---
layout: post
title:  "Improvement on TCP Sequence Number Inference Attack"
date: 2019-10-12 17:30
author: "Adam"
header-img: "img/post-bg-tcp.jpg"
catalog: true
tags:
    - Computer Network
---

# TCP序列号预测攻击的改进-N分查找法



## 一、问题的重述

​	传输控制协议 (TCP )作为一种重要的传输协议，在其安全性方面主要使用随机的初始序列号 (ISN) 来防止旁道攻击者冒充注入数据或进行重置攻击 (reset attack) 。为此，主流防火墙提供商如$Cisco^{[1]}$，$Juniper^{[2]}$等以节约资源与增强安全性为目的，在自己的产品中增加了在防火墙中进行序列号检查的功能。但讽刺的是，防火墙的这种特性也给了攻击者通过旁道攻击获取反馈，来判断测试的序列号是否合法的机会，所以将这种攻击手段命名为“TCP序列号预测攻击”。

​	在Off-Path TCP Sequence Number Inference Attack - How Firewall Middleboxes Reduce Security (Qian, Zhiyun , and Mao. Z. M. 2012) 一文中作者在32bit的序列号空间中使用类二分法(Binary-search-like)进行序列号预测在最理想情况下最长需要$log_2^{32}=32$次迭代，这在非常时间敏感的序列号预测攻击中虽然比暴力破解所需的时间短得多，但是我们仍然可以进一步通过改进算法缩短预测时间，防止引起被攻击者警觉从而提高攻击的成功率。

​	因此，在本文的研究中，重点就是要进行算法层面的改进，并综合考虑实际情况和各种影响因素（如时延、丢包等）对最终序列号预测时间的影响。



## 二、模型假设

为了使得问题更加易于理解和判断，本文作出以下合理假设：

- 假设本文涉及的防火墙设备具有TCP序列号检查功能，且默认操作为：接受在窗口内的数据包，静默丢弃不在窗口内的数据包。
- 假设防火墙所设窗口大小为64K，且窗口移动方式为*window advancing*。
- 假设攻击者从受害者处获得反馈的方式为预先植入受害者设备的恶意软件，该软件可以检测到设备特定包计数器的值并且在受害者不知情的情况下将此信息发送给攻击者。		

## 三、变量说明

​	本文建立模型的过程中主要涉及了以下变量，说明如下：

<center>表 1 变量于说明</center>

|    变量     |        说明         |
| :---------: | :-----------------: |
|    $RTT$    |      往返时延       |
|     $N$     |  将调查区间分为N份  |
|    $L_i$    | 第i次调查的区间长度 |
|    $WIN$    |     TCP窗口长度     |
|     $B$     |      网络带宽       |
| $T_{trans}$ |      传输时延       |
| $T_{prop}$  |      传播时延       |
| $T_{proc}$  |      处理时延       |
| $T_{total}$ |       总时间        |
|     $p$     |      数据包数       |
|    $MTU$    |    最大传输单元     |



## 四、模型的建立与求解

### 4.1 模型建立

​	由于TCP序列号预测攻击对于往返时间的要求远超于对于带宽的要求，尽可能减少往返次数才能有效降低预测时间。所以改进的主要思路为依靠改进算法减少预测时的测试次数。在二分法中可以每次排除当前调查区间的一半，是因为每次发送的探测包只有一或零个可以进入防火墙内，因此存下非此即彼的特性：若为一，则一定在当前区间；反之一定在另一区间。

​	不由想到：如果一次调查可以排除更大范围的区间，便可以更快速地缩小查找范围，进而预测到正确的序列号。具体方法为类二分法的推广——类N分法：将调查区间分为N个小区间进行测试，在每个小区间中依然按照原方法：在长度为$\frac{L_i}{N}​$的区间仍每间隔$2WIN​$发送报文，每个小区间共发送$\frac{L_i}{N*2WIN}​$个，其中仍然只有一个包通过。但这样做会带来一个问题：当$N>2​$时区间之间就不是非此即彼的关系，收到一个反馈也无法确定哪个小区间的包通过了防火墙。针对此问题的解决方法为使用发送不同数量包的方法**标记**各个小区间：具体为：第$1, 2, ... ,N​$个小区间内的每个报文重复发送$1, 2, ..., N​$个，从而在获得反馈时也会得到对应数字，进而每次排除$\frac{N-1}{N}​$个小区间。

​	使用本方法可以将序列号预测的轮数缩减到$log_N2^{32}$轮，$N$的取值越大则轮数越少，需要的时间也就越少。但在实际情况中$N$的取值不能无限增加，这一点将在下一节内容中展开讨论。



### 4.2 模型求解

​	在序列号预测攻击的过程中，时间开销主要包括以下方面：传输时延：数据包在攻击者的设备上产生到发送到网络上的时间；传播时延：由攻击者发送的数据包在网络上进行传输直到被受害者收到的时间；处理时延：受害者接收到数据包后对其进行处理所需的时间；反馈时延：预先植入受害者设备的恶意软件向攻击者发送反馈所需的时间（此时延也包括传输、传播、处理时延三部分，但由于其较为稳定，故可以简化整合讨论）。接下来本文将由理想条件出发，逐步达到接近真实情况下所需的总时间，并尝试求解出$N$的最佳取值。

#### 4.2.1 理想条件下的模型

​	在此情况下，我们假设只存在传播时延且恒定，包括攻击者发送数据包和从受害者处接受反馈两个过程，传输时延和处理时延不计。此时我们将传播时延记为：
$$
T_0 = RTT
$$
​	其次，我们假设网络带宽为无限大，即在同一时间可以发送任意数量的数据包，总的数据包量在这种情况下为无关变量，不加考虑。则完成一次序列号预测的理论最长时间为：
$$
T_{total}=log_N2^{32}*RTT
$$
​	可以明显看出此时预测的总时间只与$N$负相关，$N$的值越大则总时间越短。从下图中也可以看出：预测所需要的总时间在$N$的值增大的同时不断减少，且总时间在$N=2到N=10$之间迅速从$32RTT$下降到$10RTT$左右，之后则平稳下降。最极限的情况为当$N=2^{32}$时只需一个$RTT​$便可完成。

![理想情况时间图](http://adamyoung71.github.io/img/in-post/post-tcp-inference/理想情况时间图.jpg)

#### 4.2.2 进一步增加限制条件的模型求解

​	在现实情况中，网络带宽不可能为无限大，所以在攻击者发送更多数据包的同时也会相应地增加发送所需的时间。此处，我们假设使用4G网路进行通信，以中国联通平均带宽$B=3\ MB/s$为基准，假设上传和下载带宽相同。而对于攻击者所发送的数据包和接收到的反馈包来说，其包内数据部分不需要过多的内容，故假设每一个$TCP$数据包的最大传输单元（$Maximum Transmission Unit-MTU$）为除首部20字节外再加10字节的数据共计30字节；方程如下。


$$
T_{prop}=log_N^{4G}t_{prop}
$$

$$
T_{trans}=\frac{MTU*p}{B}
$$

$$
T_{total}=T_{prop}+T_{trans}
$$

$$
p=\sum_{i=1}^{log_N^{4G}}\frac{L_i}{2WIN}\sum_{j=1}^{N}j
$$

$$
L_i=\frac{4G}{N^{i}}
$$

​	联立上述式子，可以得出最终需要的时间为：
$$
T_{total} = log_N^{4G}t_{prop}+\frac{G\ MTU\ N(N^{log_N^{4G}}-1)(N-1)}{B\ N^{log_N^{4G}}WIN(N-1)}
$$
​	而对于往返时延，此情形下，传输时延不应与传播时延、处理时延合并为固定的$RTT$，而应该单独考虑。此处设为$t_{prop}$，其中包括为了避免失序而增加的填充。通过文章中的数据可计算出此值和$\frac{MTU}{B}$的大致值分别为：$0.1775$和$0.000044$。

​	既然已经得到时间总函数，接下来就是对其进行分析。可以看出：此式第一部分为总的往返时延，而第二部分则是发送全部数据包所用的总时间。按照经验判断，当$N$较小时发送的总数据包数量也较小，所以左边是主导因素；而当$N$达到某一数值后，发送数据包所用的时间将与总往返时延达到同一量级。接下来将带宽与MTU的值代入，此时总时间就成为了$N$的单变量函数。在MATLAB中用不同的N值进行测试结果如下：

![改进](http://adamyoung71.github.io/img/in-post/post-tcp-inference/改进.jpg)

​	可以看出，序列号预测所用的总时间从$N=2$的10秒左右随着$N$的增大先缩短，到$N=4$时达到最小值约7.65秒，随后因为发送的数据包数的增多时间又逐步延长。这一结果很好地符合了预测，得出$N=4$为当前情况的最优解。

#### 4.2.3进一步优化模型

​	在上一节的论述中，我们假定每一次序列号预测时$N$的值都不发生变化，而容易想到的是在探测空间缩小的时候所发送的数据包数量也会急剧缩小，所以引出此处的对模型的进一步优化：动态设置$N$的值使之根据轮数的不同而变化，例如在开始的几轮为了避免发送过多的探测数据包而使用较小的$N$，再在之后的轮次中为了缩短总时间而使用较大的$N$值。设前一过程进行$m$轮，后一过程进行$n$轮。此时的方程为：


$$
T_{total}=T_{prop}+T_{trans}
$$

$$
T_{prop}=(m+n)t_{prop}
$$

$$
T_{trans}=\frac{MTU*p}{B}
$$

$$
L_i=\begin{cases}
\frac{4G}{N_1^i} & i=m\\
\frac{4G}{N_1^mN_2^i} & i=n\\
\end{cases}
$$

$$
p=\sum_{i=1}^m\frac{N_1(N_1+1)G}{N_1^i\ WIN}+\sum_{i=1}^n\frac{N_2(N_2+1)G}{N_1^mN_2^i\ WIN}
$$

联立得到总时间：


$$
T_{total}=(m+n)t_{prop}+\frac{MTU}{B}(\frac{GN_1(N_1^m-1)(N_1+1)}{N_1^m\ WIN(N_1-1)}+\frac{GN_2(N_2^n-1)(N_2+1)}{N_1^mN_2^n\ WIN(N_2-1)})
$$
​	

此时参数共有$N_1, N_2,m$三个，$n$可以由$m$推出：$n=log_{N2}\frac{4G}{N_1^m}$。所以构造数组对其进行检验得到结果为当$N_1=2,N_2=4,m=8$时的最短时间可以达到3.5秒左右，相比于原方案有一倍左右的提升，非常可观。

#### 4.2.3 攻击模型

![attack-model](http://adamyoung71.github.io/img/in-post/post-tcp-inference/attack-model.png)

​	本模型应用在攻击模型中的流程大致为：首先，当受害者向合法服务器发送TCP连接请求时，其设备上预先植入的恶意软件会向攻击者报告这一信息；而在服务器对受害者进行回应后，攻击者会伪造大量的RST包使得服务器重置此连接，使得受害者不能正常完成三次握手从而建立TCP连接。接下来就是利用本文的模型进行序列号预测，并在预测成功后假冒合法服务器向受害者发送信息。

## 五、模型的评价

​	本文从“类二分法”的TCP序列号预测的算法出发，提出了“类N分法”预测序列号的改进算法，该算法可以有效减少探测序列号所需的轮数从而减少所需的时间，可以有效地提升预测的成功率。而之后对其的进一步改进又通过减少预测前期发送大量数据包的开支从而减少最终时间。

​	本模型当前还是理论模型，一些参数是从日常经验或论文中得到，由于水平限制并不能提供实际的实验情景并通过测量得出更加客观的参数，所以还会继续进行完善。

## 六、参考文献

[1] Cisco. Cisco ASA 5500 Series Configuration Guide using the CLI, 8.2.

[2]  Juniper. Stateful Inspection Firewalls.

[3] Qian, Zhiyun , and Z. M. Mao . " [IEEE 2012 IEEE Symposium on Security and Privacy (SP) Conference dates subject to change - San Francisco, CA, USA (2012.05.20-2012.05.23)] 2012 IEEE Symposium on Security and Privacy - Off-path TCP Sequence Number Inference Attack - How Firewall Middleboxes Reduce Security." 2012:347-361.



## 七、附录

1. MATLAB代码：

	```matlab
	%理想情况
	syms L_i N i_ WIN G;
	L_i = G/power(N, i_);
	L=L_i/(2*WIN);
	p1 = symsum(i_,1,L);
	p2 = symsum(p1, i_, 1, log(G)/log(N))
	```

2. 优化算法代码：

	```matlab
	function[T_total]=A2(n1, n2, M)
	syms T_total T_trans T_prop j_ k_ i_ G WIN N1 N2 m n MTU B;%创建变量
	p1=N1.*(N1+1).*G./(power(N1,i_).*WIN);
	p2=N2.*(N2+1).*G./(power(N1,m).*power(N2,i_).*WIN);
	p=symsum(p1,i_,1,m)+symsum(p2,i_,1,n);%数据包总数量
	T_total=0.000044.*p+(m+n).*0.1775;%总时间
	T_total=subs(T_total,N1,n1);
	T_total=subs(T_total, N2, n2);
	T_total=subs(T_total, G, power(2,30));
	T_total=subs(T_total, m, M);
	T_total=subs(T_total, WIN, power(2,16));
	T_total=subs(T_total, n, log(power(2,32)./power(n1,M))./log(n2));
	T_total=vpa(T_total);
	end
	```

	